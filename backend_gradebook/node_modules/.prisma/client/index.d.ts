
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model attendances
 * 
 */
export type attendances = $Result.DefaultSelection<Prisma.$attendancesPayload>
/**
 * Model badges
 * 
 */
export type badges = $Result.DefaultSelection<Prisma.$badgesPayload>
/**
 * Model badges_categories
 * 
 */
export type badges_categories = $Result.DefaultSelection<Prisma.$badges_categoriesPayload>
/**
 * Model badges_history
 * 
 */
export type badges_history = $Result.DefaultSelection<Prisma.$badges_historyPayload>
/**
 * Model classes
 * 
 */
export type classes = $Result.DefaultSelection<Prisma.$classesPayload>
/**
 * Model event_types
 * 
 */
export type event_types = $Result.DefaultSelection<Prisma.$event_typesPayload>
/**
 * Model grades_gradebook
 * 
 */
export type grades_gradebook = $Result.DefaultSelection<Prisma.$grades_gradebookPayload>
/**
 * Model homeworks
 * 
 */
export type homeworks = $Result.DefaultSelection<Prisma.$homeworksPayload>
/**
 * Model lessons
 * 
 */
export type lessons = $Result.DefaultSelection<Prisma.$lessonsPayload>
/**
 * Model messages
 * 
 */
export type messages = $Result.DefaultSelection<Prisma.$messagesPayload>
/**
 * Model parents
 * 
 */
export type parents = $Result.DefaultSelection<Prisma.$parentsPayload>
/**
 * Model problem_types
 * 
 */
export type problem_types = $Result.DefaultSelection<Prisma.$problem_typesPayload>
/**
 * Model problems_gradebook
 * 
 */
export type problems_gradebook = $Result.DefaultSelection<Prisma.$problems_gradebookPayload>
/**
 * Model school_events
 * 
 */
export type school_events = $Result.DefaultSelection<Prisma.$school_eventsPayload>
/**
 * Model statuses
 * 
 */
export type statuses = $Result.DefaultSelection<Prisma.$statusesPayload>
/**
 * Model students
 * 
 */
export type students = $Result.DefaultSelection<Prisma.$studentsPayload>
/**
 * Model students_parents
 * 
 */
export type students_parents = $Result.DefaultSelection<Prisma.$students_parentsPayload>
/**
 * Model subjects
 * 
 */
export type subjects = $Result.DefaultSelection<Prisma.$subjectsPayload>
/**
 * Model surveys
 * 
 */
export type surveys = $Result.DefaultSelection<Prisma.$surveysPayload>
/**
 * Model teachers
 * 
 */
export type teachers = $Result.DefaultSelection<Prisma.$teachersPayload>
/**
 * Model teachers_subjects
 * 
 */
export type teachers_subjects = $Result.DefaultSelection<Prisma.$teachers_subjectsPayload>
/**
 * Model updates
 * 
 */
export type updates = $Result.DefaultSelection<Prisma.$updatesPayload>
/**
 * Model administrators
 * 
 */
export type administrators = $Result.DefaultSelection<Prisma.$administratorsPayload>
/**
 * Model user_types
 * 
 */
export type user_types = $Result.DefaultSelection<Prisma.$user_typesPayload>
/**
 * Model school_years
 * 
 */
export type school_years = $Result.DefaultSelection<Prisma.$school_yearsPayload>
/**
 * Model semesters
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type semesters = $Result.DefaultSelection<Prisma.$semestersPayload>
/**
 * Model class_names
 * 
 */
export type class_names = $Result.DefaultSelection<Prisma.$class_namesPayload>
/**
 * Model exams
 * 
 */
export type exams = $Result.DefaultSelection<Prisma.$examsPayload>
/**
 * Model final_grades
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type final_grades = $Result.DefaultSelection<Prisma.$final_gradesPayload>
/**
 * Model questions
 * 
 */
export type questions = $Result.DefaultSelection<Prisma.$questionsPayload>
/**
 * Model questions_possible_responses
 * 
 */
export type questions_possible_responses = $Result.DefaultSelection<Prisma.$questions_possible_responsesPayload>
/**
 * Model questions_responses
 * 
 */
export type questions_responses = $Result.DefaultSelection<Prisma.$questions_responsesPayload>
/**
 * Model questions_types
 * 
 */
export type questions_types = $Result.DefaultSelection<Prisma.$questions_typesPayload>
/**
 * Model attempt_questions
 * 
 */
export type attempt_questions = $Result.DefaultSelection<Prisma.$attempt_questionsPayload>
/**
 * Model attempts
 * 
 */
export type attempts = $Result.DefaultSelection<Prisma.$attemptsPayload>
/**
 * Model classes_exams
 * 
 */
export type classes_exams = $Result.DefaultSelection<Prisma.$classes_examsPayload>
/**
 * Model closed_answers
 * 
 */
export type closed_answers = $Result.DefaultSelection<Prisma.$closed_answersPayload>
/**
 * Model closed_questions
 * 
 */
export type closed_questions = $Result.DefaultSelection<Prisma.$closed_questionsPayload>
/**
 * Model files_repository
 * 
 */
export type files_repository = $Result.DefaultSelection<Prisma.$files_repositoryPayload>
/**
 * Model gradebook_exams
 * 
 */
export type gradebook_exams = $Result.DefaultSelection<Prisma.$gradebook_examsPayload>
/**
 * Model grades_exams
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type grades_exams = $Result.DefaultSelection<Prisma.$grades_examsPayload>
/**
 * Model grading_scale
 * 
 */
export type grading_scale = $Result.DefaultSelection<Prisma.$grading_scalePayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model open_answers
 * 
 */
export type open_answers = $Result.DefaultSelection<Prisma.$open_answersPayload>
/**
 * Model open_questions
 * 
 */
export type open_questions = $Result.DefaultSelection<Prisma.$open_questionsPayload>
/**
 * Model student_closed_answers
 * 
 */
export type student_closed_answers = $Result.DefaultSelection<Prisma.$student_closed_answersPayload>
/**
 * Model student_open_answers
 * 
 */
export type student_open_answers = $Result.DefaultSelection<Prisma.$student_open_answersPayload>
/**
 * Model students_exams
 * 
 */
export type students_exams = $Result.DefaultSelection<Prisma.$students_examsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const attempt_questions_question_type: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export type attempt_questions_question_type = (typeof attempt_questions_question_type)[keyof typeof attempt_questions_question_type]

}

export type attempt_questions_question_type = $Enums.attempt_questions_question_type

export const attempt_questions_question_type: typeof $Enums.attempt_questions_question_type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Attendances
 * const attendances = await prisma.attendances.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Attendances
   * const attendances = await prisma.attendances.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.attendances`: Exposes CRUD operations for the **attendances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendances.findMany()
    * ```
    */
  get attendances(): Prisma.attendancesDelegate<ExtArgs>;

  /**
   * `prisma.badges`: Exposes CRUD operations for the **badges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badges.findMany()
    * ```
    */
  get badges(): Prisma.badgesDelegate<ExtArgs>;

  /**
   * `prisma.badges_categories`: Exposes CRUD operations for the **badges_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges_categories
    * const badges_categories = await prisma.badges_categories.findMany()
    * ```
    */
  get badges_categories(): Prisma.badges_categoriesDelegate<ExtArgs>;

  /**
   * `prisma.badges_history`: Exposes CRUD operations for the **badges_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges_histories
    * const badges_histories = await prisma.badges_history.findMany()
    * ```
    */
  get badges_history(): Prisma.badges_historyDelegate<ExtArgs>;

  /**
   * `prisma.classes`: Exposes CRUD operations for the **classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classes.findMany()
    * ```
    */
  get classes(): Prisma.classesDelegate<ExtArgs>;

  /**
   * `prisma.event_types`: Exposes CRUD operations for the **event_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_types
    * const event_types = await prisma.event_types.findMany()
    * ```
    */
  get event_types(): Prisma.event_typesDelegate<ExtArgs>;

  /**
   * `prisma.grades_gradebook`: Exposes CRUD operations for the **grades_gradebook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades_gradebooks
    * const grades_gradebooks = await prisma.grades_gradebook.findMany()
    * ```
    */
  get grades_gradebook(): Prisma.grades_gradebookDelegate<ExtArgs>;

  /**
   * `prisma.homeworks`: Exposes CRUD operations for the **homeworks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Homeworks
    * const homeworks = await prisma.homeworks.findMany()
    * ```
    */
  get homeworks(): Prisma.homeworksDelegate<ExtArgs>;

  /**
   * `prisma.lessons`: Exposes CRUD operations for the **lessons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lessons.findMany()
    * ```
    */
  get lessons(): Prisma.lessonsDelegate<ExtArgs>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.messagesDelegate<ExtArgs>;

  /**
   * `prisma.parents`: Exposes CRUD operations for the **parents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parents.findMany()
    * ```
    */
  get parents(): Prisma.parentsDelegate<ExtArgs>;

  /**
   * `prisma.problem_types`: Exposes CRUD operations for the **problem_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problem_types
    * const problem_types = await prisma.problem_types.findMany()
    * ```
    */
  get problem_types(): Prisma.problem_typesDelegate<ExtArgs>;

  /**
   * `prisma.problems_gradebook`: Exposes CRUD operations for the **problems_gradebook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problems_gradebooks
    * const problems_gradebooks = await prisma.problems_gradebook.findMany()
    * ```
    */
  get problems_gradebook(): Prisma.problems_gradebookDelegate<ExtArgs>;

  /**
   * `prisma.school_events`: Exposes CRUD operations for the **school_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more School_events
    * const school_events = await prisma.school_events.findMany()
    * ```
    */
  get school_events(): Prisma.school_eventsDelegate<ExtArgs>;

  /**
   * `prisma.statuses`: Exposes CRUD operations for the **statuses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statuses
    * const statuses = await prisma.statuses.findMany()
    * ```
    */
  get statuses(): Prisma.statusesDelegate<ExtArgs>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.studentsDelegate<ExtArgs>;

  /**
   * `prisma.students_parents`: Exposes CRUD operations for the **students_parents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students_parents
    * const students_parents = await prisma.students_parents.findMany()
    * ```
    */
  get students_parents(): Prisma.students_parentsDelegate<ExtArgs>;

  /**
   * `prisma.subjects`: Exposes CRUD operations for the **subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subjects.findMany()
    * ```
    */
  get subjects(): Prisma.subjectsDelegate<ExtArgs>;

  /**
   * `prisma.surveys`: Exposes CRUD operations for the **surveys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveys
    * const surveys = await prisma.surveys.findMany()
    * ```
    */
  get surveys(): Prisma.surveysDelegate<ExtArgs>;

  /**
   * `prisma.teachers`: Exposes CRUD operations for the **teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teachers.findMany()
    * ```
    */
  get teachers(): Prisma.teachersDelegate<ExtArgs>;

  /**
   * `prisma.teachers_subjects`: Exposes CRUD operations for the **teachers_subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers_subjects
    * const teachers_subjects = await prisma.teachers_subjects.findMany()
    * ```
    */
  get teachers_subjects(): Prisma.teachers_subjectsDelegate<ExtArgs>;

  /**
   * `prisma.updates`: Exposes CRUD operations for the **updates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Updates
    * const updates = await prisma.updates.findMany()
    * ```
    */
  get updates(): Prisma.updatesDelegate<ExtArgs>;

  /**
   * `prisma.administrators`: Exposes CRUD operations for the **administrators** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administrators
    * const administrators = await prisma.administrators.findMany()
    * ```
    */
  get administrators(): Prisma.administratorsDelegate<ExtArgs>;

  /**
   * `prisma.user_types`: Exposes CRUD operations for the **user_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_types
    * const user_types = await prisma.user_types.findMany()
    * ```
    */
  get user_types(): Prisma.user_typesDelegate<ExtArgs>;

  /**
   * `prisma.school_years`: Exposes CRUD operations for the **school_years** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more School_years
    * const school_years = await prisma.school_years.findMany()
    * ```
    */
  get school_years(): Prisma.school_yearsDelegate<ExtArgs>;

  /**
   * `prisma.semesters`: Exposes CRUD operations for the **semesters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Semesters
    * const semesters = await prisma.semesters.findMany()
    * ```
    */
  get semesters(): Prisma.semestersDelegate<ExtArgs>;

  /**
   * `prisma.class_names`: Exposes CRUD operations for the **class_names** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Class_names
    * const class_names = await prisma.class_names.findMany()
    * ```
    */
  get class_names(): Prisma.class_namesDelegate<ExtArgs>;

  /**
   * `prisma.exams`: Exposes CRUD operations for the **exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exams.findMany()
    * ```
    */
  get exams(): Prisma.examsDelegate<ExtArgs>;

  /**
   * `prisma.final_grades`: Exposes CRUD operations for the **final_grades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Final_grades
    * const final_grades = await prisma.final_grades.findMany()
    * ```
    */
  get final_grades(): Prisma.final_gradesDelegate<ExtArgs>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.questionsDelegate<ExtArgs>;

  /**
   * `prisma.questions_possible_responses`: Exposes CRUD operations for the **questions_possible_responses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions_possible_responses
    * const questions_possible_responses = await prisma.questions_possible_responses.findMany()
    * ```
    */
  get questions_possible_responses(): Prisma.questions_possible_responsesDelegate<ExtArgs>;

  /**
   * `prisma.questions_responses`: Exposes CRUD operations for the **questions_responses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions_responses
    * const questions_responses = await prisma.questions_responses.findMany()
    * ```
    */
  get questions_responses(): Prisma.questions_responsesDelegate<ExtArgs>;

  /**
   * `prisma.questions_types`: Exposes CRUD operations for the **questions_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions_types
    * const questions_types = await prisma.questions_types.findMany()
    * ```
    */
  get questions_types(): Prisma.questions_typesDelegate<ExtArgs>;

  /**
   * `prisma.attempt_questions`: Exposes CRUD operations for the **attempt_questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attempt_questions
    * const attempt_questions = await prisma.attempt_questions.findMany()
    * ```
    */
  get attempt_questions(): Prisma.attempt_questionsDelegate<ExtArgs>;

  /**
   * `prisma.attempts`: Exposes CRUD operations for the **attempts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attempts
    * const attempts = await prisma.attempts.findMany()
    * ```
    */
  get attempts(): Prisma.attemptsDelegate<ExtArgs>;

  /**
   * `prisma.classes_exams`: Exposes CRUD operations for the **classes_exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes_exams
    * const classes_exams = await prisma.classes_exams.findMany()
    * ```
    */
  get classes_exams(): Prisma.classes_examsDelegate<ExtArgs>;

  /**
   * `prisma.closed_answers`: Exposes CRUD operations for the **closed_answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Closed_answers
    * const closed_answers = await prisma.closed_answers.findMany()
    * ```
    */
  get closed_answers(): Prisma.closed_answersDelegate<ExtArgs>;

  /**
   * `prisma.closed_questions`: Exposes CRUD operations for the **closed_questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Closed_questions
    * const closed_questions = await prisma.closed_questions.findMany()
    * ```
    */
  get closed_questions(): Prisma.closed_questionsDelegate<ExtArgs>;

  /**
   * `prisma.files_repository`: Exposes CRUD operations for the **files_repository** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files_repositories
    * const files_repositories = await prisma.files_repository.findMany()
    * ```
    */
  get files_repository(): Prisma.files_repositoryDelegate<ExtArgs>;

  /**
   * `prisma.gradebook_exams`: Exposes CRUD operations for the **gradebook_exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gradebook_exams
    * const gradebook_exams = await prisma.gradebook_exams.findMany()
    * ```
    */
  get gradebook_exams(): Prisma.gradebook_examsDelegate<ExtArgs>;

  /**
   * `prisma.grades_exams`: Exposes CRUD operations for the **grades_exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades_exams
    * const grades_exams = await prisma.grades_exams.findMany()
    * ```
    */
  get grades_exams(): Prisma.grades_examsDelegate<ExtArgs>;

  /**
   * `prisma.grading_scale`: Exposes CRUD operations for the **grading_scale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grading_scales
    * const grading_scales = await prisma.grading_scale.findMany()
    * ```
    */
  get grading_scale(): Prisma.grading_scaleDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs>;

  /**
   * `prisma.open_answers`: Exposes CRUD operations for the **open_answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Open_answers
    * const open_answers = await prisma.open_answers.findMany()
    * ```
    */
  get open_answers(): Prisma.open_answersDelegate<ExtArgs>;

  /**
   * `prisma.open_questions`: Exposes CRUD operations for the **open_questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Open_questions
    * const open_questions = await prisma.open_questions.findMany()
    * ```
    */
  get open_questions(): Prisma.open_questionsDelegate<ExtArgs>;

  /**
   * `prisma.student_closed_answers`: Exposes CRUD operations for the **student_closed_answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_closed_answers
    * const student_closed_answers = await prisma.student_closed_answers.findMany()
    * ```
    */
  get student_closed_answers(): Prisma.student_closed_answersDelegate<ExtArgs>;

  /**
   * `prisma.student_open_answers`: Exposes CRUD operations for the **student_open_answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_open_answers
    * const student_open_answers = await prisma.student_open_answers.findMany()
    * ```
    */
  get student_open_answers(): Prisma.student_open_answersDelegate<ExtArgs>;

  /**
   * `prisma.students_exams`: Exposes CRUD operations for the **students_exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students_exams
    * const students_exams = await prisma.students_exams.findMany()
    * ```
    */
  get students_exams(): Prisma.students_examsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.0
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    attendances: 'attendances',
    badges: 'badges',
    badges_categories: 'badges_categories',
    badges_history: 'badges_history',
    classes: 'classes',
    event_types: 'event_types',
    grades_gradebook: 'grades_gradebook',
    homeworks: 'homeworks',
    lessons: 'lessons',
    messages: 'messages',
    parents: 'parents',
    problem_types: 'problem_types',
    problems_gradebook: 'problems_gradebook',
    school_events: 'school_events',
    statuses: 'statuses',
    students: 'students',
    students_parents: 'students_parents',
    subjects: 'subjects',
    surveys: 'surveys',
    teachers: 'teachers',
    teachers_subjects: 'teachers_subjects',
    updates: 'updates',
    administrators: 'administrators',
    user_types: 'user_types',
    school_years: 'school_years',
    semesters: 'semesters',
    class_names: 'class_names',
    exams: 'exams',
    final_grades: 'final_grades',
    questions: 'questions',
    questions_possible_responses: 'questions_possible_responses',
    questions_responses: 'questions_responses',
    questions_types: 'questions_types',
    attempt_questions: 'attempt_questions',
    attempts: 'attempts',
    classes_exams: 'classes_exams',
    closed_answers: 'closed_answers',
    closed_questions: 'closed_questions',
    files_repository: 'files_repository',
    gradebook_exams: 'gradebook_exams',
    grades_exams: 'grades_exams',
    grading_scale: 'grading_scale',
    notifications: 'notifications',
    open_answers: 'open_answers',
    open_questions: 'open_questions',
    student_closed_answers: 'student_closed_answers',
    student_open_answers: 'student_open_answers',
    students_exams: 'students_exams'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "attendances" | "badges" | "badges_categories" | "badges_history" | "classes" | "event_types" | "grades_gradebook" | "homeworks" | "lessons" | "messages" | "parents" | "problem_types" | "problems_gradebook" | "school_events" | "statuses" | "students" | "students_parents" | "subjects" | "surveys" | "teachers" | "teachers_subjects" | "updates" | "administrators" | "user_types" | "school_years" | "semesters" | "class_names" | "exams" | "final_grades" | "questions" | "questions_possible_responses" | "questions_responses" | "questions_types" | "attempt_questions" | "attempts" | "classes_exams" | "closed_answers" | "closed_questions" | "files_repository" | "gradebook_exams" | "grades_exams" | "grading_scale" | "notifications" | "open_answers" | "open_questions" | "student_closed_answers" | "student_open_answers" | "students_exams"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      attendances: {
        payload: Prisma.$attendancesPayload<ExtArgs>
        fields: Prisma.attendancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          findFirst: {
            args: Prisma.attendancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          findMany: {
            args: Prisma.attendancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>[]
          }
          create: {
            args: Prisma.attendancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          createMany: {
            args: Prisma.attendancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          update: {
            args: Prisma.attendancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          deleteMany: {
            args: Prisma.attendancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesPayload>
          }
          aggregate: {
            args: Prisma.AttendancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendances>
          }
          groupBy: {
            args: Prisma.attendancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendancesCountArgs<ExtArgs>
            result: $Utils.Optional<AttendancesCountAggregateOutputType> | number
          }
        }
      }
      badges: {
        payload: Prisma.$badgesPayload<ExtArgs>
        fields: Prisma.badgesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.badgesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.badgesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          findFirst: {
            args: Prisma.badgesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.badgesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          findMany: {
            args: Prisma.badgesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>[]
          }
          create: {
            args: Prisma.badgesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          createMany: {
            args: Prisma.badgesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.badgesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          update: {
            args: Prisma.badgesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          deleteMany: {
            args: Prisma.badgesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.badgesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.badgesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          aggregate: {
            args: Prisma.BadgesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadges>
          }
          groupBy: {
            args: Prisma.badgesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgesGroupByOutputType>[]
          }
          count: {
            args: Prisma.badgesCountArgs<ExtArgs>
            result: $Utils.Optional<BadgesCountAggregateOutputType> | number
          }
        }
      }
      badges_categories: {
        payload: Prisma.$badges_categoriesPayload<ExtArgs>
        fields: Prisma.badges_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.badges_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.badges_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload>
          }
          findFirst: {
            args: Prisma.badges_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.badges_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload>
          }
          findMany: {
            args: Prisma.badges_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload>[]
          }
          create: {
            args: Prisma.badges_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload>
          }
          createMany: {
            args: Prisma.badges_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.badges_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload>
          }
          update: {
            args: Prisma.badges_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.badges_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.badges_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.badges_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Badges_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadges_categories>
          }
          groupBy: {
            args: Prisma.badges_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Badges_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.badges_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Badges_categoriesCountAggregateOutputType> | number
          }
        }
      }
      badges_history: {
        payload: Prisma.$badges_historyPayload<ExtArgs>
        fields: Prisma.badges_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.badges_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.badges_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload>
          }
          findFirst: {
            args: Prisma.badges_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.badges_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload>
          }
          findMany: {
            args: Prisma.badges_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload>[]
          }
          create: {
            args: Prisma.badges_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload>
          }
          createMany: {
            args: Prisma.badges_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.badges_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload>
          }
          update: {
            args: Prisma.badges_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload>
          }
          deleteMany: {
            args: Prisma.badges_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.badges_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.badges_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badges_historyPayload>
          }
          aggregate: {
            args: Prisma.Badges_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadges_history>
          }
          groupBy: {
            args: Prisma.badges_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Badges_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.badges_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Badges_historyCountAggregateOutputType> | number
          }
        }
      }
      classes: {
        payload: Prisma.$classesPayload<ExtArgs>
        fields: Prisma.classesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.classesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.classesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          findFirst: {
            args: Prisma.classesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.classesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          findMany: {
            args: Prisma.classesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>[]
          }
          create: {
            args: Prisma.classesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          createMany: {
            args: Prisma.classesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.classesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          update: {
            args: Prisma.classesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          deleteMany: {
            args: Prisma.classesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.classesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.classesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          aggregate: {
            args: Prisma.ClassesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasses>
          }
          groupBy: {
            args: Prisma.classesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.classesCountArgs<ExtArgs>
            result: $Utils.Optional<ClassesCountAggregateOutputType> | number
          }
        }
      }
      event_types: {
        payload: Prisma.$event_typesPayload<ExtArgs>
        fields: Prisma.event_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload>
          }
          findFirst: {
            args: Prisma.event_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload>
          }
          findMany: {
            args: Prisma.event_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload>[]
          }
          create: {
            args: Prisma.event_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload>
          }
          createMany: {
            args: Prisma.event_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.event_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload>
          }
          update: {
            args: Prisma.event_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload>
          }
          deleteMany: {
            args: Prisma.event_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.event_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.event_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_typesPayload>
          }
          aggregate: {
            args: Prisma.Event_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent_types>
          }
          groupBy: {
            args: Prisma.event_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Event_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Event_typesCountAggregateOutputType> | number
          }
        }
      }
      grades_gradebook: {
        payload: Prisma.$grades_gradebookPayload<ExtArgs>
        fields: Prisma.grades_gradebookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grades_gradebookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grades_gradebookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload>
          }
          findFirst: {
            args: Prisma.grades_gradebookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grades_gradebookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload>
          }
          findMany: {
            args: Prisma.grades_gradebookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload>[]
          }
          create: {
            args: Prisma.grades_gradebookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload>
          }
          createMany: {
            args: Prisma.grades_gradebookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.grades_gradebookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload>
          }
          update: {
            args: Prisma.grades_gradebookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload>
          }
          deleteMany: {
            args: Prisma.grades_gradebookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grades_gradebookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.grades_gradebookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_gradebookPayload>
          }
          aggregate: {
            args: Prisma.Grades_gradebookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrades_gradebook>
          }
          groupBy: {
            args: Prisma.grades_gradebookGroupByArgs<ExtArgs>
            result: $Utils.Optional<Grades_gradebookGroupByOutputType>[]
          }
          count: {
            args: Prisma.grades_gradebookCountArgs<ExtArgs>
            result: $Utils.Optional<Grades_gradebookCountAggregateOutputType> | number
          }
        }
      }
      homeworks: {
        payload: Prisma.$homeworksPayload<ExtArgs>
        fields: Prisma.homeworksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.homeworksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.homeworksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload>
          }
          findFirst: {
            args: Prisma.homeworksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.homeworksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload>
          }
          findMany: {
            args: Prisma.homeworksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload>[]
          }
          create: {
            args: Prisma.homeworksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload>
          }
          createMany: {
            args: Prisma.homeworksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.homeworksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload>
          }
          update: {
            args: Prisma.homeworksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload>
          }
          deleteMany: {
            args: Prisma.homeworksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.homeworksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.homeworksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeworksPayload>
          }
          aggregate: {
            args: Prisma.HomeworksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomeworks>
          }
          groupBy: {
            args: Prisma.homeworksGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomeworksGroupByOutputType>[]
          }
          count: {
            args: Prisma.homeworksCountArgs<ExtArgs>
            result: $Utils.Optional<HomeworksCountAggregateOutputType> | number
          }
        }
      }
      lessons: {
        payload: Prisma.$lessonsPayload<ExtArgs>
        fields: Prisma.lessonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lessonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lessonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload>
          }
          findFirst: {
            args: Prisma.lessonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lessonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload>
          }
          findMany: {
            args: Prisma.lessonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload>[]
          }
          create: {
            args: Prisma.lessonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload>
          }
          createMany: {
            args: Prisma.lessonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.lessonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload>
          }
          update: {
            args: Prisma.lessonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload>
          }
          deleteMany: {
            args: Prisma.lessonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lessonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lessonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonsPayload>
          }
          aggregate: {
            args: Prisma.LessonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessons>
          }
          groupBy: {
            args: Prisma.lessonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lessonsCountArgs<ExtArgs>
            result: $Utils.Optional<LessonsCountAggregateOutputType> | number
          }
        }
      }
      messages: {
        payload: Prisma.$messagesPayload<ExtArgs>
        fields: Prisma.messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findFirst: {
            args: Prisma.messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findMany: {
            args: Prisma.messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          create: {
            args: Prisma.messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          createMany: {
            args: Prisma.messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          update: {
            args: Prisma.messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          deleteMany: {
            args: Prisma.messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      parents: {
        payload: Prisma.$parentsPayload<ExtArgs>
        fields: Prisma.parentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findFirst: {
            args: Prisma.parentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findMany: {
            args: Prisma.parentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          create: {
            args: Prisma.parentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          createMany: {
            args: Prisma.parentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.parentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          update: {
            args: Prisma.parentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          deleteMany: {
            args: Prisma.parentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.parentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          aggregate: {
            args: Prisma.ParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParents>
          }
          groupBy: {
            args: Prisma.parentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.parentsCountArgs<ExtArgs>
            result: $Utils.Optional<ParentsCountAggregateOutputType> | number
          }
        }
      }
      problem_types: {
        payload: Prisma.$problem_typesPayload<ExtArgs>
        fields: Prisma.problem_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.problem_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.problem_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload>
          }
          findFirst: {
            args: Prisma.problem_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.problem_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload>
          }
          findMany: {
            args: Prisma.problem_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload>[]
          }
          create: {
            args: Prisma.problem_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload>
          }
          createMany: {
            args: Prisma.problem_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.problem_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload>
          }
          update: {
            args: Prisma.problem_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload>
          }
          deleteMany: {
            args: Prisma.problem_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.problem_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.problem_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problem_typesPayload>
          }
          aggregate: {
            args: Prisma.Problem_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProblem_types>
          }
          groupBy: {
            args: Prisma.problem_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Problem_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.problem_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Problem_typesCountAggregateOutputType> | number
          }
        }
      }
      problems_gradebook: {
        payload: Prisma.$problems_gradebookPayload<ExtArgs>
        fields: Prisma.problems_gradebookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.problems_gradebookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.problems_gradebookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload>
          }
          findFirst: {
            args: Prisma.problems_gradebookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.problems_gradebookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload>
          }
          findMany: {
            args: Prisma.problems_gradebookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload>[]
          }
          create: {
            args: Prisma.problems_gradebookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload>
          }
          createMany: {
            args: Prisma.problems_gradebookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.problems_gradebookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload>
          }
          update: {
            args: Prisma.problems_gradebookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload>
          }
          deleteMany: {
            args: Prisma.problems_gradebookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.problems_gradebookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.problems_gradebookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$problems_gradebookPayload>
          }
          aggregate: {
            args: Prisma.Problems_gradebookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProblems_gradebook>
          }
          groupBy: {
            args: Prisma.problems_gradebookGroupByArgs<ExtArgs>
            result: $Utils.Optional<Problems_gradebookGroupByOutputType>[]
          }
          count: {
            args: Prisma.problems_gradebookCountArgs<ExtArgs>
            result: $Utils.Optional<Problems_gradebookCountAggregateOutputType> | number
          }
        }
      }
      school_events: {
        payload: Prisma.$school_eventsPayload<ExtArgs>
        fields: Prisma.school_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.school_eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.school_eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload>
          }
          findFirst: {
            args: Prisma.school_eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.school_eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload>
          }
          findMany: {
            args: Prisma.school_eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload>[]
          }
          create: {
            args: Prisma.school_eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload>
          }
          createMany: {
            args: Prisma.school_eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.school_eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload>
          }
          update: {
            args: Prisma.school_eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload>
          }
          deleteMany: {
            args: Prisma.school_eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.school_eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.school_eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_eventsPayload>
          }
          aggregate: {
            args: Prisma.School_eventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool_events>
          }
          groupBy: {
            args: Prisma.school_eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<School_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.school_eventsCountArgs<ExtArgs>
            result: $Utils.Optional<School_eventsCountAggregateOutputType> | number
          }
        }
      }
      statuses: {
        payload: Prisma.$statusesPayload<ExtArgs>
        fields: Prisma.statusesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statusesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statusesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload>
          }
          findFirst: {
            args: Prisma.statusesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statusesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload>
          }
          findMany: {
            args: Prisma.statusesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload>[]
          }
          create: {
            args: Prisma.statusesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload>
          }
          createMany: {
            args: Prisma.statusesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.statusesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload>
          }
          update: {
            args: Prisma.statusesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload>
          }
          deleteMany: {
            args: Prisma.statusesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statusesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.statusesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statusesPayload>
          }
          aggregate: {
            args: Prisma.StatusesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatuses>
          }
          groupBy: {
            args: Prisma.statusesGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusesGroupByOutputType>[]
          }
          count: {
            args: Prisma.statusesCountArgs<ExtArgs>
            result: $Utils.Optional<StatusesCountAggregateOutputType> | number
          }
        }
      }
      students: {
        payload: Prisma.$studentsPayload<ExtArgs>
        fields: Prisma.studentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findFirst: {
            args: Prisma.studentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findMany: {
            args: Prisma.studentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          create: {
            args: Prisma.studentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          createMany: {
            args: Prisma.studentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.studentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          update: {
            args: Prisma.studentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          deleteMany: {
            args: Prisma.studentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.studentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      students_parents: {
        payload: Prisma.$students_parentsPayload<ExtArgs>
        fields: Prisma.students_parentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.students_parentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.students_parentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload>
          }
          findFirst: {
            args: Prisma.students_parentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.students_parentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload>
          }
          findMany: {
            args: Prisma.students_parentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload>[]
          }
          create: {
            args: Prisma.students_parentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload>
          }
          createMany: {
            args: Prisma.students_parentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.students_parentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload>
          }
          update: {
            args: Prisma.students_parentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload>
          }
          deleteMany: {
            args: Prisma.students_parentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.students_parentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.students_parentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_parentsPayload>
          }
          aggregate: {
            args: Prisma.Students_parentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents_parents>
          }
          groupBy: {
            args: Prisma.students_parentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Students_parentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.students_parentsCountArgs<ExtArgs>
            result: $Utils.Optional<Students_parentsCountAggregateOutputType> | number
          }
        }
      }
      subjects: {
        payload: Prisma.$subjectsPayload<ExtArgs>
        fields: Prisma.subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findFirst: {
            args: Prisma.subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findMany: {
            args: Prisma.subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>[]
          }
          create: {
            args: Prisma.subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          createMany: {
            args: Prisma.subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          update: {
            args: Prisma.subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          deleteMany: {
            args: Prisma.subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          aggregate: {
            args: Prisma.SubjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjects>
          }
          groupBy: {
            args: Prisma.subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectsCountAggregateOutputType> | number
          }
        }
      }
      surveys: {
        payload: Prisma.$surveysPayload<ExtArgs>
        fields: Prisma.surveysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surveysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surveysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          findFirst: {
            args: Prisma.surveysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surveysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          findMany: {
            args: Prisma.surveysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>[]
          }
          create: {
            args: Prisma.surveysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          createMany: {
            args: Prisma.surveysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.surveysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          update: {
            args: Prisma.surveysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          deleteMany: {
            args: Prisma.surveysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.surveysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.surveysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surveysPayload>
          }
          aggregate: {
            args: Prisma.SurveysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveys>
          }
          groupBy: {
            args: Prisma.surveysGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveysGroupByOutputType>[]
          }
          count: {
            args: Prisma.surveysCountArgs<ExtArgs>
            result: $Utils.Optional<SurveysCountAggregateOutputType> | number
          }
        }
      }
      teachers: {
        payload: Prisma.$teachersPayload<ExtArgs>
        fields: Prisma.teachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teachersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teachersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findFirst: {
            args: Prisma.teachersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teachersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findMany: {
            args: Prisma.teachersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          create: {
            args: Prisma.teachersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          createMany: {
            args: Prisma.teachersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.teachersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          update: {
            args: Prisma.teachersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          deleteMany: {
            args: Prisma.teachersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teachersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.teachersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          aggregate: {
            args: Prisma.TeachersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachers>
          }
          groupBy: {
            args: Prisma.teachersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.teachersCountArgs<ExtArgs>
            result: $Utils.Optional<TeachersCountAggregateOutputType> | number
          }
        }
      }
      teachers_subjects: {
        payload: Prisma.$teachers_subjectsPayload<ExtArgs>
        fields: Prisma.teachers_subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teachers_subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teachers_subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload>
          }
          findFirst: {
            args: Prisma.teachers_subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teachers_subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload>
          }
          findMany: {
            args: Prisma.teachers_subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload>[]
          }
          create: {
            args: Prisma.teachers_subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload>
          }
          createMany: {
            args: Prisma.teachers_subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.teachers_subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload>
          }
          update: {
            args: Prisma.teachers_subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload>
          }
          deleteMany: {
            args: Prisma.teachers_subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teachers_subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.teachers_subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachers_subjectsPayload>
          }
          aggregate: {
            args: Prisma.Teachers_subjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachers_subjects>
          }
          groupBy: {
            args: Prisma.teachers_subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Teachers_subjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.teachers_subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<Teachers_subjectsCountAggregateOutputType> | number
          }
        }
      }
      updates: {
        payload: Prisma.$updatesPayload<ExtArgs>
        fields: Prisma.updatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.updatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.updatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload>
          }
          findFirst: {
            args: Prisma.updatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.updatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload>
          }
          findMany: {
            args: Prisma.updatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload>[]
          }
          create: {
            args: Prisma.updatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload>
          }
          createMany: {
            args: Prisma.updatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.updatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload>
          }
          update: {
            args: Prisma.updatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload>
          }
          deleteMany: {
            args: Prisma.updatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.updatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.updatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$updatesPayload>
          }
          aggregate: {
            args: Prisma.UpdatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpdates>
          }
          groupBy: {
            args: Prisma.updatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpdatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.updatesCountArgs<ExtArgs>
            result: $Utils.Optional<UpdatesCountAggregateOutputType> | number
          }
        }
      }
      administrators: {
        payload: Prisma.$administratorsPayload<ExtArgs>
        fields: Prisma.administratorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.administratorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.administratorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload>
          }
          findFirst: {
            args: Prisma.administratorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.administratorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload>
          }
          findMany: {
            args: Prisma.administratorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload>[]
          }
          create: {
            args: Prisma.administratorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload>
          }
          createMany: {
            args: Prisma.administratorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.administratorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload>
          }
          update: {
            args: Prisma.administratorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload>
          }
          deleteMany: {
            args: Prisma.administratorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.administratorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.administratorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administratorsPayload>
          }
          aggregate: {
            args: Prisma.AdministratorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrators>
          }
          groupBy: {
            args: Prisma.administratorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministratorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.administratorsCountArgs<ExtArgs>
            result: $Utils.Optional<AdministratorsCountAggregateOutputType> | number
          }
        }
      }
      user_types: {
        payload: Prisma.$user_typesPayload<ExtArgs>
        fields: Prisma.user_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload>
          }
          findFirst: {
            args: Prisma.user_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload>
          }
          findMany: {
            args: Prisma.user_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload>[]
          }
          create: {
            args: Prisma.user_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload>
          }
          createMany: {
            args: Prisma.user_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload>
          }
          update: {
            args: Prisma.user_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload>
          }
          deleteMany: {
            args: Prisma.user_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_typesPayload>
          }
          aggregate: {
            args: Prisma.User_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_types>
          }
          groupBy: {
            args: Prisma.user_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_typesCountArgs<ExtArgs>
            result: $Utils.Optional<User_typesCountAggregateOutputType> | number
          }
        }
      }
      school_years: {
        payload: Prisma.$school_yearsPayload<ExtArgs>
        fields: Prisma.school_yearsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.school_yearsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.school_yearsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload>
          }
          findFirst: {
            args: Prisma.school_yearsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.school_yearsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload>
          }
          findMany: {
            args: Prisma.school_yearsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload>[]
          }
          create: {
            args: Prisma.school_yearsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload>
          }
          createMany: {
            args: Prisma.school_yearsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.school_yearsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload>
          }
          update: {
            args: Prisma.school_yearsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload>
          }
          deleteMany: {
            args: Prisma.school_yearsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.school_yearsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.school_yearsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_yearsPayload>
          }
          aggregate: {
            args: Prisma.School_yearsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool_years>
          }
          groupBy: {
            args: Prisma.school_yearsGroupByArgs<ExtArgs>
            result: $Utils.Optional<School_yearsGroupByOutputType>[]
          }
          count: {
            args: Prisma.school_yearsCountArgs<ExtArgs>
            result: $Utils.Optional<School_yearsCountAggregateOutputType> | number
          }
        }
      }
      semesters: {
        payload: Prisma.$semestersPayload<ExtArgs>
        fields: Prisma.semestersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.semestersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.semestersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload>
          }
          findFirst: {
            args: Prisma.semestersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.semestersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload>
          }
          findMany: {
            args: Prisma.semestersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload>[]
          }
          create: {
            args: Prisma.semestersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload>
          }
          createMany: {
            args: Prisma.semestersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.semestersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload>
          }
          update: {
            args: Prisma.semestersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload>
          }
          deleteMany: {
            args: Prisma.semestersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.semestersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.semestersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semestersPayload>
          }
          aggregate: {
            args: Prisma.SemestersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemesters>
          }
          groupBy: {
            args: Prisma.semestersGroupByArgs<ExtArgs>
            result: $Utils.Optional<SemestersGroupByOutputType>[]
          }
          count: {
            args: Prisma.semestersCountArgs<ExtArgs>
            result: $Utils.Optional<SemestersCountAggregateOutputType> | number
          }
        }
      }
      class_names: {
        payload: Prisma.$class_namesPayload<ExtArgs>
        fields: Prisma.class_namesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.class_namesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.class_namesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload>
          }
          findFirst: {
            args: Prisma.class_namesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.class_namesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload>
          }
          findMany: {
            args: Prisma.class_namesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload>[]
          }
          create: {
            args: Prisma.class_namesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload>
          }
          createMany: {
            args: Prisma.class_namesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.class_namesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload>
          }
          update: {
            args: Prisma.class_namesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload>
          }
          deleteMany: {
            args: Prisma.class_namesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.class_namesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.class_namesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_namesPayload>
          }
          aggregate: {
            args: Prisma.Class_namesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass_names>
          }
          groupBy: {
            args: Prisma.class_namesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Class_namesGroupByOutputType>[]
          }
          count: {
            args: Prisma.class_namesCountArgs<ExtArgs>
            result: $Utils.Optional<Class_namesCountAggregateOutputType> | number
          }
        }
      }
      exams: {
        payload: Prisma.$examsPayload<ExtArgs>
        fields: Prisma.examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          findFirst: {
            args: Prisma.examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          findMany: {
            args: Prisma.examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>[]
          }
          create: {
            args: Prisma.examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          createMany: {
            args: Prisma.examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          update: {
            args: Prisma.examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          deleteMany: {
            args: Prisma.examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          aggregate: {
            args: Prisma.ExamsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExams>
          }
          groupBy: {
            args: Prisma.examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamsGroupByOutputType>[]
          }
          count: {
            args: Prisma.examsCountArgs<ExtArgs>
            result: $Utils.Optional<ExamsCountAggregateOutputType> | number
          }
        }
      }
      final_grades: {
        payload: Prisma.$final_gradesPayload<ExtArgs>
        fields: Prisma.final_gradesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.final_gradesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.final_gradesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload>
          }
          findFirst: {
            args: Prisma.final_gradesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.final_gradesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload>
          }
          findMany: {
            args: Prisma.final_gradesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload>[]
          }
          create: {
            args: Prisma.final_gradesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload>
          }
          createMany: {
            args: Prisma.final_gradesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.final_gradesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload>
          }
          update: {
            args: Prisma.final_gradesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload>
          }
          deleteMany: {
            args: Prisma.final_gradesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.final_gradesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.final_gradesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradesPayload>
          }
          aggregate: {
            args: Prisma.Final_gradesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinal_grades>
          }
          groupBy: {
            args: Prisma.final_gradesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Final_gradesGroupByOutputType>[]
          }
          count: {
            args: Prisma.final_gradesCountArgs<ExtArgs>
            result: $Utils.Optional<Final_gradesCountAggregateOutputType> | number
          }
        }
      }
      questions: {
        payload: Prisma.$questionsPayload<ExtArgs>
        fields: Prisma.questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findFirst: {
            args: Prisma.questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findMany: {
            args: Prisma.questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          create: {
            args: Prisma.questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          createMany: {
            args: Prisma.questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          update: {
            args: Prisma.questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          deleteMany: {
            args: Prisma.questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      questions_possible_responses: {
        payload: Prisma.$questions_possible_responsesPayload<ExtArgs>
        fields: Prisma.questions_possible_responsesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questions_possible_responsesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questions_possible_responsesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload>
          }
          findFirst: {
            args: Prisma.questions_possible_responsesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questions_possible_responsesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload>
          }
          findMany: {
            args: Prisma.questions_possible_responsesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload>[]
          }
          create: {
            args: Prisma.questions_possible_responsesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload>
          }
          createMany: {
            args: Prisma.questions_possible_responsesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questions_possible_responsesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload>
          }
          update: {
            args: Prisma.questions_possible_responsesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload>
          }
          deleteMany: {
            args: Prisma.questions_possible_responsesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questions_possible_responsesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questions_possible_responsesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_possible_responsesPayload>
          }
          aggregate: {
            args: Prisma.Questions_possible_responsesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions_possible_responses>
          }
          groupBy: {
            args: Prisma.questions_possible_responsesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Questions_possible_responsesGroupByOutputType>[]
          }
          count: {
            args: Prisma.questions_possible_responsesCountArgs<ExtArgs>
            result: $Utils.Optional<Questions_possible_responsesCountAggregateOutputType> | number
          }
        }
      }
      questions_responses: {
        payload: Prisma.$questions_responsesPayload<ExtArgs>
        fields: Prisma.questions_responsesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questions_responsesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questions_responsesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload>
          }
          findFirst: {
            args: Prisma.questions_responsesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questions_responsesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload>
          }
          findMany: {
            args: Prisma.questions_responsesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload>[]
          }
          create: {
            args: Prisma.questions_responsesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload>
          }
          createMany: {
            args: Prisma.questions_responsesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questions_responsesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload>
          }
          update: {
            args: Prisma.questions_responsesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload>
          }
          deleteMany: {
            args: Prisma.questions_responsesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questions_responsesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questions_responsesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_responsesPayload>
          }
          aggregate: {
            args: Prisma.Questions_responsesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions_responses>
          }
          groupBy: {
            args: Prisma.questions_responsesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Questions_responsesGroupByOutputType>[]
          }
          count: {
            args: Prisma.questions_responsesCountArgs<ExtArgs>
            result: $Utils.Optional<Questions_responsesCountAggregateOutputType> | number
          }
        }
      }
      questions_types: {
        payload: Prisma.$questions_typesPayload<ExtArgs>
        fields: Prisma.questions_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questions_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questions_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload>
          }
          findFirst: {
            args: Prisma.questions_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questions_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload>
          }
          findMany: {
            args: Prisma.questions_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload>[]
          }
          create: {
            args: Prisma.questions_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload>
          }
          createMany: {
            args: Prisma.questions_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questions_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload>
          }
          update: {
            args: Prisma.questions_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload>
          }
          deleteMany: {
            args: Prisma.questions_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questions_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questions_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questions_typesPayload>
          }
          aggregate: {
            args: Prisma.Questions_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions_types>
          }
          groupBy: {
            args: Prisma.questions_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Questions_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.questions_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Questions_typesCountAggregateOutputType> | number
          }
        }
      }
      attempt_questions: {
        payload: Prisma.$attempt_questionsPayload<ExtArgs>
        fields: Prisma.attempt_questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attempt_questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attempt_questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload>
          }
          findFirst: {
            args: Prisma.attempt_questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attempt_questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload>
          }
          findMany: {
            args: Prisma.attempt_questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload>[]
          }
          create: {
            args: Prisma.attempt_questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload>
          }
          createMany: {
            args: Prisma.attempt_questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attempt_questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload>
          }
          update: {
            args: Prisma.attempt_questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload>
          }
          deleteMany: {
            args: Prisma.attempt_questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attempt_questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attempt_questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attempt_questionsPayload>
          }
          aggregate: {
            args: Prisma.Attempt_questionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttempt_questions>
          }
          groupBy: {
            args: Prisma.attempt_questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Attempt_questionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.attempt_questionsCountArgs<ExtArgs>
            result: $Utils.Optional<Attempt_questionsCountAggregateOutputType> | number
          }
        }
      }
      attempts: {
        payload: Prisma.$attemptsPayload<ExtArgs>
        fields: Prisma.attemptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attemptsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attemptsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload>
          }
          findFirst: {
            args: Prisma.attemptsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attemptsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload>
          }
          findMany: {
            args: Prisma.attemptsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload>[]
          }
          create: {
            args: Prisma.attemptsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload>
          }
          createMany: {
            args: Prisma.attemptsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attemptsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload>
          }
          update: {
            args: Prisma.attemptsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload>
          }
          deleteMany: {
            args: Prisma.attemptsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attemptsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attemptsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attemptsPayload>
          }
          aggregate: {
            args: Prisma.AttemptsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttempts>
          }
          groupBy: {
            args: Prisma.attemptsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttemptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.attemptsCountArgs<ExtArgs>
            result: $Utils.Optional<AttemptsCountAggregateOutputType> | number
          }
        }
      }
      classes_exams: {
        payload: Prisma.$classes_examsPayload<ExtArgs>
        fields: Prisma.classes_examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.classes_examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.classes_examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload>
          }
          findFirst: {
            args: Prisma.classes_examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.classes_examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload>
          }
          findMany: {
            args: Prisma.classes_examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload>[]
          }
          create: {
            args: Prisma.classes_examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload>
          }
          createMany: {
            args: Prisma.classes_examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.classes_examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload>
          }
          update: {
            args: Prisma.classes_examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload>
          }
          deleteMany: {
            args: Prisma.classes_examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.classes_examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.classes_examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classes_examsPayload>
          }
          aggregate: {
            args: Prisma.Classes_examsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasses_exams>
          }
          groupBy: {
            args: Prisma.classes_examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Classes_examsGroupByOutputType>[]
          }
          count: {
            args: Prisma.classes_examsCountArgs<ExtArgs>
            result: $Utils.Optional<Classes_examsCountAggregateOutputType> | number
          }
        }
      }
      closed_answers: {
        payload: Prisma.$closed_answersPayload<ExtArgs>
        fields: Prisma.closed_answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.closed_answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.closed_answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload>
          }
          findFirst: {
            args: Prisma.closed_answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.closed_answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload>
          }
          findMany: {
            args: Prisma.closed_answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload>[]
          }
          create: {
            args: Prisma.closed_answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload>
          }
          createMany: {
            args: Prisma.closed_answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.closed_answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload>
          }
          update: {
            args: Prisma.closed_answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload>
          }
          deleteMany: {
            args: Prisma.closed_answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.closed_answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.closed_answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_answersPayload>
          }
          aggregate: {
            args: Prisma.Closed_answersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClosed_answers>
          }
          groupBy: {
            args: Prisma.closed_answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Closed_answersGroupByOutputType>[]
          }
          count: {
            args: Prisma.closed_answersCountArgs<ExtArgs>
            result: $Utils.Optional<Closed_answersCountAggregateOutputType> | number
          }
        }
      }
      closed_questions: {
        payload: Prisma.$closed_questionsPayload<ExtArgs>
        fields: Prisma.closed_questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.closed_questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.closed_questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload>
          }
          findFirst: {
            args: Prisma.closed_questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.closed_questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload>
          }
          findMany: {
            args: Prisma.closed_questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload>[]
          }
          create: {
            args: Prisma.closed_questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload>
          }
          createMany: {
            args: Prisma.closed_questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.closed_questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload>
          }
          update: {
            args: Prisma.closed_questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload>
          }
          deleteMany: {
            args: Prisma.closed_questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.closed_questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.closed_questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$closed_questionsPayload>
          }
          aggregate: {
            args: Prisma.Closed_questionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClosed_questions>
          }
          groupBy: {
            args: Prisma.closed_questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Closed_questionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.closed_questionsCountArgs<ExtArgs>
            result: $Utils.Optional<Closed_questionsCountAggregateOutputType> | number
          }
        }
      }
      files_repository: {
        payload: Prisma.$files_repositoryPayload<ExtArgs>
        fields: Prisma.files_repositoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.files_repositoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.files_repositoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload>
          }
          findFirst: {
            args: Prisma.files_repositoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.files_repositoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload>
          }
          findMany: {
            args: Prisma.files_repositoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload>[]
          }
          create: {
            args: Prisma.files_repositoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload>
          }
          createMany: {
            args: Prisma.files_repositoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.files_repositoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload>
          }
          update: {
            args: Prisma.files_repositoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload>
          }
          deleteMany: {
            args: Prisma.files_repositoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.files_repositoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.files_repositoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$files_repositoryPayload>
          }
          aggregate: {
            args: Prisma.Files_repositoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiles_repository>
          }
          groupBy: {
            args: Prisma.files_repositoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Files_repositoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.files_repositoryCountArgs<ExtArgs>
            result: $Utils.Optional<Files_repositoryCountAggregateOutputType> | number
          }
        }
      }
      gradebook_exams: {
        payload: Prisma.$gradebook_examsPayload<ExtArgs>
        fields: Prisma.gradebook_examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gradebook_examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gradebook_examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload>
          }
          findFirst: {
            args: Prisma.gradebook_examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gradebook_examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload>
          }
          findMany: {
            args: Prisma.gradebook_examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload>[]
          }
          create: {
            args: Prisma.gradebook_examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload>
          }
          createMany: {
            args: Prisma.gradebook_examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gradebook_examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload>
          }
          update: {
            args: Prisma.gradebook_examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload>
          }
          deleteMany: {
            args: Prisma.gradebook_examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gradebook_examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gradebook_examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gradebook_examsPayload>
          }
          aggregate: {
            args: Prisma.Gradebook_examsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradebook_exams>
          }
          groupBy: {
            args: Prisma.gradebook_examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gradebook_examsGroupByOutputType>[]
          }
          count: {
            args: Prisma.gradebook_examsCountArgs<ExtArgs>
            result: $Utils.Optional<Gradebook_examsCountAggregateOutputType> | number
          }
        }
      }
      grades_exams: {
        payload: Prisma.$grades_examsPayload<ExtArgs>
        fields: Prisma.grades_examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grades_examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grades_examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload>
          }
          findFirst: {
            args: Prisma.grades_examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grades_examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload>
          }
          findMany: {
            args: Prisma.grades_examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload>[]
          }
          create: {
            args: Prisma.grades_examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload>
          }
          createMany: {
            args: Prisma.grades_examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.grades_examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload>
          }
          update: {
            args: Prisma.grades_examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload>
          }
          deleteMany: {
            args: Prisma.grades_examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grades_examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.grades_examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grades_examsPayload>
          }
          aggregate: {
            args: Prisma.Grades_examsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrades_exams>
          }
          groupBy: {
            args: Prisma.grades_examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Grades_examsGroupByOutputType>[]
          }
          count: {
            args: Prisma.grades_examsCountArgs<ExtArgs>
            result: $Utils.Optional<Grades_examsCountAggregateOutputType> | number
          }
        }
      }
      grading_scale: {
        payload: Prisma.$grading_scalePayload<ExtArgs>
        fields: Prisma.grading_scaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grading_scaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grading_scaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload>
          }
          findFirst: {
            args: Prisma.grading_scaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grading_scaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload>
          }
          findMany: {
            args: Prisma.grading_scaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload>[]
          }
          create: {
            args: Prisma.grading_scaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload>
          }
          createMany: {
            args: Prisma.grading_scaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.grading_scaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload>
          }
          update: {
            args: Prisma.grading_scaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload>
          }
          deleteMany: {
            args: Prisma.grading_scaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grading_scaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.grading_scaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grading_scalePayload>
          }
          aggregate: {
            args: Prisma.Grading_scaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrading_scale>
          }
          groupBy: {
            args: Prisma.grading_scaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Grading_scaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.grading_scaleCountArgs<ExtArgs>
            result: $Utils.Optional<Grading_scaleCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      open_answers: {
        payload: Prisma.$open_answersPayload<ExtArgs>
        fields: Prisma.open_answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.open_answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.open_answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload>
          }
          findFirst: {
            args: Prisma.open_answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.open_answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload>
          }
          findMany: {
            args: Prisma.open_answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload>[]
          }
          create: {
            args: Prisma.open_answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload>
          }
          createMany: {
            args: Prisma.open_answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.open_answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload>
          }
          update: {
            args: Prisma.open_answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload>
          }
          deleteMany: {
            args: Prisma.open_answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.open_answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.open_answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_answersPayload>
          }
          aggregate: {
            args: Prisma.Open_answersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpen_answers>
          }
          groupBy: {
            args: Prisma.open_answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Open_answersGroupByOutputType>[]
          }
          count: {
            args: Prisma.open_answersCountArgs<ExtArgs>
            result: $Utils.Optional<Open_answersCountAggregateOutputType> | number
          }
        }
      }
      open_questions: {
        payload: Prisma.$open_questionsPayload<ExtArgs>
        fields: Prisma.open_questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.open_questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.open_questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload>
          }
          findFirst: {
            args: Prisma.open_questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.open_questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload>
          }
          findMany: {
            args: Prisma.open_questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload>[]
          }
          create: {
            args: Prisma.open_questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload>
          }
          createMany: {
            args: Prisma.open_questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.open_questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload>
          }
          update: {
            args: Prisma.open_questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload>
          }
          deleteMany: {
            args: Prisma.open_questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.open_questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.open_questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$open_questionsPayload>
          }
          aggregate: {
            args: Prisma.Open_questionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpen_questions>
          }
          groupBy: {
            args: Prisma.open_questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Open_questionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.open_questionsCountArgs<ExtArgs>
            result: $Utils.Optional<Open_questionsCountAggregateOutputType> | number
          }
        }
      }
      student_closed_answers: {
        payload: Prisma.$student_closed_answersPayload<ExtArgs>
        fields: Prisma.student_closed_answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_closed_answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_closed_answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload>
          }
          findFirst: {
            args: Prisma.student_closed_answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_closed_answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload>
          }
          findMany: {
            args: Prisma.student_closed_answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload>[]
          }
          create: {
            args: Prisma.student_closed_answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload>
          }
          createMany: {
            args: Prisma.student_closed_answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.student_closed_answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload>
          }
          update: {
            args: Prisma.student_closed_answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload>
          }
          deleteMany: {
            args: Prisma.student_closed_answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_closed_answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_closed_answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_closed_answersPayload>
          }
          aggregate: {
            args: Prisma.Student_closed_answersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_closed_answers>
          }
          groupBy: {
            args: Prisma.student_closed_answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_closed_answersGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_closed_answersCountArgs<ExtArgs>
            result: $Utils.Optional<Student_closed_answersCountAggregateOutputType> | number
          }
        }
      }
      student_open_answers: {
        payload: Prisma.$student_open_answersPayload<ExtArgs>
        fields: Prisma.student_open_answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_open_answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_open_answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload>
          }
          findFirst: {
            args: Prisma.student_open_answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_open_answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload>
          }
          findMany: {
            args: Prisma.student_open_answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload>[]
          }
          create: {
            args: Prisma.student_open_answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload>
          }
          createMany: {
            args: Prisma.student_open_answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.student_open_answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload>
          }
          update: {
            args: Prisma.student_open_answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload>
          }
          deleteMany: {
            args: Prisma.student_open_answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_open_answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_open_answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_open_answersPayload>
          }
          aggregate: {
            args: Prisma.Student_open_answersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_open_answers>
          }
          groupBy: {
            args: Prisma.student_open_answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_open_answersGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_open_answersCountArgs<ExtArgs>
            result: $Utils.Optional<Student_open_answersCountAggregateOutputType> | number
          }
        }
      }
      students_exams: {
        payload: Prisma.$students_examsPayload<ExtArgs>
        fields: Prisma.students_examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.students_examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.students_examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload>
          }
          findFirst: {
            args: Prisma.students_examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.students_examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload>
          }
          findMany: {
            args: Prisma.students_examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload>[]
          }
          create: {
            args: Prisma.students_examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload>
          }
          createMany: {
            args: Prisma.students_examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.students_examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload>
          }
          update: {
            args: Prisma.students_examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload>
          }
          deleteMany: {
            args: Prisma.students_examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.students_examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.students_examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$students_examsPayload>
          }
          aggregate: {
            args: Prisma.Students_examsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents_exams>
          }
          groupBy: {
            args: Prisma.students_examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Students_examsGroupByOutputType>[]
          }
          count: {
            args: Prisma.students_examsCountArgs<ExtArgs>
            result: $Utils.Optional<Students_examsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BadgesCountOutputType
   */

  export type BadgesCountOutputType = {
    badges_history: number
  }

  export type BadgesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges_history?: boolean | BadgesCountOutputTypeCountBadges_historyArgs
  }

  // Custom InputTypes
  /**
   * BadgesCountOutputType without action
   */
  export type BadgesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgesCountOutputType
     */
    select?: BadgesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgesCountOutputType without action
   */
  export type BadgesCountOutputTypeCountBadges_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badges_historyWhereInput
  }


  /**
   * Count Type Badges_categoriesCountOutputType
   */

  export type Badges_categoriesCountOutputType = {
    badges: number
  }

  export type Badges_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | Badges_categoriesCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * Badges_categoriesCountOutputType without action
   */
  export type Badges_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badges_categoriesCountOutputType
     */
    select?: Badges_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Badges_categoriesCountOutputType without action
   */
  export type Badges_categoriesCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgesWhereInput
  }


  /**
   * Count Type ClassesCountOutputType
   */

  export type ClassesCountOutputType = {
    classes_exams: number
    lessons: number
    students: number
  }

  export type ClassesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes_exams?: boolean | ClassesCountOutputTypeCountClasses_examsArgs
    lessons?: boolean | ClassesCountOutputTypeCountLessonsArgs
    students?: boolean | ClassesCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassesCountOutputType
     */
    select?: ClassesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountClasses_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classes_examsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonsWhereInput
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
  }


  /**
   * Count Type Event_typesCountOutputType
   */

  export type Event_typesCountOutputType = {
    school_events: number
  }

  export type Event_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school_events?: boolean | Event_typesCountOutputTypeCountSchool_eventsArgs
  }

  // Custom InputTypes
  /**
   * Event_typesCountOutputType without action
   */
  export type Event_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event_typesCountOutputType
     */
    select?: Event_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Event_typesCountOutputType without action
   */
  export type Event_typesCountOutputTypeCountSchool_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_eventsWhereInput
  }


  /**
   * Count Type LessonsCountOutputType
   */

  export type LessonsCountOutputType = {
    attendances: number
    exams: number
    gradebook_exams: number
  }

  export type LessonsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | LessonsCountOutputTypeCountAttendancesArgs
    exams?: boolean | LessonsCountOutputTypeCountExamsArgs
    gradebook_exams?: boolean | LessonsCountOutputTypeCountGradebook_examsArgs
  }

  // Custom InputTypes
  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonsCountOutputType
     */
    select?: LessonsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesWhereInput
  }

  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examsWhereInput
  }

  /**
   * LessonsCountOutputType without action
   */
  export type LessonsCountOutputTypeCountGradebook_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gradebook_examsWhereInput
  }


  /**
   * Count Type ParentsCountOutputType
   */

  export type ParentsCountOutputType = {
    students_parents: number
  }

  export type ParentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students_parents?: boolean | ParentsCountOutputTypeCountStudents_parentsArgs
  }

  // Custom InputTypes
  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentsCountOutputType
     */
    select?: ParentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeCountStudents_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: students_parentsWhereInput
  }


  /**
   * Count Type Problem_typesCountOutputType
   */

  export type Problem_typesCountOutputType = {
    problems_gradebook: number
  }

  export type Problem_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems_gradebook?: boolean | Problem_typesCountOutputTypeCountProblems_gradebookArgs
  }

  // Custom InputTypes
  /**
   * Problem_typesCountOutputType without action
   */
  export type Problem_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem_typesCountOutputType
     */
    select?: Problem_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Problem_typesCountOutputType without action
   */
  export type Problem_typesCountOutputTypeCountProblems_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problems_gradebookWhereInput
  }


  /**
   * Count Type StatusesCountOutputType
   */

  export type StatusesCountOutputType = {
    problems_gradebook: number
  }

  export type StatusesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems_gradebook?: boolean | StatusesCountOutputTypeCountProblems_gradebookArgs
  }

  // Custom InputTypes
  /**
   * StatusesCountOutputType without action
   */
  export type StatusesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusesCountOutputType
     */
    select?: StatusesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatusesCountOutputType without action
   */
  export type StatusesCountOutputTypeCountProblems_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problems_gradebookWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    attempts: number
    attendances: number
    badges_history: number
    final_grades: number
    grades_exams: number
    grades_gradebook: number
    notifications: number
    questions_responses: number
    student_closed_answers: number
    student_open_answers: number
    students_exams: number
    students_parents: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | StudentsCountOutputTypeCountAttemptsArgs
    attendances?: boolean | StudentsCountOutputTypeCountAttendancesArgs
    badges_history?: boolean | StudentsCountOutputTypeCountBadges_historyArgs
    final_grades?: boolean | StudentsCountOutputTypeCountFinal_gradesArgs
    grades_exams?: boolean | StudentsCountOutputTypeCountGrades_examsArgs
    grades_gradebook?: boolean | StudentsCountOutputTypeCountGrades_gradebookArgs
    notifications?: boolean | StudentsCountOutputTypeCountNotificationsArgs
    questions_responses?: boolean | StudentsCountOutputTypeCountQuestions_responsesArgs
    student_closed_answers?: boolean | StudentsCountOutputTypeCountStudent_closed_answersArgs
    student_open_answers?: boolean | StudentsCountOutputTypeCountStudent_open_answersArgs
    students_exams?: boolean | StudentsCountOutputTypeCountStudents_examsArgs
    students_parents?: boolean | StudentsCountOutputTypeCountStudents_parentsArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attemptsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountBadges_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badges_historyWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountFinal_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountGrades_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grades_examsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountGrades_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grades_gradebookWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountQuestions_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questions_responsesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_closed_answersWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_open_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_open_answersWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudents_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: students_examsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudents_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: students_parentsWhereInput
  }


  /**
   * Count Type SubjectsCountOutputType
   */

  export type SubjectsCountOutputType = {
    final_grades: number
    grades_gradebook: number
    lessons: number
    teachers_subjects: number
  }

  export type SubjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grades?: boolean | SubjectsCountOutputTypeCountFinal_gradesArgs
    grades_gradebook?: boolean | SubjectsCountOutputTypeCountGrades_gradebookArgs
    lessons?: boolean | SubjectsCountOutputTypeCountLessonsArgs
    teachers_subjects?: boolean | SubjectsCountOutputTypeCountTeachers_subjectsArgs
  }

  // Custom InputTypes
  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectsCountOutputType
     */
    select?: SubjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountFinal_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradesWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountGrades_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grades_gradebookWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonsWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountTeachers_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachers_subjectsWhereInput
  }


  /**
   * Count Type SurveysCountOutputType
   */

  export type SurveysCountOutputType = {
    questions: number
  }

  export type SurveysCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | SurveysCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * SurveysCountOutputType without action
   */
  export type SurveysCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveysCountOutputType
     */
    select?: SurveysCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveysCountOutputType without action
   */
  export type SurveysCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type TeachersCountOutputType
   */

  export type TeachersCountOutputType = {
    classes: number
    exams: number
    final_grades: number
    grades_gradebook: number
    lessons: number
    teachers_subjects: number
  }

  export type TeachersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | TeachersCountOutputTypeCountClassesArgs
    exams?: boolean | TeachersCountOutputTypeCountExamsArgs
    final_grades?: boolean | TeachersCountOutputTypeCountFinal_gradesArgs
    grades_gradebook?: boolean | TeachersCountOutputTypeCountGrades_gradebookArgs
    lessons?: boolean | TeachersCountOutputTypeCountLessonsArgs
    teachers_subjects?: boolean | TeachersCountOutputTypeCountTeachers_subjectsArgs
  }

  // Custom InputTypes
  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachersCountOutputType
     */
    select?: TeachersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examsWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountFinal_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradesWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountGrades_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grades_gradebookWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonsWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountTeachers_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachers_subjectsWhereInput
  }


  /**
   * Count Type User_typesCountOutputType
   */

  export type User_typesCountOutputType = {
    messages_messages_sender_type_idTouser_types: number
    messages_messages_receiver_type_idTouser_types: number
    problems_gradebook: number
  }

  export type User_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages_messages_sender_type_idTouser_types?: boolean | User_typesCountOutputTypeCountMessages_messages_sender_type_idTouser_typesArgs
    messages_messages_receiver_type_idTouser_types?: boolean | User_typesCountOutputTypeCountMessages_messages_receiver_type_idTouser_typesArgs
    problems_gradebook?: boolean | User_typesCountOutputTypeCountProblems_gradebookArgs
  }

  // Custom InputTypes
  /**
   * User_typesCountOutputType without action
   */
  export type User_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_typesCountOutputType
     */
    select?: User_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * User_typesCountOutputType without action
   */
  export type User_typesCountOutputTypeCountMessages_messages_sender_type_idTouser_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * User_typesCountOutputType without action
   */
  export type User_typesCountOutputTypeCountMessages_messages_receiver_type_idTouser_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * User_typesCountOutputType without action
   */
  export type User_typesCountOutputTypeCountProblems_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problems_gradebookWhereInput
  }


  /**
   * Count Type School_yearsCountOutputType
   */

  export type School_yearsCountOutputType = {
    classes: number
    semesters: number
  }

  export type School_yearsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | School_yearsCountOutputTypeCountClassesArgs
    semesters?: boolean | School_yearsCountOutputTypeCountSemestersArgs
  }

  // Custom InputTypes
  /**
   * School_yearsCountOutputType without action
   */
  export type School_yearsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School_yearsCountOutputType
     */
    select?: School_yearsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * School_yearsCountOutputType without action
   */
  export type School_yearsCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
  }

  /**
   * School_yearsCountOutputType without action
   */
  export type School_yearsCountOutputTypeCountSemestersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: semestersWhereInput
  }


  /**
   * Count Type SemestersCountOutputType
   */

  export type SemestersCountOutputType = {
    final_grades: number
  }

  export type SemestersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grades?: boolean | SemestersCountOutputTypeCountFinal_gradesArgs
  }

  // Custom InputTypes
  /**
   * SemestersCountOutputType without action
   */
  export type SemestersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemestersCountOutputType
     */
    select?: SemestersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SemestersCountOutputType without action
   */
  export type SemestersCountOutputTypeCountFinal_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradesWhereInput
  }


  /**
   * Count Type Class_namesCountOutputType
   */

  export type Class_namesCountOutputType = {
    classes: number
  }

  export type Class_namesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | Class_namesCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * Class_namesCountOutputType without action
   */
  export type Class_namesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class_namesCountOutputType
     */
    select?: Class_namesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Class_namesCountOutputType without action
   */
  export type Class_namesCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
  }


  /**
   * Count Type ExamsCountOutputType
   */

  export type ExamsCountOutputType = {
    attempts: number
    classes_exams: number
    closed_questions: number
    files_repository: number
    grades_exams: number
    notifications: number
    open_questions: number
    students_exams: number
  }

  export type ExamsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | ExamsCountOutputTypeCountAttemptsArgs
    classes_exams?: boolean | ExamsCountOutputTypeCountClasses_examsArgs
    closed_questions?: boolean | ExamsCountOutputTypeCountClosed_questionsArgs
    files_repository?: boolean | ExamsCountOutputTypeCountFiles_repositoryArgs
    grades_exams?: boolean | ExamsCountOutputTypeCountGrades_examsArgs
    notifications?: boolean | ExamsCountOutputTypeCountNotificationsArgs
    open_questions?: boolean | ExamsCountOutputTypeCountOpen_questionsArgs
    students_exams?: boolean | ExamsCountOutputTypeCountStudents_examsArgs
  }

  // Custom InputTypes
  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamsCountOutputType
     */
    select?: ExamsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attemptsWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountClasses_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classes_examsWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountClosed_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: closed_questionsWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountFiles_repositoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: files_repositoryWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountGrades_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grades_examsWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountOpen_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: open_questionsWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountStudents_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: students_examsWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    questions_possible_responses: number
    questions_responses: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions_possible_responses?: boolean | QuestionsCountOutputTypeCountQuestions_possible_responsesArgs
    questions_responses?: boolean | QuestionsCountOutputTypeCountQuestions_responsesArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountQuestions_possible_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questions_possible_responsesWhereInput
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountQuestions_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questions_responsesWhereInput
  }


  /**
   * Count Type Questions_typesCountOutputType
   */

  export type Questions_typesCountOutputType = {
    questions: number
  }

  export type Questions_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Questions_typesCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * Questions_typesCountOutputType without action
   */
  export type Questions_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions_typesCountOutputType
     */
    select?: Questions_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Questions_typesCountOutputType without action
   */
  export type Questions_typesCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type AttemptsCountOutputType
   */

  export type AttemptsCountOutputType = {
    attempt_questions: number
    student_closed_answers: number
    student_open_answers: number
  }

  export type AttemptsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt_questions?: boolean | AttemptsCountOutputTypeCountAttempt_questionsArgs
    student_closed_answers?: boolean | AttemptsCountOutputTypeCountStudent_closed_answersArgs
    student_open_answers?: boolean | AttemptsCountOutputTypeCountStudent_open_answersArgs
  }

  // Custom InputTypes
  /**
   * AttemptsCountOutputType without action
   */
  export type AttemptsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttemptsCountOutputType
     */
    select?: AttemptsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttemptsCountOutputType without action
   */
  export type AttemptsCountOutputTypeCountAttempt_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attempt_questionsWhereInput
  }

  /**
   * AttemptsCountOutputType without action
   */
  export type AttemptsCountOutputTypeCountStudent_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_closed_answersWhereInput
  }

  /**
   * AttemptsCountOutputType without action
   */
  export type AttemptsCountOutputTypeCountStudent_open_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_open_answersWhereInput
  }


  /**
   * Count Type Closed_answersCountOutputType
   */

  export type Closed_answersCountOutputType = {
    student_closed_answers: number
  }

  export type Closed_answersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_closed_answers?: boolean | Closed_answersCountOutputTypeCountStudent_closed_answersArgs
  }

  // Custom InputTypes
  /**
   * Closed_answersCountOutputType without action
   */
  export type Closed_answersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closed_answersCountOutputType
     */
    select?: Closed_answersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Closed_answersCountOutputType without action
   */
  export type Closed_answersCountOutputTypeCountStudent_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_closed_answersWhereInput
  }


  /**
   * Count Type Closed_questionsCountOutputType
   */

  export type Closed_questionsCountOutputType = {
    attempt_questions: number
    closed_answers: number
    student_closed_answers: number
  }

  export type Closed_questionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt_questions?: boolean | Closed_questionsCountOutputTypeCountAttempt_questionsArgs
    closed_answers?: boolean | Closed_questionsCountOutputTypeCountClosed_answersArgs
    student_closed_answers?: boolean | Closed_questionsCountOutputTypeCountStudent_closed_answersArgs
  }

  // Custom InputTypes
  /**
   * Closed_questionsCountOutputType without action
   */
  export type Closed_questionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closed_questionsCountOutputType
     */
    select?: Closed_questionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Closed_questionsCountOutputType without action
   */
  export type Closed_questionsCountOutputTypeCountAttempt_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attempt_questionsWhereInput
  }

  /**
   * Closed_questionsCountOutputType without action
   */
  export type Closed_questionsCountOutputTypeCountClosed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: closed_answersWhereInput
  }

  /**
   * Closed_questionsCountOutputType without action
   */
  export type Closed_questionsCountOutputTypeCountStudent_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_closed_answersWhereInput
  }


  /**
   * Count Type Open_questionsCountOutputType
   */

  export type Open_questionsCountOutputType = {
    attempt_questions: number
    open_answers: number
    student_open_answers: number
  }

  export type Open_questionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt_questions?: boolean | Open_questionsCountOutputTypeCountAttempt_questionsArgs
    open_answers?: boolean | Open_questionsCountOutputTypeCountOpen_answersArgs
    student_open_answers?: boolean | Open_questionsCountOutputTypeCountStudent_open_answersArgs
  }

  // Custom InputTypes
  /**
   * Open_questionsCountOutputType without action
   */
  export type Open_questionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Open_questionsCountOutputType
     */
    select?: Open_questionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Open_questionsCountOutputType without action
   */
  export type Open_questionsCountOutputTypeCountAttempt_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attempt_questionsWhereInput
  }

  /**
   * Open_questionsCountOutputType without action
   */
  export type Open_questionsCountOutputTypeCountOpen_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: open_answersWhereInput
  }

  /**
   * Open_questionsCountOutputType without action
   */
  export type Open_questionsCountOutputTypeCountStudent_open_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_open_answersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model attendances
   */

  export type AggregateAttendances = {
    _count: AttendancesCountAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  export type AttendancesMinAggregateOutputType = {
    id: Uint8Array | null
    date_time: Date | null
    was_present: boolean | null
    was_late: boolean | null
    was_excused: boolean | null
    student_id: Uint8Array | null
    lesson_id: Uint8Array | null
  }

  export type AttendancesMaxAggregateOutputType = {
    id: Uint8Array | null
    date_time: Date | null
    was_present: boolean | null
    was_late: boolean | null
    was_excused: boolean | null
    student_id: Uint8Array | null
    lesson_id: Uint8Array | null
  }

  export type AttendancesCountAggregateOutputType = {
    id: number
    date_time: number
    was_present: number
    was_late: number
    was_excused: number
    student_id: number
    lesson_id: number
    _all: number
  }


  export type AttendancesMinAggregateInputType = {
    id?: true
    date_time?: true
    was_present?: true
    was_late?: true
    was_excused?: true
    student_id?: true
    lesson_id?: true
  }

  export type AttendancesMaxAggregateInputType = {
    id?: true
    date_time?: true
    was_present?: true
    was_late?: true
    was_excused?: true
    student_id?: true
    lesson_id?: true
  }

  export type AttendancesCountAggregateInputType = {
    id?: true
    date_time?: true
    was_present?: true
    was_late?: true
    was_excused?: true
    student_id?: true
    lesson_id?: true
    _all?: true
  }

  export type AttendancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendances to aggregate.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendances
    **/
    _count?: true | AttendancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendancesMaxAggregateInputType
  }

  export type GetAttendancesAggregateType<T extends AttendancesAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendances[P]>
      : GetScalarType<T[P], AggregateAttendances[P]>
  }




  export type attendancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesWhereInput
    orderBy?: attendancesOrderByWithAggregationInput | attendancesOrderByWithAggregationInput[]
    by: AttendancesScalarFieldEnum[] | AttendancesScalarFieldEnum
    having?: attendancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendancesCountAggregateInputType | true
    _min?: AttendancesMinAggregateInputType
    _max?: AttendancesMaxAggregateInputType
  }

  export type AttendancesGroupByOutputType = {
    id: Uint8Array
    date_time: Date
    was_present: boolean
    was_late: boolean
    was_excused: boolean
    student_id: Uint8Array
    lesson_id: Uint8Array
    _count: AttendancesCountAggregateOutputType | null
    _min: AttendancesMinAggregateOutputType | null
    _max: AttendancesMaxAggregateOutputType | null
  }

  type GetAttendancesGroupByPayload<T extends attendancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
            : GetScalarType<T[P], AttendancesGroupByOutputType[P]>
        }
      >
    >


  export type attendancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_time?: boolean
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    student_id?: boolean
    lesson_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendances"]>



  export type attendancesSelectScalar = {
    id?: boolean
    date_time?: boolean
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    student_id?: boolean
    lesson_id?: boolean
  }

  export type attendancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
  }

  export type $attendancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendances"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      lessons: Prisma.$lessonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      date_time: Date
      was_present: boolean
      was_late: boolean
      was_excused: boolean
      student_id: Uint8Array
      lesson_id: Uint8Array
    }, ExtArgs["result"]["attendances"]>
    composites: {}
  }

  type attendancesGetPayload<S extends boolean | null | undefined | attendancesDefaultArgs> = $Result.GetResult<Prisma.$attendancesPayload, S>

  type attendancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendancesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendancesCountAggregateInputType | true
    }

  export interface attendancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendances'], meta: { name: 'attendances' } }
    /**
     * Find zero or one Attendances that matches the filter.
     * @param {attendancesFindUniqueArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendancesFindUniqueArgs>(args: SelectSubset<T, attendancesFindUniqueArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attendances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendancesFindUniqueOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendancesFindUniqueOrThrowArgs>(args: SelectSubset<T, attendancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesFindFirstArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendancesFindFirstArgs>(args?: SelectSubset<T, attendancesFindFirstArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attendances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesFindFirstOrThrowArgs} args - Arguments to find a Attendances
     * @example
     * // Get one Attendances
     * const attendances = await prisma.attendances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendancesFindFirstOrThrowArgs>(args?: SelectSubset<T, attendancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendances.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendancesWithIdOnly = await prisma.attendances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendancesFindManyArgs>(args?: SelectSubset<T, attendancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attendances.
     * @param {attendancesCreateArgs} args - Arguments to create a Attendances.
     * @example
     * // Create one Attendances
     * const Attendances = await prisma.attendances.create({
     *   data: {
     *     // ... data to create a Attendances
     *   }
     * })
     * 
     */
    create<T extends attendancesCreateArgs>(args: SelectSubset<T, attendancesCreateArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attendances.
     * @param {attendancesCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendances = await prisma.attendances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendancesCreateManyArgs>(args?: SelectSubset<T, attendancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendances.
     * @param {attendancesDeleteArgs} args - Arguments to delete one Attendances.
     * @example
     * // Delete one Attendances
     * const Attendances = await prisma.attendances.delete({
     *   where: {
     *     // ... filter to delete one Attendances
     *   }
     * })
     * 
     */
    delete<T extends attendancesDeleteArgs>(args: SelectSubset<T, attendancesDeleteArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attendances.
     * @param {attendancesUpdateArgs} args - Arguments to update one Attendances.
     * @example
     * // Update one Attendances
     * const attendances = await prisma.attendances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendancesUpdateArgs>(args: SelectSubset<T, attendancesUpdateArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attendances.
     * @param {attendancesDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendancesDeleteManyArgs>(args?: SelectSubset<T, attendancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendances = await prisma.attendances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendancesUpdateManyArgs>(args: SelectSubset<T, attendancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendances.
     * @param {attendancesUpsertArgs} args - Arguments to update or create a Attendances.
     * @example
     * // Update or create a Attendances
     * const attendances = await prisma.attendances.upsert({
     *   create: {
     *     // ... data to create a Attendances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendances we want to update
     *   }
     * })
     */
    upsert<T extends attendancesUpsertArgs>(args: SelectSubset<T, attendancesUpsertArgs<ExtArgs>>): Prisma__attendancesClient<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendances.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends attendancesCountArgs>(
      args?: Subset<T, attendancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendancesAggregateArgs>(args: Subset<T, AttendancesAggregateArgs>): Prisma.PrismaPromise<GetAttendancesAggregateType<T>>

    /**
     * Group by Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendancesGroupByArgs['orderBy'] }
        : { orderBy?: attendancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendances model
   */
  readonly fields: attendancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lessons<T extends lessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, lessonsDefaultArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendances model
   */ 
  interface attendancesFieldRefs {
    readonly id: FieldRef<"attendances", 'Bytes'>
    readonly date_time: FieldRef<"attendances", 'DateTime'>
    readonly was_present: FieldRef<"attendances", 'Boolean'>
    readonly was_late: FieldRef<"attendances", 'Boolean'>
    readonly was_excused: FieldRef<"attendances", 'Boolean'>
    readonly student_id: FieldRef<"attendances", 'Bytes'>
    readonly lesson_id: FieldRef<"attendances", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * attendances findUnique
   */
  export type attendancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances findUniqueOrThrow
   */
  export type attendancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances findFirst
   */
  export type attendancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * attendances findFirstOrThrow
   */
  export type attendancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * attendances findMany
   */
  export type attendancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendances.
     */
    cursor?: attendancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * attendances create
   */
  export type attendancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * The data needed to create a attendances.
     */
    data: XOR<attendancesCreateInput, attendancesUncheckedCreateInput>
  }

  /**
   * attendances createMany
   */
  export type attendancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendances.
     */
    data: attendancesCreateManyInput | attendancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendances update
   */
  export type attendancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * The data needed to update a attendances.
     */
    data: XOR<attendancesUpdateInput, attendancesUncheckedUpdateInput>
    /**
     * Choose, which attendances to update.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances updateMany
   */
  export type attendancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendances.
     */
    data: XOR<attendancesUpdateManyMutationInput, attendancesUncheckedUpdateManyInput>
    /**
     * Filter which attendances to update
     */
    where?: attendancesWhereInput
  }

  /**
   * attendances upsert
   */
  export type attendancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * The filter to search for the attendances to update in case it exists.
     */
    where: attendancesWhereUniqueInput
    /**
     * In case the attendances found by the `where` argument doesn't exist, create a new attendances with this data.
     */
    create: XOR<attendancesCreateInput, attendancesUncheckedCreateInput>
    /**
     * In case the attendances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendancesUpdateInput, attendancesUncheckedUpdateInput>
  }

  /**
   * attendances delete
   */
  export type attendancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    /**
     * Filter which attendances to delete.
     */
    where: attendancesWhereUniqueInput
  }

  /**
   * attendances deleteMany
   */
  export type attendancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendances to delete
     */
    where?: attendancesWhereInput
  }

  /**
   * attendances without action
   */
  export type attendancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
  }


  /**
   * Model badges
   */

  export type AggregateBadges = {
    _count: BadgesCountAggregateOutputType | null
    _min: BadgesMinAggregateOutputType | null
    _max: BadgesMaxAggregateOutputType | null
  }

  export type BadgesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    description: string | null
    category_id: Uint8Array | null
  }

  export type BadgesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    description: string | null
    category_id: Uint8Array | null
  }

  export type BadgesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category_id: number
    _all: number
  }


  export type BadgesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category_id?: true
  }

  export type BadgesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category_id?: true
  }

  export type BadgesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category_id?: true
    _all?: true
  }

  export type BadgesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges to aggregate.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned badges
    **/
    _count?: true | BadgesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgesMaxAggregateInputType
  }

  export type GetBadgesAggregateType<T extends BadgesAggregateArgs> = {
        [P in keyof T & keyof AggregateBadges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadges[P]>
      : GetScalarType<T[P], AggregateBadges[P]>
  }




  export type badgesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgesWhereInput
    orderBy?: badgesOrderByWithAggregationInput | badgesOrderByWithAggregationInput[]
    by: BadgesScalarFieldEnum[] | BadgesScalarFieldEnum
    having?: badgesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgesCountAggregateInputType | true
    _min?: BadgesMinAggregateInputType
    _max?: BadgesMaxAggregateInputType
  }

  export type BadgesGroupByOutputType = {
    id: Uint8Array
    name: string
    description: string
    category_id: Uint8Array
    _count: BadgesCountAggregateOutputType | null
    _min: BadgesMinAggregateOutputType | null
    _max: BadgesMaxAggregateOutputType | null
  }

  type GetBadgesGroupByPayload<T extends badgesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgesGroupByOutputType[P]>
            : GetScalarType<T[P], BadgesGroupByOutputType[P]>
        }
      >
    >


  export type badgesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category_id?: boolean
    badges_categories?: boolean | badges_categoriesDefaultArgs<ExtArgs>
    badges_history?: boolean | badges$badges_historyArgs<ExtArgs>
    _count?: boolean | BadgesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badges"]>



  export type badgesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category_id?: boolean
  }

  export type badgesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges_categories?: boolean | badges_categoriesDefaultArgs<ExtArgs>
    badges_history?: boolean | badges$badges_historyArgs<ExtArgs>
    _count?: boolean | BadgesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $badgesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "badges"
    objects: {
      badges_categories: Prisma.$badges_categoriesPayload<ExtArgs>
      badges_history: Prisma.$badges_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
      description: string
      category_id: Uint8Array
    }, ExtArgs["result"]["badges"]>
    composites: {}
  }

  type badgesGetPayload<S extends boolean | null | undefined | badgesDefaultArgs> = $Result.GetResult<Prisma.$badgesPayload, S>

  type badgesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<badgesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgesCountAggregateInputType | true
    }

  export interface badgesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['badges'], meta: { name: 'badges' } }
    /**
     * Find zero or one Badges that matches the filter.
     * @param {badgesFindUniqueArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends badgesFindUniqueArgs>(args: SelectSubset<T, badgesFindUniqueArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {badgesFindUniqueOrThrowArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends badgesFindUniqueOrThrowArgs>(args: SelectSubset<T, badgesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesFindFirstArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends badgesFindFirstArgs>(args?: SelectSubset<T, badgesFindFirstArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesFindFirstOrThrowArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends badgesFindFirstOrThrowArgs>(args?: SelectSubset<T, badgesFindFirstOrThrowArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badges.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgesWithIdOnly = await prisma.badges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends badgesFindManyArgs>(args?: SelectSubset<T, badgesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badges.
     * @param {badgesCreateArgs} args - Arguments to create a Badges.
     * @example
     * // Create one Badges
     * const Badges = await prisma.badges.create({
     *   data: {
     *     // ... data to create a Badges
     *   }
     * })
     * 
     */
    create<T extends badgesCreateArgs>(args: SelectSubset<T, badgesCreateArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {badgesCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badges = await prisma.badges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends badgesCreateManyArgs>(args?: SelectSubset<T, badgesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Badges.
     * @param {badgesDeleteArgs} args - Arguments to delete one Badges.
     * @example
     * // Delete one Badges
     * const Badges = await prisma.badges.delete({
     *   where: {
     *     // ... filter to delete one Badges
     *   }
     * })
     * 
     */
    delete<T extends badgesDeleteArgs>(args: SelectSubset<T, badgesDeleteArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badges.
     * @param {badgesUpdateArgs} args - Arguments to update one Badges.
     * @example
     * // Update one Badges
     * const badges = await prisma.badges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends badgesUpdateArgs>(args: SelectSubset<T, badgesUpdateArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {badgesDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends badgesDeleteManyArgs>(args?: SelectSubset<T, badgesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badges = await prisma.badges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends badgesUpdateManyArgs>(args: SelectSubset<T, badgesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badges.
     * @param {badgesUpsertArgs} args - Arguments to update or create a Badges.
     * @example
     * // Update or create a Badges
     * const badges = await prisma.badges.upsert({
     *   create: {
     *     // ... data to create a Badges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badges we want to update
     *   }
     * })
     */
    upsert<T extends badgesUpsertArgs>(args: SelectSubset<T, badgesUpsertArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badges.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends badgesCountArgs>(
      args?: Subset<T, badgesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgesAggregateArgs>(args: Subset<T, BadgesAggregateArgs>): Prisma.PrismaPromise<GetBadgesAggregateType<T>>

    /**
     * Group by Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends badgesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: badgesGroupByArgs['orderBy'] }
        : { orderBy?: badgesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, badgesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the badges model
   */
  readonly fields: badgesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for badges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__badgesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges_categories<T extends badges_categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, badges_categoriesDefaultArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    badges_history<T extends badges$badges_historyArgs<ExtArgs> = {}>(args?: Subset<T, badges$badges_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the badges model
   */ 
  interface badgesFieldRefs {
    readonly id: FieldRef<"badges", 'Bytes'>
    readonly name: FieldRef<"badges", 'String'>
    readonly description: FieldRef<"badges", 'String'>
    readonly category_id: FieldRef<"badges", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * badges findUnique
   */
  export type badgesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges findUniqueOrThrow
   */
  export type badgesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges findFirst
   */
  export type badgesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * badges findFirstOrThrow
   */
  export type badgesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * badges findMany
   */
  export type badgesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing badges.
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * badges create
   */
  export type badgesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * The data needed to create a badges.
     */
    data: XOR<badgesCreateInput, badgesUncheckedCreateInput>
  }

  /**
   * badges createMany
   */
  export type badgesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many badges.
     */
    data: badgesCreateManyInput | badgesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badges update
   */
  export type badgesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * The data needed to update a badges.
     */
    data: XOR<badgesUpdateInput, badgesUncheckedUpdateInput>
    /**
     * Choose, which badges to update.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges updateMany
   */
  export type badgesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update badges.
     */
    data: XOR<badgesUpdateManyMutationInput, badgesUncheckedUpdateManyInput>
    /**
     * Filter which badges to update
     */
    where?: badgesWhereInput
  }

  /**
   * badges upsert
   */
  export type badgesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * The filter to search for the badges to update in case it exists.
     */
    where: badgesWhereUniqueInput
    /**
     * In case the badges found by the `where` argument doesn't exist, create a new badges with this data.
     */
    create: XOR<badgesCreateInput, badgesUncheckedCreateInput>
    /**
     * In case the badges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<badgesUpdateInput, badgesUncheckedUpdateInput>
  }

  /**
   * badges delete
   */
  export type badgesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter which badges to delete.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges deleteMany
   */
  export type badgesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges to delete
     */
    where?: badgesWhereInput
  }

  /**
   * badges.badges_history
   */
  export type badges$badges_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    where?: badges_historyWhereInput
    orderBy?: badges_historyOrderByWithRelationInput | badges_historyOrderByWithRelationInput[]
    cursor?: badges_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Badges_historyScalarFieldEnum | Badges_historyScalarFieldEnum[]
  }

  /**
   * badges without action
   */
  export type badgesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
  }


  /**
   * Model badges_categories
   */

  export type AggregateBadges_categories = {
    _count: Badges_categoriesCountAggregateOutputType | null
    _min: Badges_categoriesMinAggregateOutputType | null
    _max: Badges_categoriesMaxAggregateOutputType | null
  }

  export type Badges_categoriesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Badges_categoriesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Badges_categoriesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Badges_categoriesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Badges_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Badges_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Badges_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges_categories to aggregate.
     */
    where?: badges_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_categories to fetch.
     */
    orderBy?: badges_categoriesOrderByWithRelationInput | badges_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: badges_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned badges_categories
    **/
    _count?: true | Badges_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Badges_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Badges_categoriesMaxAggregateInputType
  }

  export type GetBadges_categoriesAggregateType<T extends Badges_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateBadges_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadges_categories[P]>
      : GetScalarType<T[P], AggregateBadges_categories[P]>
  }




  export type badges_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badges_categoriesWhereInput
    orderBy?: badges_categoriesOrderByWithAggregationInput | badges_categoriesOrderByWithAggregationInput[]
    by: Badges_categoriesScalarFieldEnum[] | Badges_categoriesScalarFieldEnum
    having?: badges_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Badges_categoriesCountAggregateInputType | true
    _min?: Badges_categoriesMinAggregateInputType
    _max?: Badges_categoriesMaxAggregateInputType
  }

  export type Badges_categoriesGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: Badges_categoriesCountAggregateOutputType | null
    _min: Badges_categoriesMinAggregateOutputType | null
    _max: Badges_categoriesMaxAggregateOutputType | null
  }

  type GetBadges_categoriesGroupByPayload<T extends badges_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Badges_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Badges_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Badges_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Badges_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type badges_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    badges?: boolean | badges_categories$badgesArgs<ExtArgs>
    _count?: boolean | Badges_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badges_categories"]>



  export type badges_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type badges_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | badges_categories$badgesArgs<ExtArgs>
    _count?: boolean | Badges_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $badges_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "badges_categories"
    objects: {
      badges: Prisma.$badgesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["badges_categories"]>
    composites: {}
  }

  type badges_categoriesGetPayload<S extends boolean | null | undefined | badges_categoriesDefaultArgs> = $Result.GetResult<Prisma.$badges_categoriesPayload, S>

  type badges_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<badges_categoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Badges_categoriesCountAggregateInputType | true
    }

  export interface badges_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['badges_categories'], meta: { name: 'badges_categories' } }
    /**
     * Find zero or one Badges_categories that matches the filter.
     * @param {badges_categoriesFindUniqueArgs} args - Arguments to find a Badges_categories
     * @example
     * // Get one Badges_categories
     * const badges_categories = await prisma.badges_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends badges_categoriesFindUniqueArgs>(args: SelectSubset<T, badges_categoriesFindUniqueArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badges_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {badges_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Badges_categories
     * @example
     * // Get one Badges_categories
     * const badges_categories = await prisma.badges_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends badges_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, badges_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badges_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_categoriesFindFirstArgs} args - Arguments to find a Badges_categories
     * @example
     * // Get one Badges_categories
     * const badges_categories = await prisma.badges_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends badges_categoriesFindFirstArgs>(args?: SelectSubset<T, badges_categoriesFindFirstArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badges_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_categoriesFindFirstOrThrowArgs} args - Arguments to find a Badges_categories
     * @example
     * // Get one Badges_categories
     * const badges_categories = await prisma.badges_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends badges_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, badges_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges_categories
     * const badges_categories = await prisma.badges_categories.findMany()
     * 
     * // Get first 10 Badges_categories
     * const badges_categories = await prisma.badges_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badges_categoriesWithIdOnly = await prisma.badges_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends badges_categoriesFindManyArgs>(args?: SelectSubset<T, badges_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badges_categories.
     * @param {badges_categoriesCreateArgs} args - Arguments to create a Badges_categories.
     * @example
     * // Create one Badges_categories
     * const Badges_categories = await prisma.badges_categories.create({
     *   data: {
     *     // ... data to create a Badges_categories
     *   }
     * })
     * 
     */
    create<T extends badges_categoriesCreateArgs>(args: SelectSubset<T, badges_categoriesCreateArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges_categories.
     * @param {badges_categoriesCreateManyArgs} args - Arguments to create many Badges_categories.
     * @example
     * // Create many Badges_categories
     * const badges_categories = await prisma.badges_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends badges_categoriesCreateManyArgs>(args?: SelectSubset<T, badges_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Badges_categories.
     * @param {badges_categoriesDeleteArgs} args - Arguments to delete one Badges_categories.
     * @example
     * // Delete one Badges_categories
     * const Badges_categories = await prisma.badges_categories.delete({
     *   where: {
     *     // ... filter to delete one Badges_categories
     *   }
     * })
     * 
     */
    delete<T extends badges_categoriesDeleteArgs>(args: SelectSubset<T, badges_categoriesDeleteArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badges_categories.
     * @param {badges_categoriesUpdateArgs} args - Arguments to update one Badges_categories.
     * @example
     * // Update one Badges_categories
     * const badges_categories = await prisma.badges_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends badges_categoriesUpdateArgs>(args: SelectSubset<T, badges_categoriesUpdateArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges_categories.
     * @param {badges_categoriesDeleteManyArgs} args - Arguments to filter Badges_categories to delete.
     * @example
     * // Delete a few Badges_categories
     * const { count } = await prisma.badges_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends badges_categoriesDeleteManyArgs>(args?: SelectSubset<T, badges_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges_categories
     * const badges_categories = await prisma.badges_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends badges_categoriesUpdateManyArgs>(args: SelectSubset<T, badges_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badges_categories.
     * @param {badges_categoriesUpsertArgs} args - Arguments to update or create a Badges_categories.
     * @example
     * // Update or create a Badges_categories
     * const badges_categories = await prisma.badges_categories.upsert({
     *   create: {
     *     // ... data to create a Badges_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badges_categories we want to update
     *   }
     * })
     */
    upsert<T extends badges_categoriesUpsertArgs>(args: SelectSubset<T, badges_categoriesUpsertArgs<ExtArgs>>): Prisma__badges_categoriesClient<$Result.GetResult<Prisma.$badges_categoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_categoriesCountArgs} args - Arguments to filter Badges_categories to count.
     * @example
     * // Count the number of Badges_categories
     * const count = await prisma.badges_categories.count({
     *   where: {
     *     // ... the filter for the Badges_categories we want to count
     *   }
     * })
    **/
    count<T extends badges_categoriesCountArgs>(
      args?: Subset<T, badges_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Badges_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badges_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Badges_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Badges_categoriesAggregateArgs>(args: Subset<T, Badges_categoriesAggregateArgs>): Prisma.PrismaPromise<GetBadges_categoriesAggregateType<T>>

    /**
     * Group by Badges_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends badges_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: badges_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: badges_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, badges_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadges_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the badges_categories model
   */
  readonly fields: badges_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for badges_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__badges_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends badges_categories$badgesArgs<ExtArgs> = {}>(args?: Subset<T, badges_categories$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the badges_categories model
   */ 
  interface badges_categoriesFieldRefs {
    readonly id: FieldRef<"badges_categories", 'Bytes'>
    readonly name: FieldRef<"badges_categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * badges_categories findUnique
   */
  export type badges_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which badges_categories to fetch.
     */
    where: badges_categoriesWhereUniqueInput
  }

  /**
   * badges_categories findUniqueOrThrow
   */
  export type badges_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which badges_categories to fetch.
     */
    where: badges_categoriesWhereUniqueInput
  }

  /**
   * badges_categories findFirst
   */
  export type badges_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which badges_categories to fetch.
     */
    where?: badges_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_categories to fetch.
     */
    orderBy?: badges_categoriesOrderByWithRelationInput | badges_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges_categories.
     */
    cursor?: badges_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges_categories.
     */
    distinct?: Badges_categoriesScalarFieldEnum | Badges_categoriesScalarFieldEnum[]
  }

  /**
   * badges_categories findFirstOrThrow
   */
  export type badges_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which badges_categories to fetch.
     */
    where?: badges_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_categories to fetch.
     */
    orderBy?: badges_categoriesOrderByWithRelationInput | badges_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges_categories.
     */
    cursor?: badges_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges_categories.
     */
    distinct?: Badges_categoriesScalarFieldEnum | Badges_categoriesScalarFieldEnum[]
  }

  /**
   * badges_categories findMany
   */
  export type badges_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which badges_categories to fetch.
     */
    where?: badges_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_categories to fetch.
     */
    orderBy?: badges_categoriesOrderByWithRelationInput | badges_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing badges_categories.
     */
    cursor?: badges_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_categories.
     */
    skip?: number
    distinct?: Badges_categoriesScalarFieldEnum | Badges_categoriesScalarFieldEnum[]
  }

  /**
   * badges_categories create
   */
  export type badges_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a badges_categories.
     */
    data: XOR<badges_categoriesCreateInput, badges_categoriesUncheckedCreateInput>
  }

  /**
   * badges_categories createMany
   */
  export type badges_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many badges_categories.
     */
    data: badges_categoriesCreateManyInput | badges_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badges_categories update
   */
  export type badges_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a badges_categories.
     */
    data: XOR<badges_categoriesUpdateInput, badges_categoriesUncheckedUpdateInput>
    /**
     * Choose, which badges_categories to update.
     */
    where: badges_categoriesWhereUniqueInput
  }

  /**
   * badges_categories updateMany
   */
  export type badges_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update badges_categories.
     */
    data: XOR<badges_categoriesUpdateManyMutationInput, badges_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which badges_categories to update
     */
    where?: badges_categoriesWhereInput
  }

  /**
   * badges_categories upsert
   */
  export type badges_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the badges_categories to update in case it exists.
     */
    where: badges_categoriesWhereUniqueInput
    /**
     * In case the badges_categories found by the `where` argument doesn't exist, create a new badges_categories with this data.
     */
    create: XOR<badges_categoriesCreateInput, badges_categoriesUncheckedCreateInput>
    /**
     * In case the badges_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<badges_categoriesUpdateInput, badges_categoriesUncheckedUpdateInput>
  }

  /**
   * badges_categories delete
   */
  export type badges_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
    /**
     * Filter which badges_categories to delete.
     */
    where: badges_categoriesWhereUniqueInput
  }

  /**
   * badges_categories deleteMany
   */
  export type badges_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges_categories to delete
     */
    where?: badges_categoriesWhereInput
  }

  /**
   * badges_categories.badges
   */
  export type badges_categories$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    where?: badgesWhereInput
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    cursor?: badgesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * badges_categories without action
   */
  export type badges_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_categories
     */
    select?: badges_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model badges_history
   */

  export type AggregateBadges_history = {
    _count: Badges_historyCountAggregateOutputType | null
    _min: Badges_historyMinAggregateOutputType | null
    _max: Badges_historyMaxAggregateOutputType | null
  }

  export type Badges_historyMinAggregateOutputType = {
    id: Uint8Array | null
    date_awarded: Date | null
    student_id: Uint8Array | null
    badge_id: Uint8Array | null
  }

  export type Badges_historyMaxAggregateOutputType = {
    id: Uint8Array | null
    date_awarded: Date | null
    student_id: Uint8Array | null
    badge_id: Uint8Array | null
  }

  export type Badges_historyCountAggregateOutputType = {
    id: number
    date_awarded: number
    student_id: number
    badge_id: number
    _all: number
  }


  export type Badges_historyMinAggregateInputType = {
    id?: true
    date_awarded?: true
    student_id?: true
    badge_id?: true
  }

  export type Badges_historyMaxAggregateInputType = {
    id?: true
    date_awarded?: true
    student_id?: true
    badge_id?: true
  }

  export type Badges_historyCountAggregateInputType = {
    id?: true
    date_awarded?: true
    student_id?: true
    badge_id?: true
    _all?: true
  }

  export type Badges_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges_history to aggregate.
     */
    where?: badges_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_histories to fetch.
     */
    orderBy?: badges_historyOrderByWithRelationInput | badges_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: badges_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned badges_histories
    **/
    _count?: true | Badges_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Badges_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Badges_historyMaxAggregateInputType
  }

  export type GetBadges_historyAggregateType<T extends Badges_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateBadges_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadges_history[P]>
      : GetScalarType<T[P], AggregateBadges_history[P]>
  }




  export type badges_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badges_historyWhereInput
    orderBy?: badges_historyOrderByWithAggregationInput | badges_historyOrderByWithAggregationInput[]
    by: Badges_historyScalarFieldEnum[] | Badges_historyScalarFieldEnum
    having?: badges_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Badges_historyCountAggregateInputType | true
    _min?: Badges_historyMinAggregateInputType
    _max?: Badges_historyMaxAggregateInputType
  }

  export type Badges_historyGroupByOutputType = {
    id: Uint8Array
    date_awarded: Date
    student_id: Uint8Array
    badge_id: Uint8Array
    _count: Badges_historyCountAggregateOutputType | null
    _min: Badges_historyMinAggregateOutputType | null
    _max: Badges_historyMaxAggregateOutputType | null
  }

  type GetBadges_historyGroupByPayload<T extends badges_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Badges_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Badges_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Badges_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Badges_historyGroupByOutputType[P]>
        }
      >
    >


  export type badges_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date_awarded?: boolean
    student_id?: boolean
    badge_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    badges?: boolean | badgesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badges_history"]>



  export type badges_historySelectScalar = {
    id?: boolean
    date_awarded?: boolean
    student_id?: boolean
    badge_id?: boolean
  }

  export type badges_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    badges?: boolean | badgesDefaultArgs<ExtArgs>
  }

  export type $badges_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "badges_history"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      badges: Prisma.$badgesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      date_awarded: Date
      student_id: Uint8Array
      badge_id: Uint8Array
    }, ExtArgs["result"]["badges_history"]>
    composites: {}
  }

  type badges_historyGetPayload<S extends boolean | null | undefined | badges_historyDefaultArgs> = $Result.GetResult<Prisma.$badges_historyPayload, S>

  type badges_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<badges_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Badges_historyCountAggregateInputType | true
    }

  export interface badges_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['badges_history'], meta: { name: 'badges_history' } }
    /**
     * Find zero or one Badges_history that matches the filter.
     * @param {badges_historyFindUniqueArgs} args - Arguments to find a Badges_history
     * @example
     * // Get one Badges_history
     * const badges_history = await prisma.badges_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends badges_historyFindUniqueArgs>(args: SelectSubset<T, badges_historyFindUniqueArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badges_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {badges_historyFindUniqueOrThrowArgs} args - Arguments to find a Badges_history
     * @example
     * // Get one Badges_history
     * const badges_history = await prisma.badges_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends badges_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, badges_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badges_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_historyFindFirstArgs} args - Arguments to find a Badges_history
     * @example
     * // Get one Badges_history
     * const badges_history = await prisma.badges_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends badges_historyFindFirstArgs>(args?: SelectSubset<T, badges_historyFindFirstArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badges_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_historyFindFirstOrThrowArgs} args - Arguments to find a Badges_history
     * @example
     * // Get one Badges_history
     * const badges_history = await prisma.badges_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends badges_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, badges_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges_histories
     * const badges_histories = await prisma.badges_history.findMany()
     * 
     * // Get first 10 Badges_histories
     * const badges_histories = await prisma.badges_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badges_historyWithIdOnly = await prisma.badges_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends badges_historyFindManyArgs>(args?: SelectSubset<T, badges_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badges_history.
     * @param {badges_historyCreateArgs} args - Arguments to create a Badges_history.
     * @example
     * // Create one Badges_history
     * const Badges_history = await prisma.badges_history.create({
     *   data: {
     *     // ... data to create a Badges_history
     *   }
     * })
     * 
     */
    create<T extends badges_historyCreateArgs>(args: SelectSubset<T, badges_historyCreateArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges_histories.
     * @param {badges_historyCreateManyArgs} args - Arguments to create many Badges_histories.
     * @example
     * // Create many Badges_histories
     * const badges_history = await prisma.badges_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends badges_historyCreateManyArgs>(args?: SelectSubset<T, badges_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Badges_history.
     * @param {badges_historyDeleteArgs} args - Arguments to delete one Badges_history.
     * @example
     * // Delete one Badges_history
     * const Badges_history = await prisma.badges_history.delete({
     *   where: {
     *     // ... filter to delete one Badges_history
     *   }
     * })
     * 
     */
    delete<T extends badges_historyDeleteArgs>(args: SelectSubset<T, badges_historyDeleteArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badges_history.
     * @param {badges_historyUpdateArgs} args - Arguments to update one Badges_history.
     * @example
     * // Update one Badges_history
     * const badges_history = await prisma.badges_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends badges_historyUpdateArgs>(args: SelectSubset<T, badges_historyUpdateArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges_histories.
     * @param {badges_historyDeleteManyArgs} args - Arguments to filter Badges_histories to delete.
     * @example
     * // Delete a few Badges_histories
     * const { count } = await prisma.badges_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends badges_historyDeleteManyArgs>(args?: SelectSubset<T, badges_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges_histories
     * const badges_history = await prisma.badges_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends badges_historyUpdateManyArgs>(args: SelectSubset<T, badges_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badges_history.
     * @param {badges_historyUpsertArgs} args - Arguments to update or create a Badges_history.
     * @example
     * // Update or create a Badges_history
     * const badges_history = await prisma.badges_history.upsert({
     *   create: {
     *     // ... data to create a Badges_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badges_history we want to update
     *   }
     * })
     */
    upsert<T extends badges_historyUpsertArgs>(args: SelectSubset<T, badges_historyUpsertArgs<ExtArgs>>): Prisma__badges_historyClient<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_historyCountArgs} args - Arguments to filter Badges_histories to count.
     * @example
     * // Count the number of Badges_histories
     * const count = await prisma.badges_history.count({
     *   where: {
     *     // ... the filter for the Badges_histories we want to count
     *   }
     * })
    **/
    count<T extends badges_historyCountArgs>(
      args?: Subset<T, badges_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Badges_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badges_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Badges_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Badges_historyAggregateArgs>(args: Subset<T, Badges_historyAggregateArgs>): Prisma.PrismaPromise<GetBadges_historyAggregateType<T>>

    /**
     * Group by Badges_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badges_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends badges_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: badges_historyGroupByArgs['orderBy'] }
        : { orderBy?: badges_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, badges_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadges_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the badges_history model
   */
  readonly fields: badges_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for badges_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__badges_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    badges<T extends badgesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, badgesDefaultArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the badges_history model
   */ 
  interface badges_historyFieldRefs {
    readonly id: FieldRef<"badges_history", 'Bytes'>
    readonly date_awarded: FieldRef<"badges_history", 'DateTime'>
    readonly student_id: FieldRef<"badges_history", 'Bytes'>
    readonly badge_id: FieldRef<"badges_history", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * badges_history findUnique
   */
  export type badges_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * Filter, which badges_history to fetch.
     */
    where: badges_historyWhereUniqueInput
  }

  /**
   * badges_history findUniqueOrThrow
   */
  export type badges_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * Filter, which badges_history to fetch.
     */
    where: badges_historyWhereUniqueInput
  }

  /**
   * badges_history findFirst
   */
  export type badges_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * Filter, which badges_history to fetch.
     */
    where?: badges_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_histories to fetch.
     */
    orderBy?: badges_historyOrderByWithRelationInput | badges_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges_histories.
     */
    cursor?: badges_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges_histories.
     */
    distinct?: Badges_historyScalarFieldEnum | Badges_historyScalarFieldEnum[]
  }

  /**
   * badges_history findFirstOrThrow
   */
  export type badges_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * Filter, which badges_history to fetch.
     */
    where?: badges_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_histories to fetch.
     */
    orderBy?: badges_historyOrderByWithRelationInput | badges_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges_histories.
     */
    cursor?: badges_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges_histories.
     */
    distinct?: Badges_historyScalarFieldEnum | Badges_historyScalarFieldEnum[]
  }

  /**
   * badges_history findMany
   */
  export type badges_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * Filter, which badges_histories to fetch.
     */
    where?: badges_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges_histories to fetch.
     */
    orderBy?: badges_historyOrderByWithRelationInput | badges_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing badges_histories.
     */
    cursor?: badges_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges_histories.
     */
    skip?: number
    distinct?: Badges_historyScalarFieldEnum | Badges_historyScalarFieldEnum[]
  }

  /**
   * badges_history create
   */
  export type badges_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a badges_history.
     */
    data: XOR<badges_historyCreateInput, badges_historyUncheckedCreateInput>
  }

  /**
   * badges_history createMany
   */
  export type badges_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many badges_histories.
     */
    data: badges_historyCreateManyInput | badges_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badges_history update
   */
  export type badges_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a badges_history.
     */
    data: XOR<badges_historyUpdateInput, badges_historyUncheckedUpdateInput>
    /**
     * Choose, which badges_history to update.
     */
    where: badges_historyWhereUniqueInput
  }

  /**
   * badges_history updateMany
   */
  export type badges_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update badges_histories.
     */
    data: XOR<badges_historyUpdateManyMutationInput, badges_historyUncheckedUpdateManyInput>
    /**
     * Filter which badges_histories to update
     */
    where?: badges_historyWhereInput
  }

  /**
   * badges_history upsert
   */
  export type badges_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the badges_history to update in case it exists.
     */
    where: badges_historyWhereUniqueInput
    /**
     * In case the badges_history found by the `where` argument doesn't exist, create a new badges_history with this data.
     */
    create: XOR<badges_historyCreateInput, badges_historyUncheckedCreateInput>
    /**
     * In case the badges_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<badges_historyUpdateInput, badges_historyUncheckedUpdateInput>
  }

  /**
   * badges_history delete
   */
  export type badges_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    /**
     * Filter which badges_history to delete.
     */
    where: badges_historyWhereUniqueInput
  }

  /**
   * badges_history deleteMany
   */
  export type badges_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges_histories to delete
     */
    where?: badges_historyWhereInput
  }

  /**
   * badges_history without action
   */
  export type badges_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
  }


  /**
   * Model classes
   */

  export type AggregateClasses = {
    _count: ClassesCountAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  export type ClassesMinAggregateOutputType = {
    id: Uint8Array | null
    class_name_id: Uint8Array | null
    school_year_id: Uint8Array | null
    teacher_id: Uint8Array | null
  }

  export type ClassesMaxAggregateOutputType = {
    id: Uint8Array | null
    class_name_id: Uint8Array | null
    school_year_id: Uint8Array | null
    teacher_id: Uint8Array | null
  }

  export type ClassesCountAggregateOutputType = {
    id: number
    class_name_id: number
    school_year_id: number
    teacher_id: number
    _all: number
  }


  export type ClassesMinAggregateInputType = {
    id?: true
    class_name_id?: true
    school_year_id?: true
    teacher_id?: true
  }

  export type ClassesMaxAggregateInputType = {
    id?: true
    class_name_id?: true
    school_year_id?: true
    teacher_id?: true
  }

  export type ClassesCountAggregateInputType = {
    id?: true
    class_name_id?: true
    school_year_id?: true
    teacher_id?: true
    _all?: true
  }

  export type ClassesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes to aggregate.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned classes
    **/
    _count?: true | ClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassesMaxAggregateInputType
  }

  export type GetClassesAggregateType<T extends ClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasses[P]>
      : GetScalarType<T[P], AggregateClasses[P]>
  }




  export type classesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
    orderBy?: classesOrderByWithAggregationInput | classesOrderByWithAggregationInput[]
    by: ClassesScalarFieldEnum[] | ClassesScalarFieldEnum
    having?: classesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassesCountAggregateInputType | true
    _min?: ClassesMinAggregateInputType
    _max?: ClassesMaxAggregateInputType
  }

  export type ClassesGroupByOutputType = {
    id: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
    teacher_id: Uint8Array | null
    _count: ClassesCountAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  type GetClassesGroupByPayload<T extends classesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassesGroupByOutputType[P]>
            : GetScalarType<T[P], ClassesGroupByOutputType[P]>
        }
      >
    >


  export type classesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class_name_id?: boolean
    school_year_id?: boolean
    teacher_id?: boolean
    class_names?: boolean | class_namesDefaultArgs<ExtArgs>
    school_years?: boolean | school_yearsDefaultArgs<ExtArgs>
    teachers?: boolean | classes$teachersArgs<ExtArgs>
    classes_exams?: boolean | classes$classes_examsArgs<ExtArgs>
    lessons?: boolean | classes$lessonsArgs<ExtArgs>
    students?: boolean | classes$studentsArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classes"]>



  export type classesSelectScalar = {
    id?: boolean
    class_name_id?: boolean
    school_year_id?: boolean
    teacher_id?: boolean
  }

  export type classesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class_names?: boolean | class_namesDefaultArgs<ExtArgs>
    school_years?: boolean | school_yearsDefaultArgs<ExtArgs>
    teachers?: boolean | classes$teachersArgs<ExtArgs>
    classes_exams?: boolean | classes$classes_examsArgs<ExtArgs>
    lessons?: boolean | classes$lessonsArgs<ExtArgs>
    students?: boolean | classes$studentsArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $classesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "classes"
    objects: {
      class_names: Prisma.$class_namesPayload<ExtArgs>
      school_years: Prisma.$school_yearsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs> | null
      classes_exams: Prisma.$classes_examsPayload<ExtArgs>[]
      lessons: Prisma.$lessonsPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      class_name_id: Uint8Array
      school_year_id: Uint8Array
      teacher_id: Uint8Array | null
    }, ExtArgs["result"]["classes"]>
    composites: {}
  }

  type classesGetPayload<S extends boolean | null | undefined | classesDefaultArgs> = $Result.GetResult<Prisma.$classesPayload, S>

  type classesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<classesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassesCountAggregateInputType | true
    }

  export interface classesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['classes'], meta: { name: 'classes' } }
    /**
     * Find zero or one Classes that matches the filter.
     * @param {classesFindUniqueArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends classesFindUniqueArgs>(args: SelectSubset<T, classesFindUniqueArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Classes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {classesFindUniqueOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends classesFindUniqueOrThrowArgs>(args: SelectSubset<T, classesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends classesFindFirstArgs>(args?: SelectSubset<T, classesFindFirstArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Classes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends classesFindFirstOrThrowArgs>(args?: SelectSubset<T, classesFindFirstOrThrowArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classes.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classesWithIdOnly = await prisma.classes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends classesFindManyArgs>(args?: SelectSubset<T, classesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Classes.
     * @param {classesCreateArgs} args - Arguments to create a Classes.
     * @example
     * // Create one Classes
     * const Classes = await prisma.classes.create({
     *   data: {
     *     // ... data to create a Classes
     *   }
     * })
     * 
     */
    create<T extends classesCreateArgs>(args: SelectSubset<T, classesCreateArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {classesCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends classesCreateManyArgs>(args?: SelectSubset<T, classesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Classes.
     * @param {classesDeleteArgs} args - Arguments to delete one Classes.
     * @example
     * // Delete one Classes
     * const Classes = await prisma.classes.delete({
     *   where: {
     *     // ... filter to delete one Classes
     *   }
     * })
     * 
     */
    delete<T extends classesDeleteArgs>(args: SelectSubset<T, classesDeleteArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Classes.
     * @param {classesUpdateArgs} args - Arguments to update one Classes.
     * @example
     * // Update one Classes
     * const classes = await prisma.classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends classesUpdateArgs>(args: SelectSubset<T, classesUpdateArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {classesDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends classesDeleteManyArgs>(args?: SelectSubset<T, classesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends classesUpdateManyArgs>(args: SelectSubset<T, classesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Classes.
     * @param {classesUpsertArgs} args - Arguments to update or create a Classes.
     * @example
     * // Update or create a Classes
     * const classes = await prisma.classes.upsert({
     *   create: {
     *     // ... data to create a Classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classes we want to update
     *   }
     * })
     */
    upsert<T extends classesUpsertArgs>(args: SelectSubset<T, classesUpsertArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classes.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends classesCountArgs>(
      args?: Subset<T, classesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassesAggregateArgs>(args: Subset<T, ClassesAggregateArgs>): Prisma.PrismaPromise<GetClassesAggregateType<T>>

    /**
     * Group by Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends classesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: classesGroupByArgs['orderBy'] }
        : { orderBy?: classesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, classesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the classes model
   */
  readonly fields: classesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__classesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class_names<T extends class_namesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, class_namesDefaultArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    school_years<T extends school_yearsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, school_yearsDefaultArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends classes$teachersArgs<ExtArgs> = {}>(args?: Subset<T, classes$teachersArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    classes_exams<T extends classes$classes_examsArgs<ExtArgs> = {}>(args?: Subset<T, classes$classes_examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "findMany"> | Null>
    lessons<T extends classes$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, classes$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends classes$studentsArgs<ExtArgs> = {}>(args?: Subset<T, classes$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the classes model
   */ 
  interface classesFieldRefs {
    readonly id: FieldRef<"classes", 'Bytes'>
    readonly class_name_id: FieldRef<"classes", 'Bytes'>
    readonly school_year_id: FieldRef<"classes", 'Bytes'>
    readonly teacher_id: FieldRef<"classes", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * classes findUnique
   */
  export type classesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes findUniqueOrThrow
   */
  export type classesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes findFirst
   */
  export type classesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes findFirstOrThrow
   */
  export type classesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes findMany
   */
  export type classesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes create
   */
  export type classesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The data needed to create a classes.
     */
    data: XOR<classesCreateInput, classesUncheckedCreateInput>
  }

  /**
   * classes createMany
   */
  export type classesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many classes.
     */
    data: classesCreateManyInput | classesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * classes update
   */
  export type classesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The data needed to update a classes.
     */
    data: XOR<classesUpdateInput, classesUncheckedUpdateInput>
    /**
     * Choose, which classes to update.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes updateMany
   */
  export type classesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update classes.
     */
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyInput>
    /**
     * Filter which classes to update
     */
    where?: classesWhereInput
  }

  /**
   * classes upsert
   */
  export type classesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The filter to search for the classes to update in case it exists.
     */
    where: classesWhereUniqueInput
    /**
     * In case the classes found by the `where` argument doesn't exist, create a new classes with this data.
     */
    create: XOR<classesCreateInput, classesUncheckedCreateInput>
    /**
     * In case the classes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<classesUpdateInput, classesUncheckedUpdateInput>
  }

  /**
   * classes delete
   */
  export type classesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter which classes to delete.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes deleteMany
   */
  export type classesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes to delete
     */
    where?: classesWhereInput
  }

  /**
   * classes.teachers
   */
  export type classes$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
  }

  /**
   * classes.classes_exams
   */
  export type classes$classes_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    where?: classes_examsWhereInput
    orderBy?: classes_examsOrderByWithRelationInput | classes_examsOrderByWithRelationInput[]
    cursor?: classes_examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Classes_examsScalarFieldEnum | Classes_examsScalarFieldEnum[]
  }

  /**
   * classes.lessons
   */
  export type classes$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    where?: lessonsWhereInput
    orderBy?: lessonsOrderByWithRelationInput | lessonsOrderByWithRelationInput[]
    cursor?: lessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * classes.students
   */
  export type classes$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    cursor?: studentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * classes without action
   */
  export type classesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
  }


  /**
   * Model event_types
   */

  export type AggregateEvent_types = {
    _count: Event_typesCountAggregateOutputType | null
    _min: Event_typesMinAggregateOutputType | null
    _max: Event_typesMaxAggregateOutputType | null
  }

  export type Event_typesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Event_typesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Event_typesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Event_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Event_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Event_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Event_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_types to aggregate.
     */
    where?: event_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_types to fetch.
     */
    orderBy?: event_typesOrderByWithRelationInput | event_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_types
    **/
    _count?: true | Event_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_typesMaxAggregateInputType
  }

  export type GetEvent_typesAggregateType<T extends Event_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_types[P]>
      : GetScalarType<T[P], AggregateEvent_types[P]>
  }




  export type event_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: event_typesWhereInput
    orderBy?: event_typesOrderByWithAggregationInput | event_typesOrderByWithAggregationInput[]
    by: Event_typesScalarFieldEnum[] | Event_typesScalarFieldEnum
    having?: event_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_typesCountAggregateInputType | true
    _min?: Event_typesMinAggregateInputType
    _max?: Event_typesMaxAggregateInputType
  }

  export type Event_typesGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: Event_typesCountAggregateOutputType | null
    _min: Event_typesMinAggregateOutputType | null
    _max: Event_typesMaxAggregateOutputType | null
  }

  type GetEvent_typesGroupByPayload<T extends event_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Event_typesGroupByOutputType[P]>
        }
      >
    >


  export type event_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    school_events?: boolean | event_types$school_eventsArgs<ExtArgs>
    _count?: boolean | Event_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event_types"]>



  export type event_typesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type event_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school_events?: boolean | event_types$school_eventsArgs<ExtArgs>
    _count?: boolean | Event_typesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $event_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "event_types"
    objects: {
      school_events: Prisma.$school_eventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["event_types"]>
    composites: {}
  }

  type event_typesGetPayload<S extends boolean | null | undefined | event_typesDefaultArgs> = $Result.GetResult<Prisma.$event_typesPayload, S>

  type event_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<event_typesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Event_typesCountAggregateInputType | true
    }

  export interface event_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_types'], meta: { name: 'event_types' } }
    /**
     * Find zero or one Event_types that matches the filter.
     * @param {event_typesFindUniqueArgs} args - Arguments to find a Event_types
     * @example
     * // Get one Event_types
     * const event_types = await prisma.event_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends event_typesFindUniqueArgs>(args: SelectSubset<T, event_typesFindUniqueArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {event_typesFindUniqueOrThrowArgs} args - Arguments to find a Event_types
     * @example
     * // Get one Event_types
     * const event_types = await prisma.event_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends event_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, event_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_typesFindFirstArgs} args - Arguments to find a Event_types
     * @example
     * // Get one Event_types
     * const event_types = await prisma.event_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends event_typesFindFirstArgs>(args?: SelectSubset<T, event_typesFindFirstArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_typesFindFirstOrThrowArgs} args - Arguments to find a Event_types
     * @example
     * // Get one Event_types
     * const event_types = await prisma.event_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends event_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, event_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Event_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_types
     * const event_types = await prisma.event_types.findMany()
     * 
     * // Get first 10 Event_types
     * const event_types = await prisma.event_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const event_typesWithIdOnly = await prisma.event_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends event_typesFindManyArgs>(args?: SelectSubset<T, event_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event_types.
     * @param {event_typesCreateArgs} args - Arguments to create a Event_types.
     * @example
     * // Create one Event_types
     * const Event_types = await prisma.event_types.create({
     *   data: {
     *     // ... data to create a Event_types
     *   }
     * })
     * 
     */
    create<T extends event_typesCreateArgs>(args: SelectSubset<T, event_typesCreateArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Event_types.
     * @param {event_typesCreateManyArgs} args - Arguments to create many Event_types.
     * @example
     * // Create many Event_types
     * const event_types = await prisma.event_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends event_typesCreateManyArgs>(args?: SelectSubset<T, event_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event_types.
     * @param {event_typesDeleteArgs} args - Arguments to delete one Event_types.
     * @example
     * // Delete one Event_types
     * const Event_types = await prisma.event_types.delete({
     *   where: {
     *     // ... filter to delete one Event_types
     *   }
     * })
     * 
     */
    delete<T extends event_typesDeleteArgs>(args: SelectSubset<T, event_typesDeleteArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event_types.
     * @param {event_typesUpdateArgs} args - Arguments to update one Event_types.
     * @example
     * // Update one Event_types
     * const event_types = await prisma.event_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends event_typesUpdateArgs>(args: SelectSubset<T, event_typesUpdateArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Event_types.
     * @param {event_typesDeleteManyArgs} args - Arguments to filter Event_types to delete.
     * @example
     * // Delete a few Event_types
     * const { count } = await prisma.event_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends event_typesDeleteManyArgs>(args?: SelectSubset<T, event_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_types
     * const event_types = await prisma.event_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends event_typesUpdateManyArgs>(args: SelectSubset<T, event_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_types.
     * @param {event_typesUpsertArgs} args - Arguments to update or create a Event_types.
     * @example
     * // Update or create a Event_types
     * const event_types = await prisma.event_types.upsert({
     *   create: {
     *     // ... data to create a Event_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_types we want to update
     *   }
     * })
     */
    upsert<T extends event_typesUpsertArgs>(args: SelectSubset<T, event_typesUpsertArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Event_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_typesCountArgs} args - Arguments to filter Event_types to count.
     * @example
     * // Count the number of Event_types
     * const count = await prisma.event_types.count({
     *   where: {
     *     // ... the filter for the Event_types we want to count
     *   }
     * })
    **/
    count<T extends event_typesCountArgs>(
      args?: Subset<T, event_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_typesAggregateArgs>(args: Subset<T, Event_typesAggregateArgs>): Prisma.PrismaPromise<GetEvent_typesAggregateType<T>>

    /**
     * Group by Event_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_typesGroupByArgs['orderBy'] }
        : { orderBy?: event_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_types model
   */
  readonly fields: event_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__event_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school_events<T extends event_types$school_eventsArgs<ExtArgs> = {}>(args?: Subset<T, event_types$school_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the event_types model
   */ 
  interface event_typesFieldRefs {
    readonly id: FieldRef<"event_types", 'Bytes'>
    readonly name: FieldRef<"event_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * event_types findUnique
   */
  export type event_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * Filter, which event_types to fetch.
     */
    where: event_typesWhereUniqueInput
  }

  /**
   * event_types findUniqueOrThrow
   */
  export type event_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * Filter, which event_types to fetch.
     */
    where: event_typesWhereUniqueInput
  }

  /**
   * event_types findFirst
   */
  export type event_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * Filter, which event_types to fetch.
     */
    where?: event_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_types to fetch.
     */
    orderBy?: event_typesOrderByWithRelationInput | event_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_types.
     */
    cursor?: event_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_types.
     */
    distinct?: Event_typesScalarFieldEnum | Event_typesScalarFieldEnum[]
  }

  /**
   * event_types findFirstOrThrow
   */
  export type event_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * Filter, which event_types to fetch.
     */
    where?: event_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_types to fetch.
     */
    orderBy?: event_typesOrderByWithRelationInput | event_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_types.
     */
    cursor?: event_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_types.
     */
    distinct?: Event_typesScalarFieldEnum | Event_typesScalarFieldEnum[]
  }

  /**
   * event_types findMany
   */
  export type event_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * Filter, which event_types to fetch.
     */
    where?: event_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_types to fetch.
     */
    orderBy?: event_typesOrderByWithRelationInput | event_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_types.
     */
    cursor?: event_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_types.
     */
    skip?: number
    distinct?: Event_typesScalarFieldEnum | Event_typesScalarFieldEnum[]
  }

  /**
   * event_types create
   */
  export type event_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a event_types.
     */
    data: XOR<event_typesCreateInput, event_typesUncheckedCreateInput>
  }

  /**
   * event_types createMany
   */
  export type event_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_types.
     */
    data: event_typesCreateManyInput | event_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event_types update
   */
  export type event_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a event_types.
     */
    data: XOR<event_typesUpdateInput, event_typesUncheckedUpdateInput>
    /**
     * Choose, which event_types to update.
     */
    where: event_typesWhereUniqueInput
  }

  /**
   * event_types updateMany
   */
  export type event_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_types.
     */
    data: XOR<event_typesUpdateManyMutationInput, event_typesUncheckedUpdateManyInput>
    /**
     * Filter which event_types to update
     */
    where?: event_typesWhereInput
  }

  /**
   * event_types upsert
   */
  export type event_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the event_types to update in case it exists.
     */
    where: event_typesWhereUniqueInput
    /**
     * In case the event_types found by the `where` argument doesn't exist, create a new event_types with this data.
     */
    create: XOR<event_typesCreateInput, event_typesUncheckedCreateInput>
    /**
     * In case the event_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_typesUpdateInput, event_typesUncheckedUpdateInput>
  }

  /**
   * event_types delete
   */
  export type event_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
    /**
     * Filter which event_types to delete.
     */
    where: event_typesWhereUniqueInput
  }

  /**
   * event_types deleteMany
   */
  export type event_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_types to delete
     */
    where?: event_typesWhereInput
  }

  /**
   * event_types.school_events
   */
  export type event_types$school_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    where?: school_eventsWhereInput
    orderBy?: school_eventsOrderByWithRelationInput | school_eventsOrderByWithRelationInput[]
    cursor?: school_eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: School_eventsScalarFieldEnum | School_eventsScalarFieldEnum[]
  }

  /**
   * event_types without action
   */
  export type event_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_types
     */
    select?: event_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: event_typesInclude<ExtArgs> | null
  }


  /**
   * Model grades_gradebook
   */

  export type AggregateGrades_gradebook = {
    _count: Grades_gradebookCountAggregateOutputType | null
    _avg: Grades_gradebookAvgAggregateOutputType | null
    _sum: Grades_gradebookSumAggregateOutputType | null
    _min: Grades_gradebookMinAggregateOutputType | null
    _max: Grades_gradebookMaxAggregateOutputType | null
  }

  export type Grades_gradebookAvgAggregateOutputType = {
    grade: number | null
    weight: number | null
  }

  export type Grades_gradebookSumAggregateOutputType = {
    grade: number | null
    weight: number | null
  }

  export type Grades_gradebookMinAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    grade: number | null
    weight: number | null
    date_given: Date | null
    student_id: Uint8Array | null
    subject_id: Uint8Array | null
    teacher_id: Uint8Array | null
  }

  export type Grades_gradebookMaxAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    grade: number | null
    weight: number | null
    date_given: Date | null
    student_id: Uint8Array | null
    subject_id: Uint8Array | null
    teacher_id: Uint8Array | null
  }

  export type Grades_gradebookCountAggregateOutputType = {
    id: number
    description: number
    grade: number
    weight: number
    date_given: number
    student_id: number
    subject_id: number
    teacher_id: number
    _all: number
  }


  export type Grades_gradebookAvgAggregateInputType = {
    grade?: true
    weight?: true
  }

  export type Grades_gradebookSumAggregateInputType = {
    grade?: true
    weight?: true
  }

  export type Grades_gradebookMinAggregateInputType = {
    id?: true
    description?: true
    grade?: true
    weight?: true
    date_given?: true
    student_id?: true
    subject_id?: true
    teacher_id?: true
  }

  export type Grades_gradebookMaxAggregateInputType = {
    id?: true
    description?: true
    grade?: true
    weight?: true
    date_given?: true
    student_id?: true
    subject_id?: true
    teacher_id?: true
  }

  export type Grades_gradebookCountAggregateInputType = {
    id?: true
    description?: true
    grade?: true
    weight?: true
    date_given?: true
    student_id?: true
    subject_id?: true
    teacher_id?: true
    _all?: true
  }

  export type Grades_gradebookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grades_gradebook to aggregate.
     */
    where?: grades_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_gradebooks to fetch.
     */
    orderBy?: grades_gradebookOrderByWithRelationInput | grades_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grades_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_gradebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grades_gradebooks
    **/
    _count?: true | Grades_gradebookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Grades_gradebookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Grades_gradebookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Grades_gradebookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Grades_gradebookMaxAggregateInputType
  }

  export type GetGrades_gradebookAggregateType<T extends Grades_gradebookAggregateArgs> = {
        [P in keyof T & keyof AggregateGrades_gradebook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrades_gradebook[P]>
      : GetScalarType<T[P], AggregateGrades_gradebook[P]>
  }




  export type grades_gradebookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grades_gradebookWhereInput
    orderBy?: grades_gradebookOrderByWithAggregationInput | grades_gradebookOrderByWithAggregationInput[]
    by: Grades_gradebookScalarFieldEnum[] | Grades_gradebookScalarFieldEnum
    having?: grades_gradebookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Grades_gradebookCountAggregateInputType | true
    _avg?: Grades_gradebookAvgAggregateInputType
    _sum?: Grades_gradebookSumAggregateInputType
    _min?: Grades_gradebookMinAggregateInputType
    _max?: Grades_gradebookMaxAggregateInputType
  }

  export type Grades_gradebookGroupByOutputType = {
    id: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
    _count: Grades_gradebookCountAggregateOutputType | null
    _avg: Grades_gradebookAvgAggregateOutputType | null
    _sum: Grades_gradebookSumAggregateOutputType | null
    _min: Grades_gradebookMinAggregateOutputType | null
    _max: Grades_gradebookMaxAggregateOutputType | null
  }

  type GetGrades_gradebookGroupByPayload<T extends grades_gradebookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Grades_gradebookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Grades_gradebookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Grades_gradebookGroupByOutputType[P]>
            : GetScalarType<T[P], Grades_gradebookGroupByOutputType[P]>
        }
      >
    >


  export type grades_gradebookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    grade?: boolean
    weight?: boolean
    date_given?: boolean
    student_id?: boolean
    subject_id?: boolean
    teacher_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades_gradebook"]>



  export type grades_gradebookSelectScalar = {
    id?: boolean
    description?: boolean
    grade?: boolean
    weight?: boolean
    date_given?: boolean
    student_id?: boolean
    subject_id?: boolean
    teacher_id?: boolean
  }

  export type grades_gradebookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }

  export type $grades_gradebookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grades_gradebook"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      description: string
      grade: number
      weight: number
      date_given: Date
      student_id: Uint8Array
      subject_id: Uint8Array
      teacher_id: Uint8Array
    }, ExtArgs["result"]["grades_gradebook"]>
    composites: {}
  }

  type grades_gradebookGetPayload<S extends boolean | null | undefined | grades_gradebookDefaultArgs> = $Result.GetResult<Prisma.$grades_gradebookPayload, S>

  type grades_gradebookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<grades_gradebookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Grades_gradebookCountAggregateInputType | true
    }

  export interface grades_gradebookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grades_gradebook'], meta: { name: 'grades_gradebook' } }
    /**
     * Find zero or one Grades_gradebook that matches the filter.
     * @param {grades_gradebookFindUniqueArgs} args - Arguments to find a Grades_gradebook
     * @example
     * // Get one Grades_gradebook
     * const grades_gradebook = await prisma.grades_gradebook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grades_gradebookFindUniqueArgs>(args: SelectSubset<T, grades_gradebookFindUniqueArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grades_gradebook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {grades_gradebookFindUniqueOrThrowArgs} args - Arguments to find a Grades_gradebook
     * @example
     * // Get one Grades_gradebook
     * const grades_gradebook = await prisma.grades_gradebook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grades_gradebookFindUniqueOrThrowArgs>(args: SelectSubset<T, grades_gradebookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grades_gradebook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_gradebookFindFirstArgs} args - Arguments to find a Grades_gradebook
     * @example
     * // Get one Grades_gradebook
     * const grades_gradebook = await prisma.grades_gradebook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grades_gradebookFindFirstArgs>(args?: SelectSubset<T, grades_gradebookFindFirstArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grades_gradebook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_gradebookFindFirstOrThrowArgs} args - Arguments to find a Grades_gradebook
     * @example
     * // Get one Grades_gradebook
     * const grades_gradebook = await prisma.grades_gradebook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grades_gradebookFindFirstOrThrowArgs>(args?: SelectSubset<T, grades_gradebookFindFirstOrThrowArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grades_gradebooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_gradebookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades_gradebooks
     * const grades_gradebooks = await prisma.grades_gradebook.findMany()
     * 
     * // Get first 10 Grades_gradebooks
     * const grades_gradebooks = await prisma.grades_gradebook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grades_gradebookWithIdOnly = await prisma.grades_gradebook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grades_gradebookFindManyArgs>(args?: SelectSubset<T, grades_gradebookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grades_gradebook.
     * @param {grades_gradebookCreateArgs} args - Arguments to create a Grades_gradebook.
     * @example
     * // Create one Grades_gradebook
     * const Grades_gradebook = await prisma.grades_gradebook.create({
     *   data: {
     *     // ... data to create a Grades_gradebook
     *   }
     * })
     * 
     */
    create<T extends grades_gradebookCreateArgs>(args: SelectSubset<T, grades_gradebookCreateArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grades_gradebooks.
     * @param {grades_gradebookCreateManyArgs} args - Arguments to create many Grades_gradebooks.
     * @example
     * // Create many Grades_gradebooks
     * const grades_gradebook = await prisma.grades_gradebook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grades_gradebookCreateManyArgs>(args?: SelectSubset<T, grades_gradebookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Grades_gradebook.
     * @param {grades_gradebookDeleteArgs} args - Arguments to delete one Grades_gradebook.
     * @example
     * // Delete one Grades_gradebook
     * const Grades_gradebook = await prisma.grades_gradebook.delete({
     *   where: {
     *     // ... filter to delete one Grades_gradebook
     *   }
     * })
     * 
     */
    delete<T extends grades_gradebookDeleteArgs>(args: SelectSubset<T, grades_gradebookDeleteArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grades_gradebook.
     * @param {grades_gradebookUpdateArgs} args - Arguments to update one Grades_gradebook.
     * @example
     * // Update one Grades_gradebook
     * const grades_gradebook = await prisma.grades_gradebook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grades_gradebookUpdateArgs>(args: SelectSubset<T, grades_gradebookUpdateArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grades_gradebooks.
     * @param {grades_gradebookDeleteManyArgs} args - Arguments to filter Grades_gradebooks to delete.
     * @example
     * // Delete a few Grades_gradebooks
     * const { count } = await prisma.grades_gradebook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grades_gradebookDeleteManyArgs>(args?: SelectSubset<T, grades_gradebookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades_gradebooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_gradebookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades_gradebooks
     * const grades_gradebook = await prisma.grades_gradebook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grades_gradebookUpdateManyArgs>(args: SelectSubset<T, grades_gradebookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grades_gradebook.
     * @param {grades_gradebookUpsertArgs} args - Arguments to update or create a Grades_gradebook.
     * @example
     * // Update or create a Grades_gradebook
     * const grades_gradebook = await prisma.grades_gradebook.upsert({
     *   create: {
     *     // ... data to create a Grades_gradebook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grades_gradebook we want to update
     *   }
     * })
     */
    upsert<T extends grades_gradebookUpsertArgs>(args: SelectSubset<T, grades_gradebookUpsertArgs<ExtArgs>>): Prisma__grades_gradebookClient<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grades_gradebooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_gradebookCountArgs} args - Arguments to filter Grades_gradebooks to count.
     * @example
     * // Count the number of Grades_gradebooks
     * const count = await prisma.grades_gradebook.count({
     *   where: {
     *     // ... the filter for the Grades_gradebooks we want to count
     *   }
     * })
    **/
    count<T extends grades_gradebookCountArgs>(
      args?: Subset<T, grades_gradebookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Grades_gradebookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grades_gradebook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Grades_gradebookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Grades_gradebookAggregateArgs>(args: Subset<T, Grades_gradebookAggregateArgs>): Prisma.PrismaPromise<GetGrades_gradebookAggregateType<T>>

    /**
     * Group by Grades_gradebook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_gradebookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grades_gradebookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grades_gradebookGroupByArgs['orderBy'] }
        : { orderBy?: grades_gradebookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grades_gradebookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrades_gradebookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grades_gradebook model
   */
  readonly fields: grades_gradebookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grades_gradebook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grades_gradebookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grades_gradebook model
   */ 
  interface grades_gradebookFieldRefs {
    readonly id: FieldRef<"grades_gradebook", 'Bytes'>
    readonly description: FieldRef<"grades_gradebook", 'String'>
    readonly grade: FieldRef<"grades_gradebook", 'Int'>
    readonly weight: FieldRef<"grades_gradebook", 'Int'>
    readonly date_given: FieldRef<"grades_gradebook", 'DateTime'>
    readonly student_id: FieldRef<"grades_gradebook", 'Bytes'>
    readonly subject_id: FieldRef<"grades_gradebook", 'Bytes'>
    readonly teacher_id: FieldRef<"grades_gradebook", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * grades_gradebook findUnique
   */
  export type grades_gradebookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which grades_gradebook to fetch.
     */
    where: grades_gradebookWhereUniqueInput
  }

  /**
   * grades_gradebook findUniqueOrThrow
   */
  export type grades_gradebookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which grades_gradebook to fetch.
     */
    where: grades_gradebookWhereUniqueInput
  }

  /**
   * grades_gradebook findFirst
   */
  export type grades_gradebookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which grades_gradebook to fetch.
     */
    where?: grades_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_gradebooks to fetch.
     */
    orderBy?: grades_gradebookOrderByWithRelationInput | grades_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grades_gradebooks.
     */
    cursor?: grades_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_gradebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grades_gradebooks.
     */
    distinct?: Grades_gradebookScalarFieldEnum | Grades_gradebookScalarFieldEnum[]
  }

  /**
   * grades_gradebook findFirstOrThrow
   */
  export type grades_gradebookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which grades_gradebook to fetch.
     */
    where?: grades_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_gradebooks to fetch.
     */
    orderBy?: grades_gradebookOrderByWithRelationInput | grades_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grades_gradebooks.
     */
    cursor?: grades_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_gradebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grades_gradebooks.
     */
    distinct?: Grades_gradebookScalarFieldEnum | Grades_gradebookScalarFieldEnum[]
  }

  /**
   * grades_gradebook findMany
   */
  export type grades_gradebookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which grades_gradebooks to fetch.
     */
    where?: grades_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_gradebooks to fetch.
     */
    orderBy?: grades_gradebookOrderByWithRelationInput | grades_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grades_gradebooks.
     */
    cursor?: grades_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_gradebooks.
     */
    skip?: number
    distinct?: Grades_gradebookScalarFieldEnum | Grades_gradebookScalarFieldEnum[]
  }

  /**
   * grades_gradebook create
   */
  export type grades_gradebookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * The data needed to create a grades_gradebook.
     */
    data: XOR<grades_gradebookCreateInput, grades_gradebookUncheckedCreateInput>
  }

  /**
   * grades_gradebook createMany
   */
  export type grades_gradebookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grades_gradebooks.
     */
    data: grades_gradebookCreateManyInput | grades_gradebookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grades_gradebook update
   */
  export type grades_gradebookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * The data needed to update a grades_gradebook.
     */
    data: XOR<grades_gradebookUpdateInput, grades_gradebookUncheckedUpdateInput>
    /**
     * Choose, which grades_gradebook to update.
     */
    where: grades_gradebookWhereUniqueInput
  }

  /**
   * grades_gradebook updateMany
   */
  export type grades_gradebookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grades_gradebooks.
     */
    data: XOR<grades_gradebookUpdateManyMutationInput, grades_gradebookUncheckedUpdateManyInput>
    /**
     * Filter which grades_gradebooks to update
     */
    where?: grades_gradebookWhereInput
  }

  /**
   * grades_gradebook upsert
   */
  export type grades_gradebookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * The filter to search for the grades_gradebook to update in case it exists.
     */
    where: grades_gradebookWhereUniqueInput
    /**
     * In case the grades_gradebook found by the `where` argument doesn't exist, create a new grades_gradebook with this data.
     */
    create: XOR<grades_gradebookCreateInput, grades_gradebookUncheckedCreateInput>
    /**
     * In case the grades_gradebook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grades_gradebookUpdateInput, grades_gradebookUncheckedUpdateInput>
  }

  /**
   * grades_gradebook delete
   */
  export type grades_gradebookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    /**
     * Filter which grades_gradebook to delete.
     */
    where: grades_gradebookWhereUniqueInput
  }

  /**
   * grades_gradebook deleteMany
   */
  export type grades_gradebookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grades_gradebooks to delete
     */
    where?: grades_gradebookWhereInput
  }

  /**
   * grades_gradebook without action
   */
  export type grades_gradebookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
  }


  /**
   * Model homeworks
   */

  export type AggregateHomeworks = {
    _count: HomeworksCountAggregateOutputType | null
    _min: HomeworksMinAggregateOutputType | null
    _max: HomeworksMaxAggregateOutputType | null
  }

  export type HomeworksMinAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    deadline: Date | null
    lesson_id: Uint8Array | null
  }

  export type HomeworksMaxAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    deadline: Date | null
    lesson_id: Uint8Array | null
  }

  export type HomeworksCountAggregateOutputType = {
    id: number
    description: number
    deadline: number
    lesson_id: number
    _all: number
  }


  export type HomeworksMinAggregateInputType = {
    id?: true
    description?: true
    deadline?: true
    lesson_id?: true
  }

  export type HomeworksMaxAggregateInputType = {
    id?: true
    description?: true
    deadline?: true
    lesson_id?: true
  }

  export type HomeworksCountAggregateInputType = {
    id?: true
    description?: true
    deadline?: true
    lesson_id?: true
    _all?: true
  }

  export type HomeworksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which homeworks to aggregate.
     */
    where?: homeworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeworks to fetch.
     */
    orderBy?: homeworksOrderByWithRelationInput | homeworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: homeworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned homeworks
    **/
    _count?: true | HomeworksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeworksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeworksMaxAggregateInputType
  }

  export type GetHomeworksAggregateType<T extends HomeworksAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeworks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeworks[P]>
      : GetScalarType<T[P], AggregateHomeworks[P]>
  }




  export type homeworksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: homeworksWhereInput
    orderBy?: homeworksOrderByWithAggregationInput | homeworksOrderByWithAggregationInput[]
    by: HomeworksScalarFieldEnum[] | HomeworksScalarFieldEnum
    having?: homeworksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeworksCountAggregateInputType | true
    _min?: HomeworksMinAggregateInputType
    _max?: HomeworksMaxAggregateInputType
  }

  export type HomeworksGroupByOutputType = {
    id: Uint8Array
    description: string
    deadline: Date
    lesson_id: Uint8Array
    _count: HomeworksCountAggregateOutputType | null
    _min: HomeworksMinAggregateOutputType | null
    _max: HomeworksMaxAggregateOutputType | null
  }

  type GetHomeworksGroupByPayload<T extends homeworksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeworksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeworksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeworksGroupByOutputType[P]>
            : GetScalarType<T[P], HomeworksGroupByOutputType[P]>
        }
      >
    >


  export type homeworksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    deadline?: boolean
    lesson_id?: boolean
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeworks"]>



  export type homeworksSelectScalar = {
    id?: boolean
    description?: boolean
    deadline?: boolean
    lesson_id?: boolean
  }

  export type homeworksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
  }

  export type $homeworksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "homeworks"
    objects: {
      lessons: Prisma.$lessonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      description: string
      deadline: Date
      lesson_id: Uint8Array
    }, ExtArgs["result"]["homeworks"]>
    composites: {}
  }

  type homeworksGetPayload<S extends boolean | null | undefined | homeworksDefaultArgs> = $Result.GetResult<Prisma.$homeworksPayload, S>

  type homeworksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<homeworksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HomeworksCountAggregateInputType | true
    }

  export interface homeworksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['homeworks'], meta: { name: 'homeworks' } }
    /**
     * Find zero or one Homeworks that matches the filter.
     * @param {homeworksFindUniqueArgs} args - Arguments to find a Homeworks
     * @example
     * // Get one Homeworks
     * const homeworks = await prisma.homeworks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends homeworksFindUniqueArgs>(args: SelectSubset<T, homeworksFindUniqueArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Homeworks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {homeworksFindUniqueOrThrowArgs} args - Arguments to find a Homeworks
     * @example
     * // Get one Homeworks
     * const homeworks = await prisma.homeworks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends homeworksFindUniqueOrThrowArgs>(args: SelectSubset<T, homeworksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Homeworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeworksFindFirstArgs} args - Arguments to find a Homeworks
     * @example
     * // Get one Homeworks
     * const homeworks = await prisma.homeworks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends homeworksFindFirstArgs>(args?: SelectSubset<T, homeworksFindFirstArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Homeworks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeworksFindFirstOrThrowArgs} args - Arguments to find a Homeworks
     * @example
     * // Get one Homeworks
     * const homeworks = await prisma.homeworks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends homeworksFindFirstOrThrowArgs>(args?: SelectSubset<T, homeworksFindFirstOrThrowArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Homeworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeworksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Homeworks
     * const homeworks = await prisma.homeworks.findMany()
     * 
     * // Get first 10 Homeworks
     * const homeworks = await prisma.homeworks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeworksWithIdOnly = await prisma.homeworks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends homeworksFindManyArgs>(args?: SelectSubset<T, homeworksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Homeworks.
     * @param {homeworksCreateArgs} args - Arguments to create a Homeworks.
     * @example
     * // Create one Homeworks
     * const Homeworks = await prisma.homeworks.create({
     *   data: {
     *     // ... data to create a Homeworks
     *   }
     * })
     * 
     */
    create<T extends homeworksCreateArgs>(args: SelectSubset<T, homeworksCreateArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Homeworks.
     * @param {homeworksCreateManyArgs} args - Arguments to create many Homeworks.
     * @example
     * // Create many Homeworks
     * const homeworks = await prisma.homeworks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends homeworksCreateManyArgs>(args?: SelectSubset<T, homeworksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Homeworks.
     * @param {homeworksDeleteArgs} args - Arguments to delete one Homeworks.
     * @example
     * // Delete one Homeworks
     * const Homeworks = await prisma.homeworks.delete({
     *   where: {
     *     // ... filter to delete one Homeworks
     *   }
     * })
     * 
     */
    delete<T extends homeworksDeleteArgs>(args: SelectSubset<T, homeworksDeleteArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Homeworks.
     * @param {homeworksUpdateArgs} args - Arguments to update one Homeworks.
     * @example
     * // Update one Homeworks
     * const homeworks = await prisma.homeworks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends homeworksUpdateArgs>(args: SelectSubset<T, homeworksUpdateArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Homeworks.
     * @param {homeworksDeleteManyArgs} args - Arguments to filter Homeworks to delete.
     * @example
     * // Delete a few Homeworks
     * const { count } = await prisma.homeworks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends homeworksDeleteManyArgs>(args?: SelectSubset<T, homeworksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Homeworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeworksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Homeworks
     * const homeworks = await prisma.homeworks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends homeworksUpdateManyArgs>(args: SelectSubset<T, homeworksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Homeworks.
     * @param {homeworksUpsertArgs} args - Arguments to update or create a Homeworks.
     * @example
     * // Update or create a Homeworks
     * const homeworks = await prisma.homeworks.upsert({
     *   create: {
     *     // ... data to create a Homeworks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Homeworks we want to update
     *   }
     * })
     */
    upsert<T extends homeworksUpsertArgs>(args: SelectSubset<T, homeworksUpsertArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Homeworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeworksCountArgs} args - Arguments to filter Homeworks to count.
     * @example
     * // Count the number of Homeworks
     * const count = await prisma.homeworks.count({
     *   where: {
     *     // ... the filter for the Homeworks we want to count
     *   }
     * })
    **/
    count<T extends homeworksCountArgs>(
      args?: Subset<T, homeworksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeworksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Homeworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeworksAggregateArgs>(args: Subset<T, HomeworksAggregateArgs>): Prisma.PrismaPromise<GetHomeworksAggregateType<T>>

    /**
     * Group by Homeworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeworksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends homeworksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: homeworksGroupByArgs['orderBy'] }
        : { orderBy?: homeworksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, homeworksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeworksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the homeworks model
   */
  readonly fields: homeworksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for homeworks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__homeworksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends lessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, lessonsDefaultArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the homeworks model
   */ 
  interface homeworksFieldRefs {
    readonly id: FieldRef<"homeworks", 'Bytes'>
    readonly description: FieldRef<"homeworks", 'String'>
    readonly deadline: FieldRef<"homeworks", 'DateTime'>
    readonly lesson_id: FieldRef<"homeworks", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * homeworks findUnique
   */
  export type homeworksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * Filter, which homeworks to fetch.
     */
    where: homeworksWhereUniqueInput
  }

  /**
   * homeworks findUniqueOrThrow
   */
  export type homeworksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * Filter, which homeworks to fetch.
     */
    where: homeworksWhereUniqueInput
  }

  /**
   * homeworks findFirst
   */
  export type homeworksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * Filter, which homeworks to fetch.
     */
    where?: homeworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeworks to fetch.
     */
    orderBy?: homeworksOrderByWithRelationInput | homeworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for homeworks.
     */
    cursor?: homeworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of homeworks.
     */
    distinct?: HomeworksScalarFieldEnum | HomeworksScalarFieldEnum[]
  }

  /**
   * homeworks findFirstOrThrow
   */
  export type homeworksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * Filter, which homeworks to fetch.
     */
    where?: homeworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeworks to fetch.
     */
    orderBy?: homeworksOrderByWithRelationInput | homeworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for homeworks.
     */
    cursor?: homeworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of homeworks.
     */
    distinct?: HomeworksScalarFieldEnum | HomeworksScalarFieldEnum[]
  }

  /**
   * homeworks findMany
   */
  export type homeworksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * Filter, which homeworks to fetch.
     */
    where?: homeworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeworks to fetch.
     */
    orderBy?: homeworksOrderByWithRelationInput | homeworksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing homeworks.
     */
    cursor?: homeworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeworks.
     */
    skip?: number
    distinct?: HomeworksScalarFieldEnum | HomeworksScalarFieldEnum[]
  }

  /**
   * homeworks create
   */
  export type homeworksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * The data needed to create a homeworks.
     */
    data: XOR<homeworksCreateInput, homeworksUncheckedCreateInput>
  }

  /**
   * homeworks createMany
   */
  export type homeworksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many homeworks.
     */
    data: homeworksCreateManyInput | homeworksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * homeworks update
   */
  export type homeworksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * The data needed to update a homeworks.
     */
    data: XOR<homeworksUpdateInput, homeworksUncheckedUpdateInput>
    /**
     * Choose, which homeworks to update.
     */
    where: homeworksWhereUniqueInput
  }

  /**
   * homeworks updateMany
   */
  export type homeworksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update homeworks.
     */
    data: XOR<homeworksUpdateManyMutationInput, homeworksUncheckedUpdateManyInput>
    /**
     * Filter which homeworks to update
     */
    where?: homeworksWhereInput
  }

  /**
   * homeworks upsert
   */
  export type homeworksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * The filter to search for the homeworks to update in case it exists.
     */
    where: homeworksWhereUniqueInput
    /**
     * In case the homeworks found by the `where` argument doesn't exist, create a new homeworks with this data.
     */
    create: XOR<homeworksCreateInput, homeworksUncheckedCreateInput>
    /**
     * In case the homeworks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<homeworksUpdateInput, homeworksUncheckedUpdateInput>
  }

  /**
   * homeworks delete
   */
  export type homeworksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    /**
     * Filter which homeworks to delete.
     */
    where: homeworksWhereUniqueInput
  }

  /**
   * homeworks deleteMany
   */
  export type homeworksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which homeworks to delete
     */
    where?: homeworksWhereInput
  }

  /**
   * homeworks without action
   */
  export type homeworksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
  }


  /**
   * Model lessons
   */

  export type AggregateLessons = {
    _count: LessonsCountAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  export type LessonsMinAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    teacher_id: Uint8Array | null
    class_id: Uint8Array | null
    subject_id: Uint8Array | null
  }

  export type LessonsMaxAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    teacher_id: Uint8Array | null
    class_id: Uint8Array | null
    subject_id: Uint8Array | null
  }

  export type LessonsCountAggregateOutputType = {
    id: number
    description: number
    date: number
    start_time: number
    end_time: number
    teacher_id: number
    class_id: number
    subject_id: number
    _all: number
  }


  export type LessonsMinAggregateInputType = {
    id?: true
    description?: true
    date?: true
    start_time?: true
    end_time?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
  }

  export type LessonsMaxAggregateInputType = {
    id?: true
    description?: true
    date?: true
    start_time?: true
    end_time?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
  }

  export type LessonsCountAggregateInputType = {
    id?: true
    description?: true
    date?: true
    start_time?: true
    end_time?: true
    teacher_id?: true
    class_id?: true
    subject_id?: true
    _all?: true
  }

  export type LessonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lessons to aggregate.
     */
    where?: lessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonsOrderByWithRelationInput | lessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lessons
    **/
    _count?: true | LessonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonsMaxAggregateInputType
  }

  export type GetLessonsAggregateType<T extends LessonsAggregateArgs> = {
        [P in keyof T & keyof AggregateLessons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessons[P]>
      : GetScalarType<T[P], AggregateLessons[P]>
  }




  export type lessonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonsWhereInput
    orderBy?: lessonsOrderByWithAggregationInput | lessonsOrderByWithAggregationInput[]
    by: LessonsScalarFieldEnum[] | LessonsScalarFieldEnum
    having?: lessonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonsCountAggregateInputType | true
    _min?: LessonsMinAggregateInputType
    _max?: LessonsMaxAggregateInputType
  }

  export type LessonsGroupByOutputType = {
    id: Uint8Array
    description: string | null
    date: Date
    start_time: Date
    end_time: Date
    teacher_id: Uint8Array
    class_id: Uint8Array
    subject_id: Uint8Array
    _count: LessonsCountAggregateOutputType | null
    _min: LessonsMinAggregateOutputType | null
    _max: LessonsMaxAggregateOutputType | null
  }

  type GetLessonsGroupByPayload<T extends lessonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonsGroupByOutputType[P]>
            : GetScalarType<T[P], LessonsGroupByOutputType[P]>
        }
      >
    >


  export type lessonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
    attendances?: boolean | lessons$attendancesArgs<ExtArgs>
    exams?: boolean | lessons$examsArgs<ExtArgs>
    gradebook_exams?: boolean | lessons$gradebook_examsArgs<ExtArgs>
    homeworks?: boolean | lessons$homeworksArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    classes?: boolean | classesDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | LessonsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessons"]>



  export type lessonsSelectScalar = {
    id?: boolean
    description?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    teacher_id?: boolean
    class_id?: boolean
    subject_id?: boolean
  }

  export type lessonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | lessons$attendancesArgs<ExtArgs>
    exams?: boolean | lessons$examsArgs<ExtArgs>
    gradebook_exams?: boolean | lessons$gradebook_examsArgs<ExtArgs>
    homeworks?: boolean | lessons$homeworksArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    classes?: boolean | classesDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    _count?: boolean | LessonsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $lessonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lessons"
    objects: {
      attendances: Prisma.$attendancesPayload<ExtArgs>[]
      exams: Prisma.$examsPayload<ExtArgs>[]
      gradebook_exams: Prisma.$gradebook_examsPayload<ExtArgs>[]
      homeworks: Prisma.$homeworksPayload<ExtArgs> | null
      teachers: Prisma.$teachersPayload<ExtArgs>
      classes: Prisma.$classesPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      description: string | null
      date: Date
      start_time: Date
      end_time: Date
      teacher_id: Uint8Array
      class_id: Uint8Array
      subject_id: Uint8Array
    }, ExtArgs["result"]["lessons"]>
    composites: {}
  }

  type lessonsGetPayload<S extends boolean | null | undefined | lessonsDefaultArgs> = $Result.GetResult<Prisma.$lessonsPayload, S>

  type lessonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lessonsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonsCountAggregateInputType | true
    }

  export interface lessonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lessons'], meta: { name: 'lessons' } }
    /**
     * Find zero or one Lessons that matches the filter.
     * @param {lessonsFindUniqueArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lessonsFindUniqueArgs>(args: SelectSubset<T, lessonsFindUniqueArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lessons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lessonsFindUniqueOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lessonsFindUniqueOrThrowArgs>(args: SelectSubset<T, lessonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonsFindFirstArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lessonsFindFirstArgs>(args?: SelectSubset<T, lessonsFindFirstArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lessons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonsFindFirstOrThrowArgs} args - Arguments to find a Lessons
     * @example
     * // Get one Lessons
     * const lessons = await prisma.lessons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lessonsFindFirstOrThrowArgs>(args?: SelectSubset<T, lessonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lessons.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lessons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonsWithIdOnly = await prisma.lessons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lessonsFindManyArgs>(args?: SelectSubset<T, lessonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lessons.
     * @param {lessonsCreateArgs} args - Arguments to create a Lessons.
     * @example
     * // Create one Lessons
     * const Lessons = await prisma.lessons.create({
     *   data: {
     *     // ... data to create a Lessons
     *   }
     * })
     * 
     */
    create<T extends lessonsCreateArgs>(args: SelectSubset<T, lessonsCreateArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lessons.
     * @param {lessonsCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lessons = await prisma.lessons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lessonsCreateManyArgs>(args?: SelectSubset<T, lessonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lessons.
     * @param {lessonsDeleteArgs} args - Arguments to delete one Lessons.
     * @example
     * // Delete one Lessons
     * const Lessons = await prisma.lessons.delete({
     *   where: {
     *     // ... filter to delete one Lessons
     *   }
     * })
     * 
     */
    delete<T extends lessonsDeleteArgs>(args: SelectSubset<T, lessonsDeleteArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lessons.
     * @param {lessonsUpdateArgs} args - Arguments to update one Lessons.
     * @example
     * // Update one Lessons
     * const lessons = await prisma.lessons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lessonsUpdateArgs>(args: SelectSubset<T, lessonsUpdateArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {lessonsDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lessons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lessonsDeleteManyArgs>(args?: SelectSubset<T, lessonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lessons = await prisma.lessons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lessonsUpdateManyArgs>(args: SelectSubset<T, lessonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lessons.
     * @param {lessonsUpsertArgs} args - Arguments to update or create a Lessons.
     * @example
     * // Update or create a Lessons
     * const lessons = await prisma.lessons.upsert({
     *   create: {
     *     // ... data to create a Lessons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lessons we want to update
     *   }
     * })
     */
    upsert<T extends lessonsUpsertArgs>(args: SelectSubset<T, lessonsUpsertArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonsCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lessons.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends lessonsCountArgs>(
      args?: Subset<T, lessonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonsAggregateArgs>(args: Subset<T, LessonsAggregateArgs>): Prisma.PrismaPromise<GetLessonsAggregateType<T>>

    /**
     * Group by Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lessonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lessonsGroupByArgs['orderBy'] }
        : { orderBy?: lessonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lessonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lessons model
   */
  readonly fields: lessonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lessons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lessonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendances<T extends lessons$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, lessons$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends lessons$examsArgs<ExtArgs> = {}>(args?: Subset<T, lessons$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findMany"> | Null>
    gradebook_exams<T extends lessons$gradebook_examsArgs<ExtArgs> = {}>(args?: Subset<T, lessons$gradebook_examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "findMany"> | Null>
    homeworks<T extends lessons$homeworksArgs<ExtArgs> = {}>(args?: Subset<T, lessons$homeworksArgs<ExtArgs>>): Prisma__homeworksClient<$Result.GetResult<Prisma.$homeworksPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    classes<T extends classesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classesDefaultArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lessons model
   */ 
  interface lessonsFieldRefs {
    readonly id: FieldRef<"lessons", 'Bytes'>
    readonly description: FieldRef<"lessons", 'String'>
    readonly date: FieldRef<"lessons", 'DateTime'>
    readonly start_time: FieldRef<"lessons", 'DateTime'>
    readonly end_time: FieldRef<"lessons", 'DateTime'>
    readonly teacher_id: FieldRef<"lessons", 'Bytes'>
    readonly class_id: FieldRef<"lessons", 'Bytes'>
    readonly subject_id: FieldRef<"lessons", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * lessons findUnique
   */
  export type lessonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * Filter, which lessons to fetch.
     */
    where: lessonsWhereUniqueInput
  }

  /**
   * lessons findUniqueOrThrow
   */
  export type lessonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * Filter, which lessons to fetch.
     */
    where: lessonsWhereUniqueInput
  }

  /**
   * lessons findFirst
   */
  export type lessonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * Filter, which lessons to fetch.
     */
    where?: lessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonsOrderByWithRelationInput | lessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lessons.
     */
    cursor?: lessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * lessons findFirstOrThrow
   */
  export type lessonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * Filter, which lessons to fetch.
     */
    where?: lessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonsOrderByWithRelationInput | lessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lessons.
     */
    cursor?: lessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lessons.
     */
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * lessons findMany
   */
  export type lessonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * Filter, which lessons to fetch.
     */
    where?: lessonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonsOrderByWithRelationInput | lessonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lessons.
     */
    cursor?: lessonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * lessons create
   */
  export type lessonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * The data needed to create a lessons.
     */
    data: XOR<lessonsCreateInput, lessonsUncheckedCreateInput>
  }

  /**
   * lessons createMany
   */
  export type lessonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lessons.
     */
    data: lessonsCreateManyInput | lessonsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lessons update
   */
  export type lessonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * The data needed to update a lessons.
     */
    data: XOR<lessonsUpdateInput, lessonsUncheckedUpdateInput>
    /**
     * Choose, which lessons to update.
     */
    where: lessonsWhereUniqueInput
  }

  /**
   * lessons updateMany
   */
  export type lessonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lessons.
     */
    data: XOR<lessonsUpdateManyMutationInput, lessonsUncheckedUpdateManyInput>
    /**
     * Filter which lessons to update
     */
    where?: lessonsWhereInput
  }

  /**
   * lessons upsert
   */
  export type lessonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * The filter to search for the lessons to update in case it exists.
     */
    where: lessonsWhereUniqueInput
    /**
     * In case the lessons found by the `where` argument doesn't exist, create a new lessons with this data.
     */
    create: XOR<lessonsCreateInput, lessonsUncheckedCreateInput>
    /**
     * In case the lessons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lessonsUpdateInput, lessonsUncheckedUpdateInput>
  }

  /**
   * lessons delete
   */
  export type lessonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    /**
     * Filter which lessons to delete.
     */
    where: lessonsWhereUniqueInput
  }

  /**
   * lessons deleteMany
   */
  export type lessonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lessons to delete
     */
    where?: lessonsWhereInput
  }

  /**
   * lessons.attendances
   */
  export type lessons$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    where?: attendancesWhereInput
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    cursor?: attendancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * lessons.exams
   */
  export type lessons$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    where?: examsWhereInput
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    cursor?: examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * lessons.gradebook_exams
   */
  export type lessons$gradebook_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    where?: gradebook_examsWhereInput
    orderBy?: gradebook_examsOrderByWithRelationInput | gradebook_examsOrderByWithRelationInput[]
    cursor?: gradebook_examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Gradebook_examsScalarFieldEnum | Gradebook_examsScalarFieldEnum[]
  }

  /**
   * lessons.homeworks
   */
  export type lessons$homeworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeworks
     */
    select?: homeworksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: homeworksInclude<ExtArgs> | null
    where?: homeworksWhereInput
  }

  /**
   * lessons without action
   */
  export type lessonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
  }


  /**
   * Model messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesMinAggregateOutputType = {
    id: Uint8Array | null
    subject: string | null
    content: string | null
    date_time: Date | null
    was_read: boolean | null
    sender_id: Uint8Array | null
    sender_type_id: Uint8Array | null
    receiver_id: Uint8Array | null
    receiver_type_id: Uint8Array | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: Uint8Array | null
    subject: string | null
    content: string | null
    date_time: Date | null
    was_read: boolean | null
    sender_id: Uint8Array | null
    sender_type_id: Uint8Array | null
    receiver_id: Uint8Array | null
    receiver_type_id: Uint8Array | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    subject: number
    content: number
    date_time: number
    was_read: number
    sender_id: number
    sender_type_id: number
    receiver_id: number
    receiver_type_id: number
    _all: number
  }


  export type MessagesMinAggregateInputType = {
    id?: true
    subject?: true
    content?: true
    date_time?: true
    was_read?: true
    sender_id?: true
    sender_type_id?: true
    receiver_id?: true
    receiver_type_id?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    subject?: true
    content?: true
    date_time?: true
    was_read?: true
    sender_id?: true
    sender_type_id?: true
    receiver_id?: true
    receiver_type_id?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    subject?: true
    content?: true
    date_time?: true
    was_read?: true
    sender_id?: true
    sender_type_id?: true
    receiver_id?: true
    receiver_type_id?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to aggregate.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithAggregationInput | messagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: Uint8Array
    subject: string
    content: string
    date_time: Date
    was_read: boolean
    sender_id: Uint8Array
    sender_type_id: Uint8Array
    receiver_id: Uint8Array
    receiver_type_id: Uint8Array
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    content?: boolean
    date_time?: boolean
    was_read?: boolean
    sender_id?: boolean
    sender_type_id?: boolean
    receiver_id?: boolean
    receiver_type_id?: boolean
    user_types_messages_sender_type_idTouser_types?: boolean | user_typesDefaultArgs<ExtArgs>
    user_types_messages_receiver_type_idTouser_types?: boolean | user_typesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>



  export type messagesSelectScalar = {
    id?: boolean
    subject?: boolean
    content?: boolean
    date_time?: boolean
    was_read?: boolean
    sender_id?: boolean
    sender_type_id?: boolean
    receiver_id?: boolean
    receiver_type_id?: boolean
  }

  export type messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_types_messages_sender_type_idTouser_types?: boolean | user_typesDefaultArgs<ExtArgs>
    user_types_messages_receiver_type_idTouser_types?: boolean | user_typesDefaultArgs<ExtArgs>
  }

  export type $messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages"
    objects: {
      user_types_messages_sender_type_idTouser_types: Prisma.$user_typesPayload<ExtArgs>
      user_types_messages_receiver_type_idTouser_types: Prisma.$user_typesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      subject: string
      content: string
      date_time: Date
      was_read: boolean
      sender_id: Uint8Array
      sender_type_id: Uint8Array
      receiver_id: Uint8Array
      receiver_type_id: Uint8Array
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type messagesGetPayload<S extends boolean | null | undefined | messagesDefaultArgs> = $Result.GetResult<Prisma.$messagesPayload, S>

  type messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages'], meta: { name: 'messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {messagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messagesFindUniqueArgs>(args: SelectSubset<T, messagesFindUniqueArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messagesFindFirstArgs>(args?: SelectSubset<T, messagesFindFirstArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messagesFindManyArgs>(args?: SelectSubset<T, messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Messages.
     * @param {messagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends messagesCreateArgs>(args: SelectSubset<T, messagesCreateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {messagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messagesCreateManyArgs>(args?: SelectSubset<T, messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Messages.
     * @param {messagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends messagesDeleteArgs>(args: SelectSubset<T, messagesDeleteArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Messages.
     * @param {messagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messagesUpdateArgs>(args: SelectSubset<T, messagesUpdateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {messagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messagesDeleteManyArgs>(args?: SelectSubset<T, messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messagesUpdateManyArgs>(args: SelectSubset<T, messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Messages.
     * @param {messagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends messagesUpsertArgs>(args: SelectSubset<T, messagesUpsertArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messagesCountArgs>(
      args?: Subset<T, messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messagesGroupByArgs['orderBy'] }
        : { orderBy?: messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages model
   */
  readonly fields: messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_types_messages_sender_type_idTouser_types<T extends user_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_typesDefaultArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user_types_messages_receiver_type_idTouser_types<T extends user_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_typesDefaultArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages model
   */ 
  interface messagesFieldRefs {
    readonly id: FieldRef<"messages", 'Bytes'>
    readonly subject: FieldRef<"messages", 'String'>
    readonly content: FieldRef<"messages", 'String'>
    readonly date_time: FieldRef<"messages", 'DateTime'>
    readonly was_read: FieldRef<"messages", 'Boolean'>
    readonly sender_id: FieldRef<"messages", 'Bytes'>
    readonly sender_type_id: FieldRef<"messages", 'Bytes'>
    readonly receiver_id: FieldRef<"messages", 'Bytes'>
    readonly receiver_type_id: FieldRef<"messages", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * messages findUnique
   */
  export type messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findUniqueOrThrow
   */
  export type messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findFirst
   */
  export type messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findFirstOrThrow
   */
  export type messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findMany
   */
  export type messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages create
   */
  export type messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a messages.
     */
    data: XOR<messagesCreateInput, messagesUncheckedCreateInput>
  }

  /**
   * messages createMany
   */
  export type messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages update
   */
  export type messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a messages.
     */
    data: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
    /**
     * Choose, which messages to update.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages updateMany
   */
  export type messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
  }

  /**
   * messages upsert
   */
  export type messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the messages to update in case it exists.
     */
    where: messagesWhereUniqueInput
    /**
     * In case the messages found by the `where` argument doesn't exist, create a new messages with this data.
     */
    create: XOR<messagesCreateInput, messagesUncheckedCreateInput>
    /**
     * In case the messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
  }

  /**
   * messages delete
   */
  export type messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter which messages to delete.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages deleteMany
   */
  export type messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messagesWhereInput
  }

  /**
   * messages without action
   */
  export type messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
  }


  /**
   * Model parents
   */

  export type AggregateParents = {
    _count: ParentsCountAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  export type ParentsMinAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
  }

  export type ParentsMaxAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
  }

  export type ParentsCountAggregateOutputType = {
    id: number
    pesel: number
    email: number
    phone_number: number
    password: number
    first_name: number
    last_name: number
    reset_password_token: number
    reset_password_expires: number
    _all: number
  }


  export type ParentsMinAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
  }

  export type ParentsMaxAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
  }

  export type ParentsCountAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
    _all?: true
  }

  export type ParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to aggregate.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parents
    **/
    _count?: true | ParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentsMaxAggregateInputType
  }

  export type GetParentsAggregateType<T extends ParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParents[P]>
      : GetScalarType<T[P], AggregateParents[P]>
  }




  export type parentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentsWhereInput
    orderBy?: parentsOrderByWithAggregationInput | parentsOrderByWithAggregationInput[]
    by: ParentsScalarFieldEnum[] | ParentsScalarFieldEnum
    having?: parentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentsCountAggregateInputType | true
    _min?: ParentsMinAggregateInputType
    _max?: ParentsMaxAggregateInputType
  }

  export type ParentsGroupByOutputType = {
    id: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token: string | null
    reset_password_expires: Date | null
    _count: ParentsCountAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  type GetParentsGroupByPayload<T extends parentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentsGroupByOutputType[P]>
            : GetScalarType<T[P], ParentsGroupByOutputType[P]>
        }
      >
    >


  export type parentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
    students_parents?: boolean | parents$students_parentsArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>



  export type parentsSelectScalar = {
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
  }

  export type parentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students_parents?: boolean | parents$students_parentsArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $parentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parents"
    objects: {
      students_parents: Prisma.$students_parentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      pesel: string
      email: string
      phone_number: string
      password: string
      first_name: string
      last_name: string
      reset_password_token: string | null
      reset_password_expires: Date | null
    }, ExtArgs["result"]["parents"]>
    composites: {}
  }

  type parentsGetPayload<S extends boolean | null | undefined | parentsDefaultArgs> = $Result.GetResult<Prisma.$parentsPayload, S>

  type parentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<parentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentsCountAggregateInputType | true
    }

  export interface parentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parents'], meta: { name: 'parents' } }
    /**
     * Find zero or one Parents that matches the filter.
     * @param {parentsFindUniqueArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parentsFindUniqueArgs>(args: SelectSubset<T, parentsFindUniqueArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parentsFindUniqueOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parentsFindUniqueOrThrowArgs>(args: SelectSubset<T, parentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parentsFindFirstArgs>(args?: SelectSubset<T, parentsFindFirstArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parentsFindFirstOrThrowArgs>(args?: SelectSubset<T, parentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parents.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentsWithIdOnly = await prisma.parents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends parentsFindManyArgs>(args?: SelectSubset<T, parentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parents.
     * @param {parentsCreateArgs} args - Arguments to create a Parents.
     * @example
     * // Create one Parents
     * const Parents = await prisma.parents.create({
     *   data: {
     *     // ... data to create a Parents
     *   }
     * })
     * 
     */
    create<T extends parentsCreateArgs>(args: SelectSubset<T, parentsCreateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parents.
     * @param {parentsCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parentsCreateManyArgs>(args?: SelectSubset<T, parentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parents.
     * @param {parentsDeleteArgs} args - Arguments to delete one Parents.
     * @example
     * // Delete one Parents
     * const Parents = await prisma.parents.delete({
     *   where: {
     *     // ... filter to delete one Parents
     *   }
     * })
     * 
     */
    delete<T extends parentsDeleteArgs>(args: SelectSubset<T, parentsDeleteArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parents.
     * @param {parentsUpdateArgs} args - Arguments to update one Parents.
     * @example
     * // Update one Parents
     * const parents = await prisma.parents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parentsUpdateArgs>(args: SelectSubset<T, parentsUpdateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parents.
     * @param {parentsDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parentsDeleteManyArgs>(args?: SelectSubset<T, parentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parentsUpdateManyArgs>(args: SelectSubset<T, parentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parents.
     * @param {parentsUpsertArgs} args - Arguments to update or create a Parents.
     * @example
     * // Update or create a Parents
     * const parents = await prisma.parents.upsert({
     *   create: {
     *     // ... data to create a Parents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parents we want to update
     *   }
     * })
     */
    upsert<T extends parentsUpsertArgs>(args: SelectSubset<T, parentsUpsertArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parents.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends parentsCountArgs>(
      args?: Subset<T, parentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentsAggregateArgs>(args: Subset<T, ParentsAggregateArgs>): Prisma.PrismaPromise<GetParentsAggregateType<T>>

    /**
     * Group by Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parentsGroupByArgs['orderBy'] }
        : { orderBy?: parentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parents model
   */
  readonly fields: parentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students_parents<T extends parents$students_parentsArgs<ExtArgs> = {}>(args?: Subset<T, parents$students_parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parents model
   */ 
  interface parentsFieldRefs {
    readonly id: FieldRef<"parents", 'Bytes'>
    readonly pesel: FieldRef<"parents", 'String'>
    readonly email: FieldRef<"parents", 'String'>
    readonly phone_number: FieldRef<"parents", 'String'>
    readonly password: FieldRef<"parents", 'String'>
    readonly first_name: FieldRef<"parents", 'String'>
    readonly last_name: FieldRef<"parents", 'String'>
    readonly reset_password_token: FieldRef<"parents", 'String'>
    readonly reset_password_expires: FieldRef<"parents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * parents findUnique
   */
  export type parentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findUniqueOrThrow
   */
  export type parentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findFirst
   */
  export type parentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findFirstOrThrow
   */
  export type parentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findMany
   */
  export type parentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents create
   */
  export type parentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The data needed to create a parents.
     */
    data: XOR<parentsCreateInput, parentsUncheckedCreateInput>
  }

  /**
   * parents createMany
   */
  export type parentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parents.
     */
    data: parentsCreateManyInput | parentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parents update
   */
  export type parentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The data needed to update a parents.
     */
    data: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
    /**
     * Choose, which parents to update.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents updateMany
   */
  export type parentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parents.
     */
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyInput>
    /**
     * Filter which parents to update
     */
    where?: parentsWhereInput
  }

  /**
   * parents upsert
   */
  export type parentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The filter to search for the parents to update in case it exists.
     */
    where: parentsWhereUniqueInput
    /**
     * In case the parents found by the `where` argument doesn't exist, create a new parents with this data.
     */
    create: XOR<parentsCreateInput, parentsUncheckedCreateInput>
    /**
     * In case the parents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
  }

  /**
   * parents delete
   */
  export type parentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter which parents to delete.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents deleteMany
   */
  export type parentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to delete
     */
    where?: parentsWhereInput
  }

  /**
   * parents.students_parents
   */
  export type parents$students_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    where?: students_parentsWhereInput
    orderBy?: students_parentsOrderByWithRelationInput | students_parentsOrderByWithRelationInput[]
    cursor?: students_parentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Students_parentsScalarFieldEnum | Students_parentsScalarFieldEnum[]
  }

  /**
   * parents without action
   */
  export type parentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
  }


  /**
   * Model problem_types
   */

  export type AggregateProblem_types = {
    _count: Problem_typesCountAggregateOutputType | null
    _min: Problem_typesMinAggregateOutputType | null
    _max: Problem_typesMaxAggregateOutputType | null
  }

  export type Problem_typesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Problem_typesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Problem_typesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Problem_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Problem_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Problem_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Problem_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problem_types to aggregate.
     */
    where?: problem_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_types to fetch.
     */
    orderBy?: problem_typesOrderByWithRelationInput | problem_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: problem_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned problem_types
    **/
    _count?: true | Problem_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Problem_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Problem_typesMaxAggregateInputType
  }

  export type GetProblem_typesAggregateType<T extends Problem_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateProblem_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblem_types[P]>
      : GetScalarType<T[P], AggregateProblem_types[P]>
  }




  export type problem_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problem_typesWhereInput
    orderBy?: problem_typesOrderByWithAggregationInput | problem_typesOrderByWithAggregationInput[]
    by: Problem_typesScalarFieldEnum[] | Problem_typesScalarFieldEnum
    having?: problem_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Problem_typesCountAggregateInputType | true
    _min?: Problem_typesMinAggregateInputType
    _max?: Problem_typesMaxAggregateInputType
  }

  export type Problem_typesGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: Problem_typesCountAggregateOutputType | null
    _min: Problem_typesMinAggregateOutputType | null
    _max: Problem_typesMaxAggregateOutputType | null
  }

  type GetProblem_typesGroupByPayload<T extends problem_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Problem_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Problem_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Problem_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Problem_typesGroupByOutputType[P]>
        }
      >
    >


  export type problem_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    problems_gradebook?: boolean | problem_types$problems_gradebookArgs<ExtArgs>
    _count?: boolean | Problem_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problem_types"]>



  export type problem_typesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type problem_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems_gradebook?: boolean | problem_types$problems_gradebookArgs<ExtArgs>
    _count?: boolean | Problem_typesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $problem_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "problem_types"
    objects: {
      problems_gradebook: Prisma.$problems_gradebookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["problem_types"]>
    composites: {}
  }

  type problem_typesGetPayload<S extends boolean | null | undefined | problem_typesDefaultArgs> = $Result.GetResult<Prisma.$problem_typesPayload, S>

  type problem_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<problem_typesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Problem_typesCountAggregateInputType | true
    }

  export interface problem_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['problem_types'], meta: { name: 'problem_types' } }
    /**
     * Find zero or one Problem_types that matches the filter.
     * @param {problem_typesFindUniqueArgs} args - Arguments to find a Problem_types
     * @example
     * // Get one Problem_types
     * const problem_types = await prisma.problem_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends problem_typesFindUniqueArgs>(args: SelectSubset<T, problem_typesFindUniqueArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Problem_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {problem_typesFindUniqueOrThrowArgs} args - Arguments to find a Problem_types
     * @example
     * // Get one Problem_types
     * const problem_types = await prisma.problem_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends problem_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, problem_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Problem_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_typesFindFirstArgs} args - Arguments to find a Problem_types
     * @example
     * // Get one Problem_types
     * const problem_types = await prisma.problem_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends problem_typesFindFirstArgs>(args?: SelectSubset<T, problem_typesFindFirstArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Problem_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_typesFindFirstOrThrowArgs} args - Arguments to find a Problem_types
     * @example
     * // Get one Problem_types
     * const problem_types = await prisma.problem_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends problem_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, problem_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Problem_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problem_types
     * const problem_types = await prisma.problem_types.findMany()
     * 
     * // Get first 10 Problem_types
     * const problem_types = await prisma.problem_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const problem_typesWithIdOnly = await prisma.problem_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends problem_typesFindManyArgs>(args?: SelectSubset<T, problem_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Problem_types.
     * @param {problem_typesCreateArgs} args - Arguments to create a Problem_types.
     * @example
     * // Create one Problem_types
     * const Problem_types = await prisma.problem_types.create({
     *   data: {
     *     // ... data to create a Problem_types
     *   }
     * })
     * 
     */
    create<T extends problem_typesCreateArgs>(args: SelectSubset<T, problem_typesCreateArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Problem_types.
     * @param {problem_typesCreateManyArgs} args - Arguments to create many Problem_types.
     * @example
     * // Create many Problem_types
     * const problem_types = await prisma.problem_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends problem_typesCreateManyArgs>(args?: SelectSubset<T, problem_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Problem_types.
     * @param {problem_typesDeleteArgs} args - Arguments to delete one Problem_types.
     * @example
     * // Delete one Problem_types
     * const Problem_types = await prisma.problem_types.delete({
     *   where: {
     *     // ... filter to delete one Problem_types
     *   }
     * })
     * 
     */
    delete<T extends problem_typesDeleteArgs>(args: SelectSubset<T, problem_typesDeleteArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Problem_types.
     * @param {problem_typesUpdateArgs} args - Arguments to update one Problem_types.
     * @example
     * // Update one Problem_types
     * const problem_types = await prisma.problem_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends problem_typesUpdateArgs>(args: SelectSubset<T, problem_typesUpdateArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Problem_types.
     * @param {problem_typesDeleteManyArgs} args - Arguments to filter Problem_types to delete.
     * @example
     * // Delete a few Problem_types
     * const { count } = await prisma.problem_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends problem_typesDeleteManyArgs>(args?: SelectSubset<T, problem_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problem_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problem_types
     * const problem_types = await prisma.problem_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends problem_typesUpdateManyArgs>(args: SelectSubset<T, problem_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problem_types.
     * @param {problem_typesUpsertArgs} args - Arguments to update or create a Problem_types.
     * @example
     * // Update or create a Problem_types
     * const problem_types = await prisma.problem_types.upsert({
     *   create: {
     *     // ... data to create a Problem_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problem_types we want to update
     *   }
     * })
     */
    upsert<T extends problem_typesUpsertArgs>(args: SelectSubset<T, problem_typesUpsertArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Problem_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_typesCountArgs} args - Arguments to filter Problem_types to count.
     * @example
     * // Count the number of Problem_types
     * const count = await prisma.problem_types.count({
     *   where: {
     *     // ... the filter for the Problem_types we want to count
     *   }
     * })
    **/
    count<T extends problem_typesCountArgs>(
      args?: Subset<T, problem_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Problem_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problem_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Problem_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Problem_typesAggregateArgs>(args: Subset<T, Problem_typesAggregateArgs>): Prisma.PrismaPromise<GetProblem_typesAggregateType<T>>

    /**
     * Group by Problem_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problem_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends problem_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: problem_typesGroupByArgs['orderBy'] }
        : { orderBy?: problem_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, problem_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblem_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the problem_types model
   */
  readonly fields: problem_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for problem_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__problem_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    problems_gradebook<T extends problem_types$problems_gradebookArgs<ExtArgs> = {}>(args?: Subset<T, problem_types$problems_gradebookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the problem_types model
   */ 
  interface problem_typesFieldRefs {
    readonly id: FieldRef<"problem_types", 'Bytes'>
    readonly name: FieldRef<"problem_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * problem_types findUnique
   */
  export type problem_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * Filter, which problem_types to fetch.
     */
    where: problem_typesWhereUniqueInput
  }

  /**
   * problem_types findUniqueOrThrow
   */
  export type problem_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * Filter, which problem_types to fetch.
     */
    where: problem_typesWhereUniqueInput
  }

  /**
   * problem_types findFirst
   */
  export type problem_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * Filter, which problem_types to fetch.
     */
    where?: problem_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_types to fetch.
     */
    orderBy?: problem_typesOrderByWithRelationInput | problem_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problem_types.
     */
    cursor?: problem_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problem_types.
     */
    distinct?: Problem_typesScalarFieldEnum | Problem_typesScalarFieldEnum[]
  }

  /**
   * problem_types findFirstOrThrow
   */
  export type problem_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * Filter, which problem_types to fetch.
     */
    where?: problem_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_types to fetch.
     */
    orderBy?: problem_typesOrderByWithRelationInput | problem_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problem_types.
     */
    cursor?: problem_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problem_types.
     */
    distinct?: Problem_typesScalarFieldEnum | Problem_typesScalarFieldEnum[]
  }

  /**
   * problem_types findMany
   */
  export type problem_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * Filter, which problem_types to fetch.
     */
    where?: problem_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problem_types to fetch.
     */
    orderBy?: problem_typesOrderByWithRelationInput | problem_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing problem_types.
     */
    cursor?: problem_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problem_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problem_types.
     */
    skip?: number
    distinct?: Problem_typesScalarFieldEnum | Problem_typesScalarFieldEnum[]
  }

  /**
   * problem_types create
   */
  export type problem_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a problem_types.
     */
    data: XOR<problem_typesCreateInput, problem_typesUncheckedCreateInput>
  }

  /**
   * problem_types createMany
   */
  export type problem_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many problem_types.
     */
    data: problem_typesCreateManyInput | problem_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * problem_types update
   */
  export type problem_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a problem_types.
     */
    data: XOR<problem_typesUpdateInput, problem_typesUncheckedUpdateInput>
    /**
     * Choose, which problem_types to update.
     */
    where: problem_typesWhereUniqueInput
  }

  /**
   * problem_types updateMany
   */
  export type problem_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update problem_types.
     */
    data: XOR<problem_typesUpdateManyMutationInput, problem_typesUncheckedUpdateManyInput>
    /**
     * Filter which problem_types to update
     */
    where?: problem_typesWhereInput
  }

  /**
   * problem_types upsert
   */
  export type problem_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the problem_types to update in case it exists.
     */
    where: problem_typesWhereUniqueInput
    /**
     * In case the problem_types found by the `where` argument doesn't exist, create a new problem_types with this data.
     */
    create: XOR<problem_typesCreateInput, problem_typesUncheckedCreateInput>
    /**
     * In case the problem_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<problem_typesUpdateInput, problem_typesUncheckedUpdateInput>
  }

  /**
   * problem_types delete
   */
  export type problem_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
    /**
     * Filter which problem_types to delete.
     */
    where: problem_typesWhereUniqueInput
  }

  /**
   * problem_types deleteMany
   */
  export type problem_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problem_types to delete
     */
    where?: problem_typesWhereInput
  }

  /**
   * problem_types.problems_gradebook
   */
  export type problem_types$problems_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    where?: problems_gradebookWhereInput
    orderBy?: problems_gradebookOrderByWithRelationInput | problems_gradebookOrderByWithRelationInput[]
    cursor?: problems_gradebookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Problems_gradebookScalarFieldEnum | Problems_gradebookScalarFieldEnum[]
  }

  /**
   * problem_types without action
   */
  export type problem_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problem_types
     */
    select?: problem_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problem_typesInclude<ExtArgs> | null
  }


  /**
   * Model problems_gradebook
   */

  export type AggregateProblems_gradebook = {
    _count: Problems_gradebookCountAggregateOutputType | null
    _min: Problems_gradebookMinAggregateOutputType | null
    _max: Problems_gradebookMaxAggregateOutputType | null
  }

  export type Problems_gradebookMinAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    reported_time: Date | null
    problem_type_id: Uint8Array | null
    reporter_id: Uint8Array | null
    user_type_id: Uint8Array | null
    status_id: Uint8Array | null
  }

  export type Problems_gradebookMaxAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    reported_time: Date | null
    problem_type_id: Uint8Array | null
    reporter_id: Uint8Array | null
    user_type_id: Uint8Array | null
    status_id: Uint8Array | null
  }

  export type Problems_gradebookCountAggregateOutputType = {
    id: number
    description: number
    reported_time: number
    problem_type_id: number
    reporter_id: number
    user_type_id: number
    status_id: number
    _all: number
  }


  export type Problems_gradebookMinAggregateInputType = {
    id?: true
    description?: true
    reported_time?: true
    problem_type_id?: true
    reporter_id?: true
    user_type_id?: true
    status_id?: true
  }

  export type Problems_gradebookMaxAggregateInputType = {
    id?: true
    description?: true
    reported_time?: true
    problem_type_id?: true
    reporter_id?: true
    user_type_id?: true
    status_id?: true
  }

  export type Problems_gradebookCountAggregateInputType = {
    id?: true
    description?: true
    reported_time?: true
    problem_type_id?: true
    reporter_id?: true
    user_type_id?: true
    status_id?: true
    _all?: true
  }

  export type Problems_gradebookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problems_gradebook to aggregate.
     */
    where?: problems_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_gradebooks to fetch.
     */
    orderBy?: problems_gradebookOrderByWithRelationInput | problems_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: problems_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_gradebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned problems_gradebooks
    **/
    _count?: true | Problems_gradebookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Problems_gradebookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Problems_gradebookMaxAggregateInputType
  }

  export type GetProblems_gradebookAggregateType<T extends Problems_gradebookAggregateArgs> = {
        [P in keyof T & keyof AggregateProblems_gradebook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblems_gradebook[P]>
      : GetScalarType<T[P], AggregateProblems_gradebook[P]>
  }




  export type problems_gradebookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: problems_gradebookWhereInput
    orderBy?: problems_gradebookOrderByWithAggregationInput | problems_gradebookOrderByWithAggregationInput[]
    by: Problems_gradebookScalarFieldEnum[] | Problems_gradebookScalarFieldEnum
    having?: problems_gradebookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Problems_gradebookCountAggregateInputType | true
    _min?: Problems_gradebookMinAggregateInputType
    _max?: Problems_gradebookMaxAggregateInputType
  }

  export type Problems_gradebookGroupByOutputType = {
    id: Uint8Array
    description: string
    reported_time: Date
    problem_type_id: Uint8Array
    reporter_id: Uint8Array
    user_type_id: Uint8Array
    status_id: Uint8Array
    _count: Problems_gradebookCountAggregateOutputType | null
    _min: Problems_gradebookMinAggregateOutputType | null
    _max: Problems_gradebookMaxAggregateOutputType | null
  }

  type GetProblems_gradebookGroupByPayload<T extends problems_gradebookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Problems_gradebookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Problems_gradebookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Problems_gradebookGroupByOutputType[P]>
            : GetScalarType<T[P], Problems_gradebookGroupByOutputType[P]>
        }
      >
    >


  export type problems_gradebookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    reported_time?: boolean
    problem_type_id?: boolean
    reporter_id?: boolean
    user_type_id?: boolean
    status_id?: boolean
    problem_types?: boolean | problem_typesDefaultArgs<ExtArgs>
    user_types?: boolean | user_typesDefaultArgs<ExtArgs>
    statuses?: boolean | statusesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problems_gradebook"]>



  export type problems_gradebookSelectScalar = {
    id?: boolean
    description?: boolean
    reported_time?: boolean
    problem_type_id?: boolean
    reporter_id?: boolean
    user_type_id?: boolean
    status_id?: boolean
  }

  export type problems_gradebookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problem_types?: boolean | problem_typesDefaultArgs<ExtArgs>
    user_types?: boolean | user_typesDefaultArgs<ExtArgs>
    statuses?: boolean | statusesDefaultArgs<ExtArgs>
  }

  export type $problems_gradebookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "problems_gradebook"
    objects: {
      problem_types: Prisma.$problem_typesPayload<ExtArgs>
      user_types: Prisma.$user_typesPayload<ExtArgs>
      statuses: Prisma.$statusesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      description: string
      reported_time: Date
      problem_type_id: Uint8Array
      reporter_id: Uint8Array
      user_type_id: Uint8Array
      status_id: Uint8Array
    }, ExtArgs["result"]["problems_gradebook"]>
    composites: {}
  }

  type problems_gradebookGetPayload<S extends boolean | null | undefined | problems_gradebookDefaultArgs> = $Result.GetResult<Prisma.$problems_gradebookPayload, S>

  type problems_gradebookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<problems_gradebookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Problems_gradebookCountAggregateInputType | true
    }

  export interface problems_gradebookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['problems_gradebook'], meta: { name: 'problems_gradebook' } }
    /**
     * Find zero or one Problems_gradebook that matches the filter.
     * @param {problems_gradebookFindUniqueArgs} args - Arguments to find a Problems_gradebook
     * @example
     * // Get one Problems_gradebook
     * const problems_gradebook = await prisma.problems_gradebook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends problems_gradebookFindUniqueArgs>(args: SelectSubset<T, problems_gradebookFindUniqueArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Problems_gradebook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {problems_gradebookFindUniqueOrThrowArgs} args - Arguments to find a Problems_gradebook
     * @example
     * // Get one Problems_gradebook
     * const problems_gradebook = await prisma.problems_gradebook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends problems_gradebookFindUniqueOrThrowArgs>(args: SelectSubset<T, problems_gradebookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Problems_gradebook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_gradebookFindFirstArgs} args - Arguments to find a Problems_gradebook
     * @example
     * // Get one Problems_gradebook
     * const problems_gradebook = await prisma.problems_gradebook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends problems_gradebookFindFirstArgs>(args?: SelectSubset<T, problems_gradebookFindFirstArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Problems_gradebook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_gradebookFindFirstOrThrowArgs} args - Arguments to find a Problems_gradebook
     * @example
     * // Get one Problems_gradebook
     * const problems_gradebook = await prisma.problems_gradebook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends problems_gradebookFindFirstOrThrowArgs>(args?: SelectSubset<T, problems_gradebookFindFirstOrThrowArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Problems_gradebooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_gradebookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problems_gradebooks
     * const problems_gradebooks = await prisma.problems_gradebook.findMany()
     * 
     * // Get first 10 Problems_gradebooks
     * const problems_gradebooks = await prisma.problems_gradebook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const problems_gradebookWithIdOnly = await prisma.problems_gradebook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends problems_gradebookFindManyArgs>(args?: SelectSubset<T, problems_gradebookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Problems_gradebook.
     * @param {problems_gradebookCreateArgs} args - Arguments to create a Problems_gradebook.
     * @example
     * // Create one Problems_gradebook
     * const Problems_gradebook = await prisma.problems_gradebook.create({
     *   data: {
     *     // ... data to create a Problems_gradebook
     *   }
     * })
     * 
     */
    create<T extends problems_gradebookCreateArgs>(args: SelectSubset<T, problems_gradebookCreateArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Problems_gradebooks.
     * @param {problems_gradebookCreateManyArgs} args - Arguments to create many Problems_gradebooks.
     * @example
     * // Create many Problems_gradebooks
     * const problems_gradebook = await prisma.problems_gradebook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends problems_gradebookCreateManyArgs>(args?: SelectSubset<T, problems_gradebookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Problems_gradebook.
     * @param {problems_gradebookDeleteArgs} args - Arguments to delete one Problems_gradebook.
     * @example
     * // Delete one Problems_gradebook
     * const Problems_gradebook = await prisma.problems_gradebook.delete({
     *   where: {
     *     // ... filter to delete one Problems_gradebook
     *   }
     * })
     * 
     */
    delete<T extends problems_gradebookDeleteArgs>(args: SelectSubset<T, problems_gradebookDeleteArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Problems_gradebook.
     * @param {problems_gradebookUpdateArgs} args - Arguments to update one Problems_gradebook.
     * @example
     * // Update one Problems_gradebook
     * const problems_gradebook = await prisma.problems_gradebook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends problems_gradebookUpdateArgs>(args: SelectSubset<T, problems_gradebookUpdateArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Problems_gradebooks.
     * @param {problems_gradebookDeleteManyArgs} args - Arguments to filter Problems_gradebooks to delete.
     * @example
     * // Delete a few Problems_gradebooks
     * const { count } = await prisma.problems_gradebook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends problems_gradebookDeleteManyArgs>(args?: SelectSubset<T, problems_gradebookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problems_gradebooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_gradebookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problems_gradebooks
     * const problems_gradebook = await prisma.problems_gradebook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends problems_gradebookUpdateManyArgs>(args: SelectSubset<T, problems_gradebookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problems_gradebook.
     * @param {problems_gradebookUpsertArgs} args - Arguments to update or create a Problems_gradebook.
     * @example
     * // Update or create a Problems_gradebook
     * const problems_gradebook = await prisma.problems_gradebook.upsert({
     *   create: {
     *     // ... data to create a Problems_gradebook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problems_gradebook we want to update
     *   }
     * })
     */
    upsert<T extends problems_gradebookUpsertArgs>(args: SelectSubset<T, problems_gradebookUpsertArgs<ExtArgs>>): Prisma__problems_gradebookClient<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Problems_gradebooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_gradebookCountArgs} args - Arguments to filter Problems_gradebooks to count.
     * @example
     * // Count the number of Problems_gradebooks
     * const count = await prisma.problems_gradebook.count({
     *   where: {
     *     // ... the filter for the Problems_gradebooks we want to count
     *   }
     * })
    **/
    count<T extends problems_gradebookCountArgs>(
      args?: Subset<T, problems_gradebookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Problems_gradebookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problems_gradebook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Problems_gradebookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Problems_gradebookAggregateArgs>(args: Subset<T, Problems_gradebookAggregateArgs>): Prisma.PrismaPromise<GetProblems_gradebookAggregateType<T>>

    /**
     * Group by Problems_gradebook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {problems_gradebookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends problems_gradebookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: problems_gradebookGroupByArgs['orderBy'] }
        : { orderBy?: problems_gradebookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, problems_gradebookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblems_gradebookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the problems_gradebook model
   */
  readonly fields: problems_gradebookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for problems_gradebook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__problems_gradebookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    problem_types<T extends problem_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, problem_typesDefaultArgs<ExtArgs>>): Prisma__problem_typesClient<$Result.GetResult<Prisma.$problem_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user_types<T extends user_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_typesDefaultArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    statuses<T extends statusesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statusesDefaultArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the problems_gradebook model
   */ 
  interface problems_gradebookFieldRefs {
    readonly id: FieldRef<"problems_gradebook", 'Bytes'>
    readonly description: FieldRef<"problems_gradebook", 'String'>
    readonly reported_time: FieldRef<"problems_gradebook", 'DateTime'>
    readonly problem_type_id: FieldRef<"problems_gradebook", 'Bytes'>
    readonly reporter_id: FieldRef<"problems_gradebook", 'Bytes'>
    readonly user_type_id: FieldRef<"problems_gradebook", 'Bytes'>
    readonly status_id: FieldRef<"problems_gradebook", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * problems_gradebook findUnique
   */
  export type problems_gradebookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which problems_gradebook to fetch.
     */
    where: problems_gradebookWhereUniqueInput
  }

  /**
   * problems_gradebook findUniqueOrThrow
   */
  export type problems_gradebookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which problems_gradebook to fetch.
     */
    where: problems_gradebookWhereUniqueInput
  }

  /**
   * problems_gradebook findFirst
   */
  export type problems_gradebookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which problems_gradebook to fetch.
     */
    where?: problems_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_gradebooks to fetch.
     */
    orderBy?: problems_gradebookOrderByWithRelationInput | problems_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problems_gradebooks.
     */
    cursor?: problems_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_gradebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problems_gradebooks.
     */
    distinct?: Problems_gradebookScalarFieldEnum | Problems_gradebookScalarFieldEnum[]
  }

  /**
   * problems_gradebook findFirstOrThrow
   */
  export type problems_gradebookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which problems_gradebook to fetch.
     */
    where?: problems_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_gradebooks to fetch.
     */
    orderBy?: problems_gradebookOrderByWithRelationInput | problems_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for problems_gradebooks.
     */
    cursor?: problems_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_gradebooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of problems_gradebooks.
     */
    distinct?: Problems_gradebookScalarFieldEnum | Problems_gradebookScalarFieldEnum[]
  }

  /**
   * problems_gradebook findMany
   */
  export type problems_gradebookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * Filter, which problems_gradebooks to fetch.
     */
    where?: problems_gradebookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of problems_gradebooks to fetch.
     */
    orderBy?: problems_gradebookOrderByWithRelationInput | problems_gradebookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing problems_gradebooks.
     */
    cursor?: problems_gradebookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` problems_gradebooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` problems_gradebooks.
     */
    skip?: number
    distinct?: Problems_gradebookScalarFieldEnum | Problems_gradebookScalarFieldEnum[]
  }

  /**
   * problems_gradebook create
   */
  export type problems_gradebookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * The data needed to create a problems_gradebook.
     */
    data: XOR<problems_gradebookCreateInput, problems_gradebookUncheckedCreateInput>
  }

  /**
   * problems_gradebook createMany
   */
  export type problems_gradebookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many problems_gradebooks.
     */
    data: problems_gradebookCreateManyInput | problems_gradebookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * problems_gradebook update
   */
  export type problems_gradebookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * The data needed to update a problems_gradebook.
     */
    data: XOR<problems_gradebookUpdateInput, problems_gradebookUncheckedUpdateInput>
    /**
     * Choose, which problems_gradebook to update.
     */
    where: problems_gradebookWhereUniqueInput
  }

  /**
   * problems_gradebook updateMany
   */
  export type problems_gradebookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update problems_gradebooks.
     */
    data: XOR<problems_gradebookUpdateManyMutationInput, problems_gradebookUncheckedUpdateManyInput>
    /**
     * Filter which problems_gradebooks to update
     */
    where?: problems_gradebookWhereInput
  }

  /**
   * problems_gradebook upsert
   */
  export type problems_gradebookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * The filter to search for the problems_gradebook to update in case it exists.
     */
    where: problems_gradebookWhereUniqueInput
    /**
     * In case the problems_gradebook found by the `where` argument doesn't exist, create a new problems_gradebook with this data.
     */
    create: XOR<problems_gradebookCreateInput, problems_gradebookUncheckedCreateInput>
    /**
     * In case the problems_gradebook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<problems_gradebookUpdateInput, problems_gradebookUncheckedUpdateInput>
  }

  /**
   * problems_gradebook delete
   */
  export type problems_gradebookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    /**
     * Filter which problems_gradebook to delete.
     */
    where: problems_gradebookWhereUniqueInput
  }

  /**
   * problems_gradebook deleteMany
   */
  export type problems_gradebookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which problems_gradebooks to delete
     */
    where?: problems_gradebookWhereInput
  }

  /**
   * problems_gradebook without action
   */
  export type problems_gradebookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
  }


  /**
   * Model school_events
   */

  export type AggregateSchool_events = {
    _count: School_eventsCountAggregateOutputType | null
    _min: School_eventsMinAggregateOutputType | null
    _max: School_eventsMaxAggregateOutputType | null
  }

  export type School_eventsMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    location: string | null
    description: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    event_type_id: Uint8Array | null
  }

  export type School_eventsMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    location: string | null
    description: string | null
    date: Date | null
    start_time: Date | null
    end_time: Date | null
    event_type_id: Uint8Array | null
  }

  export type School_eventsCountAggregateOutputType = {
    id: number
    name: number
    location: number
    description: number
    date: number
    start_time: number
    end_time: number
    event_type_id: number
    _all: number
  }


  export type School_eventsMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    description?: true
    date?: true
    start_time?: true
    end_time?: true
    event_type_id?: true
  }

  export type School_eventsMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    description?: true
    date?: true
    start_time?: true
    end_time?: true
    event_type_id?: true
  }

  export type School_eventsCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    description?: true
    date?: true
    start_time?: true
    end_time?: true
    event_type_id?: true
    _all?: true
  }

  export type School_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_events to aggregate.
     */
    where?: school_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_events to fetch.
     */
    orderBy?: school_eventsOrderByWithRelationInput | school_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: school_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned school_events
    **/
    _count?: true | School_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: School_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: School_eventsMaxAggregateInputType
  }

  export type GetSchool_eventsAggregateType<T extends School_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool_events[P]>
      : GetScalarType<T[P], AggregateSchool_events[P]>
  }




  export type school_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_eventsWhereInput
    orderBy?: school_eventsOrderByWithAggregationInput | school_eventsOrderByWithAggregationInput[]
    by: School_eventsScalarFieldEnum[] | School_eventsScalarFieldEnum
    having?: school_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: School_eventsCountAggregateInputType | true
    _min?: School_eventsMinAggregateInputType
    _max?: School_eventsMaxAggregateInputType
  }

  export type School_eventsGroupByOutputType = {
    id: Uint8Array
    name: string
    location: string
    description: string
    date: Date
    start_time: Date
    end_time: Date
    event_type_id: Uint8Array
    _count: School_eventsCountAggregateOutputType | null
    _min: School_eventsMinAggregateOutputType | null
    _max: School_eventsMaxAggregateOutputType | null
  }

  type GetSchool_eventsGroupByPayload<T extends school_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<School_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof School_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], School_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], School_eventsGroupByOutputType[P]>
        }
      >
    >


  export type school_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    description?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    event_type_id?: boolean
    event_types?: boolean | event_typesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school_events"]>



  export type school_eventsSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    description?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    event_type_id?: boolean
  }

  export type school_eventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event_types?: boolean | event_typesDefaultArgs<ExtArgs>
  }

  export type $school_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "school_events"
    objects: {
      event_types: Prisma.$event_typesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
      location: string
      description: string
      date: Date
      start_time: Date
      end_time: Date
      event_type_id: Uint8Array
    }, ExtArgs["result"]["school_events"]>
    composites: {}
  }

  type school_eventsGetPayload<S extends boolean | null | undefined | school_eventsDefaultArgs> = $Result.GetResult<Prisma.$school_eventsPayload, S>

  type school_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<school_eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: School_eventsCountAggregateInputType | true
    }

  export interface school_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['school_events'], meta: { name: 'school_events' } }
    /**
     * Find zero or one School_events that matches the filter.
     * @param {school_eventsFindUniqueArgs} args - Arguments to find a School_events
     * @example
     * // Get one School_events
     * const school_events = await prisma.school_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends school_eventsFindUniqueArgs>(args: SelectSubset<T, school_eventsFindUniqueArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one School_events that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {school_eventsFindUniqueOrThrowArgs} args - Arguments to find a School_events
     * @example
     * // Get one School_events
     * const school_events = await prisma.school_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends school_eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, school_eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first School_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_eventsFindFirstArgs} args - Arguments to find a School_events
     * @example
     * // Get one School_events
     * const school_events = await prisma.school_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends school_eventsFindFirstArgs>(args?: SelectSubset<T, school_eventsFindFirstArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first School_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_eventsFindFirstOrThrowArgs} args - Arguments to find a School_events
     * @example
     * // Get one School_events
     * const school_events = await prisma.school_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends school_eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, school_eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more School_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all School_events
     * const school_events = await prisma.school_events.findMany()
     * 
     * // Get first 10 School_events
     * const school_events = await prisma.school_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const school_eventsWithIdOnly = await prisma.school_events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends school_eventsFindManyArgs>(args?: SelectSubset<T, school_eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a School_events.
     * @param {school_eventsCreateArgs} args - Arguments to create a School_events.
     * @example
     * // Create one School_events
     * const School_events = await prisma.school_events.create({
     *   data: {
     *     // ... data to create a School_events
     *   }
     * })
     * 
     */
    create<T extends school_eventsCreateArgs>(args: SelectSubset<T, school_eventsCreateArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many School_events.
     * @param {school_eventsCreateManyArgs} args - Arguments to create many School_events.
     * @example
     * // Create many School_events
     * const school_events = await prisma.school_events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends school_eventsCreateManyArgs>(args?: SelectSubset<T, school_eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School_events.
     * @param {school_eventsDeleteArgs} args - Arguments to delete one School_events.
     * @example
     * // Delete one School_events
     * const School_events = await prisma.school_events.delete({
     *   where: {
     *     // ... filter to delete one School_events
     *   }
     * })
     * 
     */
    delete<T extends school_eventsDeleteArgs>(args: SelectSubset<T, school_eventsDeleteArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one School_events.
     * @param {school_eventsUpdateArgs} args - Arguments to update one School_events.
     * @example
     * // Update one School_events
     * const school_events = await prisma.school_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends school_eventsUpdateArgs>(args: SelectSubset<T, school_eventsUpdateArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more School_events.
     * @param {school_eventsDeleteManyArgs} args - Arguments to filter School_events to delete.
     * @example
     * // Delete a few School_events
     * const { count } = await prisma.school_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends school_eventsDeleteManyArgs>(args?: SelectSubset<T, school_eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more School_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many School_events
     * const school_events = await prisma.school_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends school_eventsUpdateManyArgs>(args: SelectSubset<T, school_eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School_events.
     * @param {school_eventsUpsertArgs} args - Arguments to update or create a School_events.
     * @example
     * // Update or create a School_events
     * const school_events = await prisma.school_events.upsert({
     *   create: {
     *     // ... data to create a School_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School_events we want to update
     *   }
     * })
     */
    upsert<T extends school_eventsUpsertArgs>(args: SelectSubset<T, school_eventsUpsertArgs<ExtArgs>>): Prisma__school_eventsClient<$Result.GetResult<Prisma.$school_eventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of School_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_eventsCountArgs} args - Arguments to filter School_events to count.
     * @example
     * // Count the number of School_events
     * const count = await prisma.school_events.count({
     *   where: {
     *     // ... the filter for the School_events we want to count
     *   }
     * })
    **/
    count<T extends school_eventsCountArgs>(
      args?: Subset<T, school_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], School_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {School_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends School_eventsAggregateArgs>(args: Subset<T, School_eventsAggregateArgs>): Prisma.PrismaPromise<GetSchool_eventsAggregateType<T>>

    /**
     * Group by School_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends school_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: school_eventsGroupByArgs['orderBy'] }
        : { orderBy?: school_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, school_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchool_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the school_events model
   */
  readonly fields: school_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for school_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__school_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event_types<T extends event_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, event_typesDefaultArgs<ExtArgs>>): Prisma__event_typesClient<$Result.GetResult<Prisma.$event_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the school_events model
   */ 
  interface school_eventsFieldRefs {
    readonly id: FieldRef<"school_events", 'Bytes'>
    readonly name: FieldRef<"school_events", 'String'>
    readonly location: FieldRef<"school_events", 'String'>
    readonly description: FieldRef<"school_events", 'String'>
    readonly date: FieldRef<"school_events", 'DateTime'>
    readonly start_time: FieldRef<"school_events", 'DateTime'>
    readonly end_time: FieldRef<"school_events", 'DateTime'>
    readonly event_type_id: FieldRef<"school_events", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * school_events findUnique
   */
  export type school_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * Filter, which school_events to fetch.
     */
    where: school_eventsWhereUniqueInput
  }

  /**
   * school_events findUniqueOrThrow
   */
  export type school_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * Filter, which school_events to fetch.
     */
    where: school_eventsWhereUniqueInput
  }

  /**
   * school_events findFirst
   */
  export type school_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * Filter, which school_events to fetch.
     */
    where?: school_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_events to fetch.
     */
    orderBy?: school_eventsOrderByWithRelationInput | school_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_events.
     */
    cursor?: school_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_events.
     */
    distinct?: School_eventsScalarFieldEnum | School_eventsScalarFieldEnum[]
  }

  /**
   * school_events findFirstOrThrow
   */
  export type school_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * Filter, which school_events to fetch.
     */
    where?: school_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_events to fetch.
     */
    orderBy?: school_eventsOrderByWithRelationInput | school_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_events.
     */
    cursor?: school_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_events.
     */
    distinct?: School_eventsScalarFieldEnum | School_eventsScalarFieldEnum[]
  }

  /**
   * school_events findMany
   */
  export type school_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * Filter, which school_events to fetch.
     */
    where?: school_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_events to fetch.
     */
    orderBy?: school_eventsOrderByWithRelationInput | school_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing school_events.
     */
    cursor?: school_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_events.
     */
    skip?: number
    distinct?: School_eventsScalarFieldEnum | School_eventsScalarFieldEnum[]
  }

  /**
   * school_events create
   */
  export type school_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * The data needed to create a school_events.
     */
    data: XOR<school_eventsCreateInput, school_eventsUncheckedCreateInput>
  }

  /**
   * school_events createMany
   */
  export type school_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many school_events.
     */
    data: school_eventsCreateManyInput | school_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * school_events update
   */
  export type school_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * The data needed to update a school_events.
     */
    data: XOR<school_eventsUpdateInput, school_eventsUncheckedUpdateInput>
    /**
     * Choose, which school_events to update.
     */
    where: school_eventsWhereUniqueInput
  }

  /**
   * school_events updateMany
   */
  export type school_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update school_events.
     */
    data: XOR<school_eventsUpdateManyMutationInput, school_eventsUncheckedUpdateManyInput>
    /**
     * Filter which school_events to update
     */
    where?: school_eventsWhereInput
  }

  /**
   * school_events upsert
   */
  export type school_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * The filter to search for the school_events to update in case it exists.
     */
    where: school_eventsWhereUniqueInput
    /**
     * In case the school_events found by the `where` argument doesn't exist, create a new school_events with this data.
     */
    create: XOR<school_eventsCreateInput, school_eventsUncheckedCreateInput>
    /**
     * In case the school_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<school_eventsUpdateInput, school_eventsUncheckedUpdateInput>
  }

  /**
   * school_events delete
   */
  export type school_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
    /**
     * Filter which school_events to delete.
     */
    where: school_eventsWhereUniqueInput
  }

  /**
   * school_events deleteMany
   */
  export type school_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_events to delete
     */
    where?: school_eventsWhereInput
  }

  /**
   * school_events without action
   */
  export type school_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_events
     */
    select?: school_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_eventsInclude<ExtArgs> | null
  }


  /**
   * Model statuses
   */

  export type AggregateStatuses = {
    _count: StatusesCountAggregateOutputType | null
    _min: StatusesMinAggregateOutputType | null
    _max: StatusesMaxAggregateOutputType | null
  }

  export type StatusesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type StatusesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type StatusesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type StatusesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type StatusesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type StatusesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type StatusesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statuses to aggregate.
     */
    where?: statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusesOrderByWithRelationInput | statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statuses
    **/
    _count?: true | StatusesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusesMaxAggregateInputType
  }

  export type GetStatusesAggregateType<T extends StatusesAggregateArgs> = {
        [P in keyof T & keyof AggregateStatuses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatuses[P]>
      : GetScalarType<T[P], AggregateStatuses[P]>
  }




  export type statusesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statusesWhereInput
    orderBy?: statusesOrderByWithAggregationInput | statusesOrderByWithAggregationInput[]
    by: StatusesScalarFieldEnum[] | StatusesScalarFieldEnum
    having?: statusesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusesCountAggregateInputType | true
    _min?: StatusesMinAggregateInputType
    _max?: StatusesMaxAggregateInputType
  }

  export type StatusesGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: StatusesCountAggregateOutputType | null
    _min: StatusesMinAggregateOutputType | null
    _max: StatusesMaxAggregateOutputType | null
  }

  type GetStatusesGroupByPayload<T extends statusesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusesGroupByOutputType[P]>
            : GetScalarType<T[P], StatusesGroupByOutputType[P]>
        }
      >
    >


  export type statusesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    problems_gradebook?: boolean | statuses$problems_gradebookArgs<ExtArgs>
    _count?: boolean | StatusesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statuses"]>



  export type statusesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type statusesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems_gradebook?: boolean | statuses$problems_gradebookArgs<ExtArgs>
    _count?: boolean | StatusesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $statusesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "statuses"
    objects: {
      problems_gradebook: Prisma.$problems_gradebookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["statuses"]>
    composites: {}
  }

  type statusesGetPayload<S extends boolean | null | undefined | statusesDefaultArgs> = $Result.GetResult<Prisma.$statusesPayload, S>

  type statusesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statusesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatusesCountAggregateInputType | true
    }

  export interface statusesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statuses'], meta: { name: 'statuses' } }
    /**
     * Find zero or one Statuses that matches the filter.
     * @param {statusesFindUniqueArgs} args - Arguments to find a Statuses
     * @example
     * // Get one Statuses
     * const statuses = await prisma.statuses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statusesFindUniqueArgs>(args: SelectSubset<T, statusesFindUniqueArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Statuses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statusesFindUniqueOrThrowArgs} args - Arguments to find a Statuses
     * @example
     * // Get one Statuses
     * const statuses = await prisma.statuses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statusesFindUniqueOrThrowArgs>(args: SelectSubset<T, statusesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusesFindFirstArgs} args - Arguments to find a Statuses
     * @example
     * // Get one Statuses
     * const statuses = await prisma.statuses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statusesFindFirstArgs>(args?: SelectSubset<T, statusesFindFirstArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Statuses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusesFindFirstOrThrowArgs} args - Arguments to find a Statuses
     * @example
     * // Get one Statuses
     * const statuses = await prisma.statuses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statusesFindFirstOrThrowArgs>(args?: SelectSubset<T, statusesFindFirstOrThrowArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statuses
     * const statuses = await prisma.statuses.findMany()
     * 
     * // Get first 10 Statuses
     * const statuses = await prisma.statuses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusesWithIdOnly = await prisma.statuses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statusesFindManyArgs>(args?: SelectSubset<T, statusesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Statuses.
     * @param {statusesCreateArgs} args - Arguments to create a Statuses.
     * @example
     * // Create one Statuses
     * const Statuses = await prisma.statuses.create({
     *   data: {
     *     // ... data to create a Statuses
     *   }
     * })
     * 
     */
    create<T extends statusesCreateArgs>(args: SelectSubset<T, statusesCreateArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Statuses.
     * @param {statusesCreateManyArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const statuses = await prisma.statuses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statusesCreateManyArgs>(args?: SelectSubset<T, statusesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Statuses.
     * @param {statusesDeleteArgs} args - Arguments to delete one Statuses.
     * @example
     * // Delete one Statuses
     * const Statuses = await prisma.statuses.delete({
     *   where: {
     *     // ... filter to delete one Statuses
     *   }
     * })
     * 
     */
    delete<T extends statusesDeleteArgs>(args: SelectSubset<T, statusesDeleteArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Statuses.
     * @param {statusesUpdateArgs} args - Arguments to update one Statuses.
     * @example
     * // Update one Statuses
     * const statuses = await prisma.statuses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statusesUpdateArgs>(args: SelectSubset<T, statusesUpdateArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Statuses.
     * @param {statusesDeleteManyArgs} args - Arguments to filter Statuses to delete.
     * @example
     * // Delete a few Statuses
     * const { count } = await prisma.statuses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statusesDeleteManyArgs>(args?: SelectSubset<T, statusesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statuses
     * const statuses = await prisma.statuses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statusesUpdateManyArgs>(args: SelectSubset<T, statusesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Statuses.
     * @param {statusesUpsertArgs} args - Arguments to update or create a Statuses.
     * @example
     * // Update or create a Statuses
     * const statuses = await prisma.statuses.upsert({
     *   create: {
     *     // ... data to create a Statuses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statuses we want to update
     *   }
     * })
     */
    upsert<T extends statusesUpsertArgs>(args: SelectSubset<T, statusesUpsertArgs<ExtArgs>>): Prisma__statusesClient<$Result.GetResult<Prisma.$statusesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusesCountArgs} args - Arguments to filter Statuses to count.
     * @example
     * // Count the number of Statuses
     * const count = await prisma.statuses.count({
     *   where: {
     *     // ... the filter for the Statuses we want to count
     *   }
     * })
    **/
    count<T extends statusesCountArgs>(
      args?: Subset<T, statusesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusesAggregateArgs>(args: Subset<T, StatusesAggregateArgs>): Prisma.PrismaPromise<GetStatusesAggregateType<T>>

    /**
     * Group by Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statusesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statusesGroupByArgs['orderBy'] }
        : { orderBy?: statusesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statusesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statuses model
   */
  readonly fields: statusesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statuses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statusesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    problems_gradebook<T extends statuses$problems_gradebookArgs<ExtArgs> = {}>(args?: Subset<T, statuses$problems_gradebookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the statuses model
   */ 
  interface statusesFieldRefs {
    readonly id: FieldRef<"statuses", 'Bytes'>
    readonly name: FieldRef<"statuses", 'String'>
  }
    

  // Custom InputTypes
  /**
   * statuses findUnique
   */
  export type statusesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * Filter, which statuses to fetch.
     */
    where: statusesWhereUniqueInput
  }

  /**
   * statuses findUniqueOrThrow
   */
  export type statusesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * Filter, which statuses to fetch.
     */
    where: statusesWhereUniqueInput
  }

  /**
   * statuses findFirst
   */
  export type statusesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * Filter, which statuses to fetch.
     */
    where?: statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusesOrderByWithRelationInput | statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statuses.
     */
    cursor?: statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusesScalarFieldEnum | StatusesScalarFieldEnum[]
  }

  /**
   * statuses findFirstOrThrow
   */
  export type statusesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * Filter, which statuses to fetch.
     */
    where?: statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusesOrderByWithRelationInput | statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statuses.
     */
    cursor?: statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusesScalarFieldEnum | StatusesScalarFieldEnum[]
  }

  /**
   * statuses findMany
   */
  export type statusesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * Filter, which statuses to fetch.
     */
    where?: statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusesOrderByWithRelationInput | statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statuses.
     */
    cursor?: statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statuses.
     */
    skip?: number
    distinct?: StatusesScalarFieldEnum | StatusesScalarFieldEnum[]
  }

  /**
   * statuses create
   */
  export type statusesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * The data needed to create a statuses.
     */
    data: XOR<statusesCreateInput, statusesUncheckedCreateInput>
  }

  /**
   * statuses createMany
   */
  export type statusesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statuses.
     */
    data: statusesCreateManyInput | statusesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statuses update
   */
  export type statusesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * The data needed to update a statuses.
     */
    data: XOR<statusesUpdateInput, statusesUncheckedUpdateInput>
    /**
     * Choose, which statuses to update.
     */
    where: statusesWhereUniqueInput
  }

  /**
   * statuses updateMany
   */
  export type statusesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statuses.
     */
    data: XOR<statusesUpdateManyMutationInput, statusesUncheckedUpdateManyInput>
    /**
     * Filter which statuses to update
     */
    where?: statusesWhereInput
  }

  /**
   * statuses upsert
   */
  export type statusesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * The filter to search for the statuses to update in case it exists.
     */
    where: statusesWhereUniqueInput
    /**
     * In case the statuses found by the `where` argument doesn't exist, create a new statuses with this data.
     */
    create: XOR<statusesCreateInput, statusesUncheckedCreateInput>
    /**
     * In case the statuses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statusesUpdateInput, statusesUncheckedUpdateInput>
  }

  /**
   * statuses delete
   */
  export type statusesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
    /**
     * Filter which statuses to delete.
     */
    where: statusesWhereUniqueInput
  }

  /**
   * statuses deleteMany
   */
  export type statusesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statuses to delete
     */
    where?: statusesWhereInput
  }

  /**
   * statuses.problems_gradebook
   */
  export type statuses$problems_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    where?: problems_gradebookWhereInput
    orderBy?: problems_gradebookOrderByWithRelationInput | problems_gradebookOrderByWithRelationInput[]
    cursor?: problems_gradebookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Problems_gradebookScalarFieldEnum | Problems_gradebookScalarFieldEnum[]
  }

  /**
   * statuses without action
   */
  export type statusesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statuses
     */
    select?: statusesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusesInclude<ExtArgs> | null
  }


  /**
   * Model students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsMinAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
    class_id: Uint8Array | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
    class_id: Uint8Array | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    pesel: number
    email: number
    phone_number: number
    password: number
    first_name: number
    last_name: number
    reset_password_token: number
    reset_password_expires: number
    class_id: number
    _all: number
  }


  export type StudentsMinAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
    class_id?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
    class_id?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
    class_id?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to aggregate.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type studentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithAggregationInput | studentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: studentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    id: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token: string | null
    reset_password_expires: Date | null
    class_id: Uint8Array | null
    _count: StudentsCountAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends studentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type studentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
    class_id?: boolean
    attempts?: boolean | students$attemptsArgs<ExtArgs>
    attendances?: boolean | students$attendancesArgs<ExtArgs>
    badges_history?: boolean | students$badges_historyArgs<ExtArgs>
    final_grades?: boolean | students$final_gradesArgs<ExtArgs>
    grades_exams?: boolean | students$grades_examsArgs<ExtArgs>
    grades_gradebook?: boolean | students$grades_gradebookArgs<ExtArgs>
    notifications?: boolean | students$notificationsArgs<ExtArgs>
    questions_responses?: boolean | students$questions_responsesArgs<ExtArgs>
    student_closed_answers?: boolean | students$student_closed_answersArgs<ExtArgs>
    student_open_answers?: boolean | students$student_open_answersArgs<ExtArgs>
    classes?: boolean | students$classesArgs<ExtArgs>
    students_exams?: boolean | students$students_examsArgs<ExtArgs>
    students_parents?: boolean | students$students_parentsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>



  export type studentsSelectScalar = {
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
    class_id?: boolean
  }

  export type studentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | students$attemptsArgs<ExtArgs>
    attendances?: boolean | students$attendancesArgs<ExtArgs>
    badges_history?: boolean | students$badges_historyArgs<ExtArgs>
    final_grades?: boolean | students$final_gradesArgs<ExtArgs>
    grades_exams?: boolean | students$grades_examsArgs<ExtArgs>
    grades_gradebook?: boolean | students$grades_gradebookArgs<ExtArgs>
    notifications?: boolean | students$notificationsArgs<ExtArgs>
    questions_responses?: boolean | students$questions_responsesArgs<ExtArgs>
    student_closed_answers?: boolean | students$student_closed_answersArgs<ExtArgs>
    student_open_answers?: boolean | students$student_open_answersArgs<ExtArgs>
    classes?: boolean | students$classesArgs<ExtArgs>
    students_exams?: boolean | students$students_examsArgs<ExtArgs>
    students_parents?: boolean | students$students_parentsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $studentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students"
    objects: {
      attempts: Prisma.$attemptsPayload<ExtArgs>[]
      attendances: Prisma.$attendancesPayload<ExtArgs>[]
      badges_history: Prisma.$badges_historyPayload<ExtArgs>[]
      final_grades: Prisma.$final_gradesPayload<ExtArgs>[]
      grades_exams: Prisma.$grades_examsPayload<ExtArgs>[]
      grades_gradebook: Prisma.$grades_gradebookPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      questions_responses: Prisma.$questions_responsesPayload<ExtArgs>[]
      student_closed_answers: Prisma.$student_closed_answersPayload<ExtArgs>[]
      student_open_answers: Prisma.$student_open_answersPayload<ExtArgs>[]
      classes: Prisma.$classesPayload<ExtArgs> | null
      students_exams: Prisma.$students_examsPayload<ExtArgs>[]
      students_parents: Prisma.$students_parentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      pesel: string
      email: string
      phone_number: string
      password: string
      first_name: string
      last_name: string
      reset_password_token: string | null
      reset_password_expires: Date | null
      class_id: Uint8Array | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type studentsGetPayload<S extends boolean | null | undefined | studentsDefaultArgs> = $Result.GetResult<Prisma.$studentsPayload, S>

  type studentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface studentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students'], meta: { name: 'students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {studentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentsFindUniqueArgs>(args: SelectSubset<T, studentsFindUniqueArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentsFindUniqueOrThrowArgs>(args: SelectSubset<T, studentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentsFindFirstArgs>(args?: SelectSubset<T, studentsFindFirstArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentsFindFirstOrThrowArgs>(args?: SelectSubset<T, studentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends studentsFindManyArgs>(args?: SelectSubset<T, studentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Students.
     * @param {studentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends studentsCreateArgs>(args: SelectSubset<T, studentsCreateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {studentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentsCreateManyArgs>(args?: SelectSubset<T, studentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Students.
     * @param {studentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends studentsDeleteArgs>(args: SelectSubset<T, studentsDeleteArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Students.
     * @param {studentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentsUpdateArgs>(args: SelectSubset<T, studentsUpdateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {studentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentsDeleteManyArgs>(args?: SelectSubset<T, studentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentsUpdateManyArgs>(args: SelectSubset<T, studentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Students.
     * @param {studentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends studentsUpsertArgs>(args: SelectSubset<T, studentsUpsertArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentsCountArgs>(
      args?: Subset<T, studentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentsGroupByArgs['orderBy'] }
        : { orderBy?: studentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students model
   */
  readonly fields: studentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempts<T extends students$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, students$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findMany"> | Null>
    attendances<T extends students$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, students$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesPayload<ExtArgs>, T, "findMany"> | Null>
    badges_history<T extends students$badges_historyArgs<ExtArgs> = {}>(args?: Subset<T, students$badges_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badges_historyPayload<ExtArgs>, T, "findMany"> | Null>
    final_grades<T extends students$final_gradesArgs<ExtArgs> = {}>(args?: Subset<T, students$final_gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findMany"> | Null>
    grades_exams<T extends students$grades_examsArgs<ExtArgs> = {}>(args?: Subset<T, students$grades_examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "findMany"> | Null>
    grades_gradebook<T extends students$grades_gradebookArgs<ExtArgs> = {}>(args?: Subset<T, students$grades_gradebookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends students$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, students$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    questions_responses<T extends students$questions_responsesArgs<ExtArgs> = {}>(args?: Subset<T, students$questions_responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "findMany"> | Null>
    student_closed_answers<T extends students$student_closed_answersArgs<ExtArgs> = {}>(args?: Subset<T, students$student_closed_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findMany"> | Null>
    student_open_answers<T extends students$student_open_answersArgs<ExtArgs> = {}>(args?: Subset<T, students$student_open_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends students$classesArgs<ExtArgs> = {}>(args?: Subset<T, students$classesArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    students_exams<T extends students$students_examsArgs<ExtArgs> = {}>(args?: Subset<T, students$students_examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "findMany"> | Null>
    students_parents<T extends students$students_parentsArgs<ExtArgs> = {}>(args?: Subset<T, students$students_parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students model
   */ 
  interface studentsFieldRefs {
    readonly id: FieldRef<"students", 'Bytes'>
    readonly pesel: FieldRef<"students", 'String'>
    readonly email: FieldRef<"students", 'String'>
    readonly phone_number: FieldRef<"students", 'String'>
    readonly password: FieldRef<"students", 'String'>
    readonly first_name: FieldRef<"students", 'String'>
    readonly last_name: FieldRef<"students", 'String'>
    readonly reset_password_token: FieldRef<"students", 'String'>
    readonly reset_password_expires: FieldRef<"students", 'DateTime'>
    readonly class_id: FieldRef<"students", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * students findUnique
   */
  export type studentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findUniqueOrThrow
   */
  export type studentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findFirst
   */
  export type studentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findFirstOrThrow
   */
  export type studentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findMany
   */
  export type studentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students create
   */
  export type studentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to create a students.
     */
    data: XOR<studentsCreateInput, studentsUncheckedCreateInput>
  }

  /**
   * students createMany
   */
  export type studentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students update
   */
  export type studentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to update a students.
     */
    data: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
    /**
     * Choose, which students to update.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students updateMany
   */
  export type studentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
  }

  /**
   * students upsert
   */
  export type studentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The filter to search for the students to update in case it exists.
     */
    where: studentsWhereUniqueInput
    /**
     * In case the students found by the `where` argument doesn't exist, create a new students with this data.
     */
    create: XOR<studentsCreateInput, studentsUncheckedCreateInput>
    /**
     * In case the students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
  }

  /**
   * students delete
   */
  export type studentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter which students to delete.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students deleteMany
   */
  export type studentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentsWhereInput
  }

  /**
   * students.attempts
   */
  export type students$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    where?: attemptsWhereInput
    orderBy?: attemptsOrderByWithRelationInput | attemptsOrderByWithRelationInput[]
    cursor?: attemptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttemptsScalarFieldEnum | AttemptsScalarFieldEnum[]
  }

  /**
   * students.attendances
   */
  export type students$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendances
     */
    select?: attendancesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesInclude<ExtArgs> | null
    where?: attendancesWhereInput
    orderBy?: attendancesOrderByWithRelationInput | attendancesOrderByWithRelationInput[]
    cursor?: attendancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesScalarFieldEnum | AttendancesScalarFieldEnum[]
  }

  /**
   * students.badges_history
   */
  export type students$badges_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges_history
     */
    select?: badges_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badges_historyInclude<ExtArgs> | null
    where?: badges_historyWhereInput
    orderBy?: badges_historyOrderByWithRelationInput | badges_historyOrderByWithRelationInput[]
    cursor?: badges_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Badges_historyScalarFieldEnum | Badges_historyScalarFieldEnum[]
  }

  /**
   * students.final_grades
   */
  export type students$final_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    where?: final_gradesWhereInput
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    cursor?: final_gradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Final_gradesScalarFieldEnum | Final_gradesScalarFieldEnum[]
  }

  /**
   * students.grades_exams
   */
  export type students$grades_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    where?: grades_examsWhereInput
    orderBy?: grades_examsOrderByWithRelationInput | grades_examsOrderByWithRelationInput[]
    cursor?: grades_examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Grades_examsScalarFieldEnum | Grades_examsScalarFieldEnum[]
  }

  /**
   * students.grades_gradebook
   */
  export type students$grades_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    where?: grades_gradebookWhereInput
    orderBy?: grades_gradebookOrderByWithRelationInput | grades_gradebookOrderByWithRelationInput[]
    cursor?: grades_gradebookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Grades_gradebookScalarFieldEnum | Grades_gradebookScalarFieldEnum[]
  }

  /**
   * students.notifications
   */
  export type students$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * students.questions_responses
   */
  export type students$questions_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    where?: questions_responsesWhereInput
    orderBy?: questions_responsesOrderByWithRelationInput | questions_responsesOrderByWithRelationInput[]
    cursor?: questions_responsesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Questions_responsesScalarFieldEnum | Questions_responsesScalarFieldEnum[]
  }

  /**
   * students.student_closed_answers
   */
  export type students$student_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    where?: student_closed_answersWhereInput
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    cursor?: student_closed_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_closed_answersScalarFieldEnum | Student_closed_answersScalarFieldEnum[]
  }

  /**
   * students.student_open_answers
   */
  export type students$student_open_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    where?: student_open_answersWhereInput
    orderBy?: student_open_answersOrderByWithRelationInput | student_open_answersOrderByWithRelationInput[]
    cursor?: student_open_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_open_answersScalarFieldEnum | Student_open_answersScalarFieldEnum[]
  }

  /**
   * students.classes
   */
  export type students$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    where?: classesWhereInput
  }

  /**
   * students.students_exams
   */
  export type students$students_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    where?: students_examsWhereInput
    orderBy?: students_examsOrderByWithRelationInput | students_examsOrderByWithRelationInput[]
    cursor?: students_examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Students_examsScalarFieldEnum | Students_examsScalarFieldEnum[]
  }

  /**
   * students.students_parents
   */
  export type students$students_parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    where?: students_parentsWhereInput
    orderBy?: students_parentsOrderByWithRelationInput | students_parentsOrderByWithRelationInput[]
    cursor?: students_parentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Students_parentsScalarFieldEnum | Students_parentsScalarFieldEnum[]
  }

  /**
   * students without action
   */
  export type studentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
  }


  /**
   * Model students_parents
   */

  export type AggregateStudents_parents = {
    _count: Students_parentsCountAggregateOutputType | null
    _min: Students_parentsMinAggregateOutputType | null
    _max: Students_parentsMaxAggregateOutputType | null
  }

  export type Students_parentsMinAggregateOutputType = {
    student_id: Uint8Array | null
    parent_id: Uint8Array | null
  }

  export type Students_parentsMaxAggregateOutputType = {
    student_id: Uint8Array | null
    parent_id: Uint8Array | null
  }

  export type Students_parentsCountAggregateOutputType = {
    student_id: number
    parent_id: number
    _all: number
  }


  export type Students_parentsMinAggregateInputType = {
    student_id?: true
    parent_id?: true
  }

  export type Students_parentsMaxAggregateInputType = {
    student_id?: true
    parent_id?: true
  }

  export type Students_parentsCountAggregateInputType = {
    student_id?: true
    parent_id?: true
    _all?: true
  }

  export type Students_parentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students_parents to aggregate.
     */
    where?: students_parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_parents to fetch.
     */
    orderBy?: students_parentsOrderByWithRelationInput | students_parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: students_parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students_parents
    **/
    _count?: true | Students_parentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Students_parentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Students_parentsMaxAggregateInputType
  }

  export type GetStudents_parentsAggregateType<T extends Students_parentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents_parents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents_parents[P]>
      : GetScalarType<T[P], AggregateStudents_parents[P]>
  }




  export type students_parentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: students_parentsWhereInput
    orderBy?: students_parentsOrderByWithAggregationInput | students_parentsOrderByWithAggregationInput[]
    by: Students_parentsScalarFieldEnum[] | Students_parentsScalarFieldEnum
    having?: students_parentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Students_parentsCountAggregateInputType | true
    _min?: Students_parentsMinAggregateInputType
    _max?: Students_parentsMaxAggregateInputType
  }

  export type Students_parentsGroupByOutputType = {
    student_id: Uint8Array
    parent_id: Uint8Array
    _count: Students_parentsCountAggregateOutputType | null
    _min: Students_parentsMinAggregateOutputType | null
    _max: Students_parentsMaxAggregateOutputType | null
  }

  type GetStudents_parentsGroupByPayload<T extends students_parentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Students_parentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Students_parentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Students_parentsGroupByOutputType[P]>
            : GetScalarType<T[P], Students_parentsGroupByOutputType[P]>
        }
      >
    >


  export type students_parentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    parent_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    parents?: boolean | parentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students_parents"]>



  export type students_parentsSelectScalar = {
    student_id?: boolean
    parent_id?: boolean
  }

  export type students_parentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    parents?: boolean | parentsDefaultArgs<ExtArgs>
  }

  export type $students_parentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students_parents"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      parents: Prisma.$parentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: Uint8Array
      parent_id: Uint8Array
    }, ExtArgs["result"]["students_parents"]>
    composites: {}
  }

  type students_parentsGetPayload<S extends boolean | null | undefined | students_parentsDefaultArgs> = $Result.GetResult<Prisma.$students_parentsPayload, S>

  type students_parentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<students_parentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Students_parentsCountAggregateInputType | true
    }

  export interface students_parentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students_parents'], meta: { name: 'students_parents' } }
    /**
     * Find zero or one Students_parents that matches the filter.
     * @param {students_parentsFindUniqueArgs} args - Arguments to find a Students_parents
     * @example
     * // Get one Students_parents
     * const students_parents = await prisma.students_parents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends students_parentsFindUniqueArgs>(args: SelectSubset<T, students_parentsFindUniqueArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Students_parents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {students_parentsFindUniqueOrThrowArgs} args - Arguments to find a Students_parents
     * @example
     * // Get one Students_parents
     * const students_parents = await prisma.students_parents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends students_parentsFindUniqueOrThrowArgs>(args: SelectSubset<T, students_parentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Students_parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_parentsFindFirstArgs} args - Arguments to find a Students_parents
     * @example
     * // Get one Students_parents
     * const students_parents = await prisma.students_parents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends students_parentsFindFirstArgs>(args?: SelectSubset<T, students_parentsFindFirstArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Students_parents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_parentsFindFirstOrThrowArgs} args - Arguments to find a Students_parents
     * @example
     * // Get one Students_parents
     * const students_parents = await prisma.students_parents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends students_parentsFindFirstOrThrowArgs>(args?: SelectSubset<T, students_parentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students_parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_parentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students_parents
     * const students_parents = await prisma.students_parents.findMany()
     * 
     * // Get first 10 Students_parents
     * const students_parents = await prisma.students_parents.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const students_parentsWithStudent_idOnly = await prisma.students_parents.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends students_parentsFindManyArgs>(args?: SelectSubset<T, students_parentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Students_parents.
     * @param {students_parentsCreateArgs} args - Arguments to create a Students_parents.
     * @example
     * // Create one Students_parents
     * const Students_parents = await prisma.students_parents.create({
     *   data: {
     *     // ... data to create a Students_parents
     *   }
     * })
     * 
     */
    create<T extends students_parentsCreateArgs>(args: SelectSubset<T, students_parentsCreateArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students_parents.
     * @param {students_parentsCreateManyArgs} args - Arguments to create many Students_parents.
     * @example
     * // Create many Students_parents
     * const students_parents = await prisma.students_parents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends students_parentsCreateManyArgs>(args?: SelectSubset<T, students_parentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Students_parents.
     * @param {students_parentsDeleteArgs} args - Arguments to delete one Students_parents.
     * @example
     * // Delete one Students_parents
     * const Students_parents = await prisma.students_parents.delete({
     *   where: {
     *     // ... filter to delete one Students_parents
     *   }
     * })
     * 
     */
    delete<T extends students_parentsDeleteArgs>(args: SelectSubset<T, students_parentsDeleteArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Students_parents.
     * @param {students_parentsUpdateArgs} args - Arguments to update one Students_parents.
     * @example
     * // Update one Students_parents
     * const students_parents = await prisma.students_parents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends students_parentsUpdateArgs>(args: SelectSubset<T, students_parentsUpdateArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students_parents.
     * @param {students_parentsDeleteManyArgs} args - Arguments to filter Students_parents to delete.
     * @example
     * // Delete a few Students_parents
     * const { count } = await prisma.students_parents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends students_parentsDeleteManyArgs>(args?: SelectSubset<T, students_parentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students_parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_parentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students_parents
     * const students_parents = await prisma.students_parents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends students_parentsUpdateManyArgs>(args: SelectSubset<T, students_parentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Students_parents.
     * @param {students_parentsUpsertArgs} args - Arguments to update or create a Students_parents.
     * @example
     * // Update or create a Students_parents
     * const students_parents = await prisma.students_parents.upsert({
     *   create: {
     *     // ... data to create a Students_parents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students_parents we want to update
     *   }
     * })
     */
    upsert<T extends students_parentsUpsertArgs>(args: SelectSubset<T, students_parentsUpsertArgs<ExtArgs>>): Prisma__students_parentsClient<$Result.GetResult<Prisma.$students_parentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students_parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_parentsCountArgs} args - Arguments to filter Students_parents to count.
     * @example
     * // Count the number of Students_parents
     * const count = await prisma.students_parents.count({
     *   where: {
     *     // ... the filter for the Students_parents we want to count
     *   }
     * })
    **/
    count<T extends students_parentsCountArgs>(
      args?: Subset<T, students_parentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Students_parentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students_parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Students_parentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Students_parentsAggregateArgs>(args: Subset<T, Students_parentsAggregateArgs>): Prisma.PrismaPromise<GetStudents_parentsAggregateType<T>>

    /**
     * Group by Students_parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_parentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends students_parentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: students_parentsGroupByArgs['orderBy'] }
        : { orderBy?: students_parentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, students_parentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudents_parentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students_parents model
   */
  readonly fields: students_parentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students_parents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__students_parentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parents<T extends parentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parentsDefaultArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students_parents model
   */ 
  interface students_parentsFieldRefs {
    readonly student_id: FieldRef<"students_parents", 'Bytes'>
    readonly parent_id: FieldRef<"students_parents", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * students_parents findUnique
   */
  export type students_parentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * Filter, which students_parents to fetch.
     */
    where: students_parentsWhereUniqueInput
  }

  /**
   * students_parents findUniqueOrThrow
   */
  export type students_parentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * Filter, which students_parents to fetch.
     */
    where: students_parentsWhereUniqueInput
  }

  /**
   * students_parents findFirst
   */
  export type students_parentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * Filter, which students_parents to fetch.
     */
    where?: students_parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_parents to fetch.
     */
    orderBy?: students_parentsOrderByWithRelationInput | students_parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students_parents.
     */
    cursor?: students_parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students_parents.
     */
    distinct?: Students_parentsScalarFieldEnum | Students_parentsScalarFieldEnum[]
  }

  /**
   * students_parents findFirstOrThrow
   */
  export type students_parentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * Filter, which students_parents to fetch.
     */
    where?: students_parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_parents to fetch.
     */
    orderBy?: students_parentsOrderByWithRelationInput | students_parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students_parents.
     */
    cursor?: students_parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students_parents.
     */
    distinct?: Students_parentsScalarFieldEnum | Students_parentsScalarFieldEnum[]
  }

  /**
   * students_parents findMany
   */
  export type students_parentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * Filter, which students_parents to fetch.
     */
    where?: students_parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_parents to fetch.
     */
    orderBy?: students_parentsOrderByWithRelationInput | students_parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students_parents.
     */
    cursor?: students_parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_parents.
     */
    skip?: number
    distinct?: Students_parentsScalarFieldEnum | Students_parentsScalarFieldEnum[]
  }

  /**
   * students_parents create
   */
  export type students_parentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * The data needed to create a students_parents.
     */
    data: XOR<students_parentsCreateInput, students_parentsUncheckedCreateInput>
  }

  /**
   * students_parents createMany
   */
  export type students_parentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students_parents.
     */
    data: students_parentsCreateManyInput | students_parentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students_parents update
   */
  export type students_parentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * The data needed to update a students_parents.
     */
    data: XOR<students_parentsUpdateInput, students_parentsUncheckedUpdateInput>
    /**
     * Choose, which students_parents to update.
     */
    where: students_parentsWhereUniqueInput
  }

  /**
   * students_parents updateMany
   */
  export type students_parentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students_parents.
     */
    data: XOR<students_parentsUpdateManyMutationInput, students_parentsUncheckedUpdateManyInput>
    /**
     * Filter which students_parents to update
     */
    where?: students_parentsWhereInput
  }

  /**
   * students_parents upsert
   */
  export type students_parentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * The filter to search for the students_parents to update in case it exists.
     */
    where: students_parentsWhereUniqueInput
    /**
     * In case the students_parents found by the `where` argument doesn't exist, create a new students_parents with this data.
     */
    create: XOR<students_parentsCreateInput, students_parentsUncheckedCreateInput>
    /**
     * In case the students_parents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<students_parentsUpdateInput, students_parentsUncheckedUpdateInput>
  }

  /**
   * students_parents delete
   */
  export type students_parentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
    /**
     * Filter which students_parents to delete.
     */
    where: students_parentsWhereUniqueInput
  }

  /**
   * students_parents deleteMany
   */
  export type students_parentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students_parents to delete
     */
    where?: students_parentsWhereInput
  }

  /**
   * students_parents without action
   */
  export type students_parentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_parents
     */
    select?: students_parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_parentsInclude<ExtArgs> | null
  }


  /**
   * Model subjects
   */

  export type AggregateSubjects = {
    _count: SubjectsCountAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  export type SubjectsMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type SubjectsMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type SubjectsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SubjectsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SubjectsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SubjectsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SubjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to aggregate.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectsMaxAggregateInputType
  }

  export type GetSubjectsAggregateType<T extends SubjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjects[P]>
      : GetScalarType<T[P], AggregateSubjects[P]>
  }




  export type subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectsWhereInput
    orderBy?: subjectsOrderByWithAggregationInput | subjectsOrderByWithAggregationInput[]
    by: SubjectsScalarFieldEnum[] | SubjectsScalarFieldEnum
    having?: subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectsCountAggregateInputType | true
    _min?: SubjectsMinAggregateInputType
    _max?: SubjectsMaxAggregateInputType
  }

  export type SubjectsGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: SubjectsCountAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  type GetSubjectsGroupByPayload<T extends subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
        }
      >
    >


  export type subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    final_grades?: boolean | subjects$final_gradesArgs<ExtArgs>
    grades_gradebook?: boolean | subjects$grades_gradebookArgs<ExtArgs>
    lessons?: boolean | subjects$lessonsArgs<ExtArgs>
    teachers_subjects?: boolean | subjects$teachers_subjectsArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>



  export type subjectsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type subjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grades?: boolean | subjects$final_gradesArgs<ExtArgs>
    grades_gradebook?: boolean | subjects$grades_gradebookArgs<ExtArgs>
    lessons?: boolean | subjects$lessonsArgs<ExtArgs>
    teachers_subjects?: boolean | subjects$teachers_subjectsArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subjects"
    objects: {
      final_grades: Prisma.$final_gradesPayload<ExtArgs>[]
      grades_gradebook: Prisma.$grades_gradebookPayload<ExtArgs>[]
      lessons: Prisma.$lessonsPayload<ExtArgs>[]
      teachers_subjects: Prisma.$teachers_subjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["subjects"]>
    composites: {}
  }

  type subjectsGetPayload<S extends boolean | null | undefined | subjectsDefaultArgs> = $Result.GetResult<Prisma.$subjectsPayload, S>

  type subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subjectsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubjectsCountAggregateInputType | true
    }

  export interface subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subjects'], meta: { name: 'subjects' } }
    /**
     * Find zero or one Subjects that matches the filter.
     * @param {subjectsFindUniqueArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subjectsFindUniqueArgs>(args: SelectSubset<T, subjectsFindUniqueArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subjectsFindUniqueOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subjectsFindFirstArgs>(args?: SelectSubset<T, subjectsFindFirstArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subjects.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subjects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectsWithIdOnly = await prisma.subjects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subjectsFindManyArgs>(args?: SelectSubset<T, subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subjects.
     * @param {subjectsCreateArgs} args - Arguments to create a Subjects.
     * @example
     * // Create one Subjects
     * const Subjects = await prisma.subjects.create({
     *   data: {
     *     // ... data to create a Subjects
     *   }
     * })
     * 
     */
    create<T extends subjectsCreateArgs>(args: SelectSubset<T, subjectsCreateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subjects.
     * @param {subjectsCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subjectsCreateManyArgs>(args?: SelectSubset<T, subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subjects.
     * @param {subjectsDeleteArgs} args - Arguments to delete one Subjects.
     * @example
     * // Delete one Subjects
     * const Subjects = await prisma.subjects.delete({
     *   where: {
     *     // ... filter to delete one Subjects
     *   }
     * })
     * 
     */
    delete<T extends subjectsDeleteArgs>(args: SelectSubset<T, subjectsDeleteArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subjects.
     * @param {subjectsUpdateArgs} args - Arguments to update one Subjects.
     * @example
     * // Update one Subjects
     * const subjects = await prisma.subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subjectsUpdateArgs>(args: SelectSubset<T, subjectsUpdateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subjects.
     * @param {subjectsDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subjectsDeleteManyArgs>(args?: SelectSubset<T, subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subjectsUpdateManyArgs>(args: SelectSubset<T, subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subjects.
     * @param {subjectsUpsertArgs} args - Arguments to update or create a Subjects.
     * @example
     * // Update or create a Subjects
     * const subjects = await prisma.subjects.upsert({
     *   create: {
     *     // ... data to create a Subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjects we want to update
     *   }
     * })
     */
    upsert<T extends subjectsUpsertArgs>(args: SelectSubset<T, subjectsUpsertArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subjects.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectsCountArgs>(
      args?: Subset<T, subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectsAggregateArgs>(args: Subset<T, SubjectsAggregateArgs>): Prisma.PrismaPromise<GetSubjectsAggregateType<T>>

    /**
     * Group by Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subjectsGroupByArgs['orderBy'] }
        : { orderBy?: subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subjects model
   */
  readonly fields: subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    final_grades<T extends subjects$final_gradesArgs<ExtArgs> = {}>(args?: Subset<T, subjects$final_gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findMany"> | Null>
    grades_gradebook<T extends subjects$grades_gradebookArgs<ExtArgs> = {}>(args?: Subset<T, subjects$grades_gradebookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findMany"> | Null>
    lessons<T extends subjects$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findMany"> | Null>
    teachers_subjects<T extends subjects$teachers_subjectsArgs<ExtArgs> = {}>(args?: Subset<T, subjects$teachers_subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subjects model
   */ 
  interface subjectsFieldRefs {
    readonly id: FieldRef<"subjects", 'Bytes'>
    readonly name: FieldRef<"subjects", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subjects findUnique
   */
  export type subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findUniqueOrThrow
   */
  export type subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findFirst
   */
  export type subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findFirstOrThrow
   */
  export type subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findMany
   */
  export type subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects create
   */
  export type subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a subjects.
     */
    data: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
  }

  /**
   * subjects createMany
   */
  export type subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subjects.
     */
    data: subjectsCreateManyInput | subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subjects update
   */
  export type subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a subjects.
     */
    data: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
    /**
     * Choose, which subjects to update.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects updateMany
   */
  export type subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectsUpdateManyMutationInput, subjectsUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectsWhereInput
  }

  /**
   * subjects upsert
   */
  export type subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the subjects to update in case it exists.
     */
    where: subjectsWhereUniqueInput
    /**
     * In case the subjects found by the `where` argument doesn't exist, create a new subjects with this data.
     */
    create: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
    /**
     * In case the subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
  }

  /**
   * subjects delete
   */
  export type subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter which subjects to delete.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects deleteMany
   */
  export type subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to delete
     */
    where?: subjectsWhereInput
  }

  /**
   * subjects.final_grades
   */
  export type subjects$final_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    where?: final_gradesWhereInput
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    cursor?: final_gradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Final_gradesScalarFieldEnum | Final_gradesScalarFieldEnum[]
  }

  /**
   * subjects.grades_gradebook
   */
  export type subjects$grades_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    where?: grades_gradebookWhereInput
    orderBy?: grades_gradebookOrderByWithRelationInput | grades_gradebookOrderByWithRelationInput[]
    cursor?: grades_gradebookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Grades_gradebookScalarFieldEnum | Grades_gradebookScalarFieldEnum[]
  }

  /**
   * subjects.lessons
   */
  export type subjects$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    where?: lessonsWhereInput
    orderBy?: lessonsOrderByWithRelationInput | lessonsOrderByWithRelationInput[]
    cursor?: lessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * subjects.teachers_subjects
   */
  export type subjects$teachers_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    where?: teachers_subjectsWhereInput
    orderBy?: teachers_subjectsOrderByWithRelationInput | teachers_subjectsOrderByWithRelationInput[]
    cursor?: teachers_subjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Teachers_subjectsScalarFieldEnum | Teachers_subjectsScalarFieldEnum[]
  }

  /**
   * subjects without action
   */
  export type subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
  }


  /**
   * Model surveys
   */

  export type AggregateSurveys = {
    _count: SurveysCountAggregateOutputType | null
    _min: SurveysMinAggregateOutputType | null
    _max: SurveysMaxAggregateOutputType | null
  }

  export type SurveysMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    description: string | null
    start_time: Date | null
    end_time: Date | null
  }

  export type SurveysMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    description: string | null
    start_time: Date | null
    end_time: Date | null
  }

  export type SurveysCountAggregateOutputType = {
    id: number
    name: number
    description: number
    start_time: number
    end_time: number
    _all: number
  }


  export type SurveysMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    start_time?: true
    end_time?: true
  }

  export type SurveysMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    start_time?: true
    end_time?: true
  }

  export type SurveysCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type SurveysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveys to aggregate.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surveys
    **/
    _count?: true | SurveysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveysMaxAggregateInputType
  }

  export type GetSurveysAggregateType<T extends SurveysAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveys[P]>
      : GetScalarType<T[P], AggregateSurveys[P]>
  }




  export type surveysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surveysWhereInput
    orderBy?: surveysOrderByWithAggregationInput | surveysOrderByWithAggregationInput[]
    by: SurveysScalarFieldEnum[] | SurveysScalarFieldEnum
    having?: surveysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveysCountAggregateInputType | true
    _min?: SurveysMinAggregateInputType
    _max?: SurveysMaxAggregateInputType
  }

  export type SurveysGroupByOutputType = {
    id: Uint8Array
    name: string
    description: string
    start_time: Date
    end_time: Date
    _count: SurveysCountAggregateOutputType | null
    _min: SurveysMinAggregateOutputType | null
    _max: SurveysMaxAggregateOutputType | null
  }

  type GetSurveysGroupByPayload<T extends surveysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveysGroupByOutputType[P]>
            : GetScalarType<T[P], SurveysGroupByOutputType[P]>
        }
      >
    >


  export type surveysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    start_time?: boolean
    end_time?: boolean
    questions?: boolean | surveys$questionsArgs<ExtArgs>
    _count?: boolean | SurveysCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveys"]>



  export type surveysSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    start_time?: boolean
    end_time?: boolean
  }

  export type surveysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | surveys$questionsArgs<ExtArgs>
    _count?: boolean | SurveysCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $surveysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "surveys"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
      description: string
      start_time: Date
      end_time: Date
    }, ExtArgs["result"]["surveys"]>
    composites: {}
  }

  type surveysGetPayload<S extends boolean | null | undefined | surveysDefaultArgs> = $Result.GetResult<Prisma.$surveysPayload, S>

  type surveysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<surveysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SurveysCountAggregateInputType | true
    }

  export interface surveysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['surveys'], meta: { name: 'surveys' } }
    /**
     * Find zero or one Surveys that matches the filter.
     * @param {surveysFindUniqueArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends surveysFindUniqueArgs>(args: SelectSubset<T, surveysFindUniqueArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Surveys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {surveysFindUniqueOrThrowArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends surveysFindUniqueOrThrowArgs>(args: SelectSubset<T, surveysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysFindFirstArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends surveysFindFirstArgs>(args?: SelectSubset<T, surveysFindFirstArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Surveys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysFindFirstOrThrowArgs} args - Arguments to find a Surveys
     * @example
     * // Get one Surveys
     * const surveys = await prisma.surveys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends surveysFindFirstOrThrowArgs>(args?: SelectSubset<T, surveysFindFirstOrThrowArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveys
     * const surveys = await prisma.surveys.findMany()
     * 
     * // Get first 10 Surveys
     * const surveys = await prisma.surveys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveysWithIdOnly = await prisma.surveys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends surveysFindManyArgs>(args?: SelectSubset<T, surveysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Surveys.
     * @param {surveysCreateArgs} args - Arguments to create a Surveys.
     * @example
     * // Create one Surveys
     * const Surveys = await prisma.surveys.create({
     *   data: {
     *     // ... data to create a Surveys
     *   }
     * })
     * 
     */
    create<T extends surveysCreateArgs>(args: SelectSubset<T, surveysCreateArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Surveys.
     * @param {surveysCreateManyArgs} args - Arguments to create many Surveys.
     * @example
     * // Create many Surveys
     * const surveys = await prisma.surveys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends surveysCreateManyArgs>(args?: SelectSubset<T, surveysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Surveys.
     * @param {surveysDeleteArgs} args - Arguments to delete one Surveys.
     * @example
     * // Delete one Surveys
     * const Surveys = await prisma.surveys.delete({
     *   where: {
     *     // ... filter to delete one Surveys
     *   }
     * })
     * 
     */
    delete<T extends surveysDeleteArgs>(args: SelectSubset<T, surveysDeleteArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Surveys.
     * @param {surveysUpdateArgs} args - Arguments to update one Surveys.
     * @example
     * // Update one Surveys
     * const surveys = await prisma.surveys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends surveysUpdateArgs>(args: SelectSubset<T, surveysUpdateArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Surveys.
     * @param {surveysDeleteManyArgs} args - Arguments to filter Surveys to delete.
     * @example
     * // Delete a few Surveys
     * const { count } = await prisma.surveys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends surveysDeleteManyArgs>(args?: SelectSubset<T, surveysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveys
     * const surveys = await prisma.surveys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends surveysUpdateManyArgs>(args: SelectSubset<T, surveysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Surveys.
     * @param {surveysUpsertArgs} args - Arguments to update or create a Surveys.
     * @example
     * // Update or create a Surveys
     * const surveys = await prisma.surveys.upsert({
     *   create: {
     *     // ... data to create a Surveys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Surveys we want to update
     *   }
     * })
     */
    upsert<T extends surveysUpsertArgs>(args: SelectSubset<T, surveysUpsertArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysCountArgs} args - Arguments to filter Surveys to count.
     * @example
     * // Count the number of Surveys
     * const count = await prisma.surveys.count({
     *   where: {
     *     // ... the filter for the Surveys we want to count
     *   }
     * })
    **/
    count<T extends surveysCountArgs>(
      args?: Subset<T, surveysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveysAggregateArgs>(args: Subset<T, SurveysAggregateArgs>): Prisma.PrismaPromise<GetSurveysAggregateType<T>>

    /**
     * Group by Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surveysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surveysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surveysGroupByArgs['orderBy'] }
        : { orderBy?: surveysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surveysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the surveys model
   */
  readonly fields: surveysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for surveys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surveysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends surveys$questionsArgs<ExtArgs> = {}>(args?: Subset<T, surveys$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the surveys model
   */ 
  interface surveysFieldRefs {
    readonly id: FieldRef<"surveys", 'Bytes'>
    readonly name: FieldRef<"surveys", 'String'>
    readonly description: FieldRef<"surveys", 'String'>
    readonly start_time: FieldRef<"surveys", 'DateTime'>
    readonly end_time: FieldRef<"surveys", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * surveys findUnique
   */
  export type surveysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where: surveysWhereUniqueInput
  }

  /**
   * surveys findUniqueOrThrow
   */
  export type surveysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where: surveysWhereUniqueInput
  }

  /**
   * surveys findFirst
   */
  export type surveysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveys.
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveys.
     */
    distinct?: SurveysScalarFieldEnum | SurveysScalarFieldEnum[]
  }

  /**
   * surveys findFirstOrThrow
   */
  export type surveysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surveys.
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surveys.
     */
    distinct?: SurveysScalarFieldEnum | SurveysScalarFieldEnum[]
  }

  /**
   * surveys findMany
   */
  export type surveysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * Filter, which surveys to fetch.
     */
    where?: surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surveys to fetch.
     */
    orderBy?: surveysOrderByWithRelationInput | surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surveys.
     */
    cursor?: surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surveys.
     */
    skip?: number
    distinct?: SurveysScalarFieldEnum | SurveysScalarFieldEnum[]
  }

  /**
   * surveys create
   */
  export type surveysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * The data needed to create a surveys.
     */
    data: XOR<surveysCreateInput, surveysUncheckedCreateInput>
  }

  /**
   * surveys createMany
   */
  export type surveysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surveys.
     */
    data: surveysCreateManyInput | surveysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surveys update
   */
  export type surveysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * The data needed to update a surveys.
     */
    data: XOR<surveysUpdateInput, surveysUncheckedUpdateInput>
    /**
     * Choose, which surveys to update.
     */
    where: surveysWhereUniqueInput
  }

  /**
   * surveys updateMany
   */
  export type surveysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surveys.
     */
    data: XOR<surveysUpdateManyMutationInput, surveysUncheckedUpdateManyInput>
    /**
     * Filter which surveys to update
     */
    where?: surveysWhereInput
  }

  /**
   * surveys upsert
   */
  export type surveysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * The filter to search for the surveys to update in case it exists.
     */
    where: surveysWhereUniqueInput
    /**
     * In case the surveys found by the `where` argument doesn't exist, create a new surveys with this data.
     */
    create: XOR<surveysCreateInput, surveysUncheckedCreateInput>
    /**
     * In case the surveys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surveysUpdateInput, surveysUncheckedUpdateInput>
  }

  /**
   * surveys delete
   */
  export type surveysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
    /**
     * Filter which surveys to delete.
     */
    where: surveysWhereUniqueInput
  }

  /**
   * surveys deleteMany
   */
  export type surveysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surveys to delete
     */
    where?: surveysWhereInput
  }

  /**
   * surveys.questions
   */
  export type surveys$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * surveys without action
   */
  export type surveysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surveys
     */
    select?: surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: surveysInclude<ExtArgs> | null
  }


  /**
   * Model teachers
   */

  export type AggregateTeachers = {
    _count: TeachersCountAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  export type TeachersMinAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
  }

  export type TeachersMaxAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
  }

  export type TeachersCountAggregateOutputType = {
    id: number
    pesel: number
    email: number
    phone_number: number
    password: number
    first_name: number
    last_name: number
    reset_password_token: number
    reset_password_expires: number
    _all: number
  }


  export type TeachersMinAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
  }

  export type TeachersMaxAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
  }

  export type TeachersCountAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
    _all?: true
  }

  export type TeachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to aggregate.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers
    **/
    _count?: true | TeachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachersMaxAggregateInputType
  }

  export type GetTeachersAggregateType<T extends TeachersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers[P]>
      : GetScalarType<T[P], AggregateTeachers[P]>
  }




  export type teachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithAggregationInput | teachersOrderByWithAggregationInput[]
    by: TeachersScalarFieldEnum[] | TeachersScalarFieldEnum
    having?: teachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachersCountAggregateInputType | true
    _min?: TeachersMinAggregateInputType
    _max?: TeachersMaxAggregateInputType
  }

  export type TeachersGroupByOutputType = {
    id: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token: string | null
    reset_password_expires: Date | null
    _count: TeachersCountAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  type GetTeachersGroupByPayload<T extends teachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachersGroupByOutputType[P]>
            : GetScalarType<T[P], TeachersGroupByOutputType[P]>
        }
      >
    >


  export type teachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
    classes?: boolean | teachers$classesArgs<ExtArgs>
    exams?: boolean | teachers$examsArgs<ExtArgs>
    final_grades?: boolean | teachers$final_gradesArgs<ExtArgs>
    grades_gradebook?: boolean | teachers$grades_gradebookArgs<ExtArgs>
    lessons?: boolean | teachers$lessonsArgs<ExtArgs>
    teachers_subjects?: boolean | teachers$teachers_subjectsArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>



  export type teachersSelectScalar = {
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
  }

  export type teachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | teachers$classesArgs<ExtArgs>
    exams?: boolean | teachers$examsArgs<ExtArgs>
    final_grades?: boolean | teachers$final_gradesArgs<ExtArgs>
    grades_gradebook?: boolean | teachers$grades_gradebookArgs<ExtArgs>
    lessons?: boolean | teachers$lessonsArgs<ExtArgs>
    teachers_subjects?: boolean | teachers$teachers_subjectsArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $teachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teachers"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>[]
      exams: Prisma.$examsPayload<ExtArgs>[]
      final_grades: Prisma.$final_gradesPayload<ExtArgs>[]
      grades_gradebook: Prisma.$grades_gradebookPayload<ExtArgs>[]
      lessons: Prisma.$lessonsPayload<ExtArgs>[]
      teachers_subjects: Prisma.$teachers_subjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      pesel: string
      email: string
      phone_number: string
      password: string
      first_name: string
      last_name: string
      reset_password_token: string | null
      reset_password_expires: Date | null
    }, ExtArgs["result"]["teachers"]>
    composites: {}
  }

  type teachersGetPayload<S extends boolean | null | undefined | teachersDefaultArgs> = $Result.GetResult<Prisma.$teachersPayload, S>

  type teachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teachersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeachersCountAggregateInputType | true
    }

  export interface teachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teachers'], meta: { name: 'teachers' } }
    /**
     * Find zero or one Teachers that matches the filter.
     * @param {teachersFindUniqueArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teachersFindUniqueArgs>(args: SelectSubset<T, teachersFindUniqueArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Teachers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teachersFindUniqueOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teachersFindUniqueOrThrowArgs>(args: SelectSubset<T, teachersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teachersFindFirstArgs>(args?: SelectSubset<T, teachersFindFirstArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teachersFindFirstOrThrowArgs>(args?: SelectSubset<T, teachersFindFirstOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teachers.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teachers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachersWithIdOnly = await prisma.teachers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teachersFindManyArgs>(args?: SelectSubset<T, teachersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Teachers.
     * @param {teachersCreateArgs} args - Arguments to create a Teachers.
     * @example
     * // Create one Teachers
     * const Teachers = await prisma.teachers.create({
     *   data: {
     *     // ... data to create a Teachers
     *   }
     * })
     * 
     */
    create<T extends teachersCreateArgs>(args: SelectSubset<T, teachersCreateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teachers.
     * @param {teachersCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teachersCreateManyArgs>(args?: SelectSubset<T, teachersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teachers.
     * @param {teachersDeleteArgs} args - Arguments to delete one Teachers.
     * @example
     * // Delete one Teachers
     * const Teachers = await prisma.teachers.delete({
     *   where: {
     *     // ... filter to delete one Teachers
     *   }
     * })
     * 
     */
    delete<T extends teachersDeleteArgs>(args: SelectSubset<T, teachersDeleteArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Teachers.
     * @param {teachersUpdateArgs} args - Arguments to update one Teachers.
     * @example
     * // Update one Teachers
     * const teachers = await prisma.teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teachersUpdateArgs>(args: SelectSubset<T, teachersUpdateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teachers.
     * @param {teachersDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teachersDeleteManyArgs>(args?: SelectSubset<T, teachersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teachersUpdateManyArgs>(args: SelectSubset<T, teachersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teachers.
     * @param {teachersUpsertArgs} args - Arguments to update or create a Teachers.
     * @example
     * // Update or create a Teachers
     * const teachers = await prisma.teachers.upsert({
     *   create: {
     *     // ... data to create a Teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers we want to update
     *   }
     * })
     */
    upsert<T extends teachersUpsertArgs>(args: SelectSubset<T, teachersUpsertArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teachers.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends teachersCountArgs>(
      args?: Subset<T, teachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachersAggregateArgs>(args: Subset<T, TeachersAggregateArgs>): Prisma.PrismaPromise<GetTeachersAggregateType<T>>

    /**
     * Group by Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teachersGroupByArgs['orderBy'] }
        : { orderBy?: teachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teachers model
   */
  readonly fields: teachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends teachers$classesArgs<ExtArgs> = {}>(args?: Subset<T, teachers$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends teachers$examsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findMany"> | Null>
    final_grades<T extends teachers$final_gradesArgs<ExtArgs> = {}>(args?: Subset<T, teachers$final_gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findMany"> | Null>
    grades_gradebook<T extends teachers$grades_gradebookArgs<ExtArgs> = {}>(args?: Subset<T, teachers$grades_gradebookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grades_gradebookPayload<ExtArgs>, T, "findMany"> | Null>
    lessons<T extends teachers$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findMany"> | Null>
    teachers_subjects<T extends teachers$teachers_subjectsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$teachers_subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teachers model
   */ 
  interface teachersFieldRefs {
    readonly id: FieldRef<"teachers", 'Bytes'>
    readonly pesel: FieldRef<"teachers", 'String'>
    readonly email: FieldRef<"teachers", 'String'>
    readonly phone_number: FieldRef<"teachers", 'String'>
    readonly password: FieldRef<"teachers", 'String'>
    readonly first_name: FieldRef<"teachers", 'String'>
    readonly last_name: FieldRef<"teachers", 'String'>
    readonly reset_password_token: FieldRef<"teachers", 'String'>
    readonly reset_password_expires: FieldRef<"teachers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * teachers findUnique
   */
  export type teachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findUniqueOrThrow
   */
  export type teachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findFirst
   */
  export type teachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findFirstOrThrow
   */
  export type teachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findMany
   */
  export type teachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers create
   */
  export type teachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to create a teachers.
     */
    data: XOR<teachersCreateInput, teachersUncheckedCreateInput>
  }

  /**
   * teachers createMany
   */
  export type teachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teachers.
     */
    data: teachersCreateManyInput | teachersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teachers update
   */
  export type teachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to update a teachers.
     */
    data: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
    /**
     * Choose, which teachers to update.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers updateMany
   */
  export type teachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teachers.
     */
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teachersWhereInput
  }

  /**
   * teachers upsert
   */
  export type teachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The filter to search for the teachers to update in case it exists.
     */
    where: teachersWhereUniqueInput
    /**
     * In case the teachers found by the `where` argument doesn't exist, create a new teachers with this data.
     */
    create: XOR<teachersCreateInput, teachersUncheckedCreateInput>
    /**
     * In case the teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
  }

  /**
   * teachers delete
   */
  export type teachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter which teachers to delete.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers deleteMany
   */
  export type teachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to delete
     */
    where?: teachersWhereInput
  }

  /**
   * teachers.classes
   */
  export type teachers$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    where?: classesWhereInput
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    cursor?: classesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * teachers.exams
   */
  export type teachers$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    where?: examsWhereInput
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    cursor?: examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * teachers.final_grades
   */
  export type teachers$final_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    where?: final_gradesWhereInput
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    cursor?: final_gradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Final_gradesScalarFieldEnum | Final_gradesScalarFieldEnum[]
  }

  /**
   * teachers.grades_gradebook
   */
  export type teachers$grades_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_gradebook
     */
    select?: grades_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_gradebookInclude<ExtArgs> | null
    where?: grades_gradebookWhereInput
    orderBy?: grades_gradebookOrderByWithRelationInput | grades_gradebookOrderByWithRelationInput[]
    cursor?: grades_gradebookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Grades_gradebookScalarFieldEnum | Grades_gradebookScalarFieldEnum[]
  }

  /**
   * teachers.lessons
   */
  export type teachers$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessons
     */
    select?: lessonsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonsInclude<ExtArgs> | null
    where?: lessonsWhereInput
    orderBy?: lessonsOrderByWithRelationInput | lessonsOrderByWithRelationInput[]
    cursor?: lessonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonsScalarFieldEnum | LessonsScalarFieldEnum[]
  }

  /**
   * teachers.teachers_subjects
   */
  export type teachers$teachers_subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    where?: teachers_subjectsWhereInput
    orderBy?: teachers_subjectsOrderByWithRelationInput | teachers_subjectsOrderByWithRelationInput[]
    cursor?: teachers_subjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Teachers_subjectsScalarFieldEnum | Teachers_subjectsScalarFieldEnum[]
  }

  /**
   * teachers without action
   */
  export type teachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
  }


  /**
   * Model teachers_subjects
   */

  export type AggregateTeachers_subjects = {
    _count: Teachers_subjectsCountAggregateOutputType | null
    _min: Teachers_subjectsMinAggregateOutputType | null
    _max: Teachers_subjectsMaxAggregateOutputType | null
  }

  export type Teachers_subjectsMinAggregateOutputType = {
    teacher_id: Uint8Array | null
    subject_id: Uint8Array | null
  }

  export type Teachers_subjectsMaxAggregateOutputType = {
    teacher_id: Uint8Array | null
    subject_id: Uint8Array | null
  }

  export type Teachers_subjectsCountAggregateOutputType = {
    teacher_id: number
    subject_id: number
    _all: number
  }


  export type Teachers_subjectsMinAggregateInputType = {
    teacher_id?: true
    subject_id?: true
  }

  export type Teachers_subjectsMaxAggregateInputType = {
    teacher_id?: true
    subject_id?: true
  }

  export type Teachers_subjectsCountAggregateInputType = {
    teacher_id?: true
    subject_id?: true
    _all?: true
  }

  export type Teachers_subjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers_subjects to aggregate.
     */
    where?: teachers_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers_subjects to fetch.
     */
    orderBy?: teachers_subjectsOrderByWithRelationInput | teachers_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teachers_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers_subjects
    **/
    _count?: true | Teachers_subjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Teachers_subjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Teachers_subjectsMaxAggregateInputType
  }

  export type GetTeachers_subjectsAggregateType<T extends Teachers_subjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers_subjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers_subjects[P]>
      : GetScalarType<T[P], AggregateTeachers_subjects[P]>
  }




  export type teachers_subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachers_subjectsWhereInput
    orderBy?: teachers_subjectsOrderByWithAggregationInput | teachers_subjectsOrderByWithAggregationInput[]
    by: Teachers_subjectsScalarFieldEnum[] | Teachers_subjectsScalarFieldEnum
    having?: teachers_subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Teachers_subjectsCountAggregateInputType | true
    _min?: Teachers_subjectsMinAggregateInputType
    _max?: Teachers_subjectsMaxAggregateInputType
  }

  export type Teachers_subjectsGroupByOutputType = {
    teacher_id: Uint8Array
    subject_id: Uint8Array
    _count: Teachers_subjectsCountAggregateOutputType | null
    _min: Teachers_subjectsMinAggregateOutputType | null
    _max: Teachers_subjectsMaxAggregateOutputType | null
  }

  type GetTeachers_subjectsGroupByPayload<T extends teachers_subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Teachers_subjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Teachers_subjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Teachers_subjectsGroupByOutputType[P]>
            : GetScalarType<T[P], Teachers_subjectsGroupByOutputType[P]>
        }
      >
    >


  export type teachers_subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_id?: boolean
    subject_id?: boolean
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachers_subjects"]>



  export type teachers_subjectsSelectScalar = {
    teacher_id?: boolean
    subject_id?: boolean
  }

  export type teachers_subjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
  }

  export type $teachers_subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teachers_subjects"
    objects: {
      teachers: Prisma.$teachersPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      teacher_id: Uint8Array
      subject_id: Uint8Array
    }, ExtArgs["result"]["teachers_subjects"]>
    composites: {}
  }

  type teachers_subjectsGetPayload<S extends boolean | null | undefined | teachers_subjectsDefaultArgs> = $Result.GetResult<Prisma.$teachers_subjectsPayload, S>

  type teachers_subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teachers_subjectsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Teachers_subjectsCountAggregateInputType | true
    }

  export interface teachers_subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teachers_subjects'], meta: { name: 'teachers_subjects' } }
    /**
     * Find zero or one Teachers_subjects that matches the filter.
     * @param {teachers_subjectsFindUniqueArgs} args - Arguments to find a Teachers_subjects
     * @example
     * // Get one Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teachers_subjectsFindUniqueArgs>(args: SelectSubset<T, teachers_subjectsFindUniqueArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Teachers_subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teachers_subjectsFindUniqueOrThrowArgs} args - Arguments to find a Teachers_subjects
     * @example
     * // Get one Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teachers_subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, teachers_subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Teachers_subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachers_subjectsFindFirstArgs} args - Arguments to find a Teachers_subjects
     * @example
     * // Get one Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teachers_subjectsFindFirstArgs>(args?: SelectSubset<T, teachers_subjectsFindFirstArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Teachers_subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachers_subjectsFindFirstOrThrowArgs} args - Arguments to find a Teachers_subjects
     * @example
     * // Get one Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teachers_subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, teachers_subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teachers_subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachers_subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.findMany()
     * 
     * // Get first 10 Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.findMany({ take: 10 })
     * 
     * // Only select the `teacher_id`
     * const teachers_subjectsWithTeacher_idOnly = await prisma.teachers_subjects.findMany({ select: { teacher_id: true } })
     * 
     */
    findMany<T extends teachers_subjectsFindManyArgs>(args?: SelectSubset<T, teachers_subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Teachers_subjects.
     * @param {teachers_subjectsCreateArgs} args - Arguments to create a Teachers_subjects.
     * @example
     * // Create one Teachers_subjects
     * const Teachers_subjects = await prisma.teachers_subjects.create({
     *   data: {
     *     // ... data to create a Teachers_subjects
     *   }
     * })
     * 
     */
    create<T extends teachers_subjectsCreateArgs>(args: SelectSubset<T, teachers_subjectsCreateArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teachers_subjects.
     * @param {teachers_subjectsCreateManyArgs} args - Arguments to create many Teachers_subjects.
     * @example
     * // Create many Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teachers_subjectsCreateManyArgs>(args?: SelectSubset<T, teachers_subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teachers_subjects.
     * @param {teachers_subjectsDeleteArgs} args - Arguments to delete one Teachers_subjects.
     * @example
     * // Delete one Teachers_subjects
     * const Teachers_subjects = await prisma.teachers_subjects.delete({
     *   where: {
     *     // ... filter to delete one Teachers_subjects
     *   }
     * })
     * 
     */
    delete<T extends teachers_subjectsDeleteArgs>(args: SelectSubset<T, teachers_subjectsDeleteArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Teachers_subjects.
     * @param {teachers_subjectsUpdateArgs} args - Arguments to update one Teachers_subjects.
     * @example
     * // Update one Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teachers_subjectsUpdateArgs>(args: SelectSubset<T, teachers_subjectsUpdateArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teachers_subjects.
     * @param {teachers_subjectsDeleteManyArgs} args - Arguments to filter Teachers_subjects to delete.
     * @example
     * // Delete a few Teachers_subjects
     * const { count } = await prisma.teachers_subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teachers_subjectsDeleteManyArgs>(args?: SelectSubset<T, teachers_subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachers_subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teachers_subjectsUpdateManyArgs>(args: SelectSubset<T, teachers_subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teachers_subjects.
     * @param {teachers_subjectsUpsertArgs} args - Arguments to update or create a Teachers_subjects.
     * @example
     * // Update or create a Teachers_subjects
     * const teachers_subjects = await prisma.teachers_subjects.upsert({
     *   create: {
     *     // ... data to create a Teachers_subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers_subjects we want to update
     *   }
     * })
     */
    upsert<T extends teachers_subjectsUpsertArgs>(args: SelectSubset<T, teachers_subjectsUpsertArgs<ExtArgs>>): Prisma__teachers_subjectsClient<$Result.GetResult<Prisma.$teachers_subjectsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teachers_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachers_subjectsCountArgs} args - Arguments to filter Teachers_subjects to count.
     * @example
     * // Count the number of Teachers_subjects
     * const count = await prisma.teachers_subjects.count({
     *   where: {
     *     // ... the filter for the Teachers_subjects we want to count
     *   }
     * })
    **/
    count<T extends teachers_subjectsCountArgs>(
      args?: Subset<T, teachers_subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Teachers_subjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Teachers_subjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Teachers_subjectsAggregateArgs>(args: Subset<T, Teachers_subjectsAggregateArgs>): Prisma.PrismaPromise<GetTeachers_subjectsAggregateType<T>>

    /**
     * Group by Teachers_subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachers_subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teachers_subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teachers_subjectsGroupByArgs['orderBy'] }
        : { orderBy?: teachers_subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teachers_subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachers_subjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teachers_subjects model
   */
  readonly fields: teachers_subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teachers_subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teachers_subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teachers_subjects model
   */ 
  interface teachers_subjectsFieldRefs {
    readonly teacher_id: FieldRef<"teachers_subjects", 'Bytes'>
    readonly subject_id: FieldRef<"teachers_subjects", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * teachers_subjects findUnique
   */
  export type teachers_subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which teachers_subjects to fetch.
     */
    where: teachers_subjectsWhereUniqueInput
  }

  /**
   * teachers_subjects findUniqueOrThrow
   */
  export type teachers_subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which teachers_subjects to fetch.
     */
    where: teachers_subjectsWhereUniqueInput
  }

  /**
   * teachers_subjects findFirst
   */
  export type teachers_subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which teachers_subjects to fetch.
     */
    where?: teachers_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers_subjects to fetch.
     */
    orderBy?: teachers_subjectsOrderByWithRelationInput | teachers_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers_subjects.
     */
    cursor?: teachers_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers_subjects.
     */
    distinct?: Teachers_subjectsScalarFieldEnum | Teachers_subjectsScalarFieldEnum[]
  }

  /**
   * teachers_subjects findFirstOrThrow
   */
  export type teachers_subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which teachers_subjects to fetch.
     */
    where?: teachers_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers_subjects to fetch.
     */
    orderBy?: teachers_subjectsOrderByWithRelationInput | teachers_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers_subjects.
     */
    cursor?: teachers_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers_subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers_subjects.
     */
    distinct?: Teachers_subjectsScalarFieldEnum | Teachers_subjectsScalarFieldEnum[]
  }

  /**
   * teachers_subjects findMany
   */
  export type teachers_subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * Filter, which teachers_subjects to fetch.
     */
    where?: teachers_subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers_subjects to fetch.
     */
    orderBy?: teachers_subjectsOrderByWithRelationInput | teachers_subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers_subjects.
     */
    cursor?: teachers_subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers_subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers_subjects.
     */
    skip?: number
    distinct?: Teachers_subjectsScalarFieldEnum | Teachers_subjectsScalarFieldEnum[]
  }

  /**
   * teachers_subjects create
   */
  export type teachers_subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a teachers_subjects.
     */
    data: XOR<teachers_subjectsCreateInput, teachers_subjectsUncheckedCreateInput>
  }

  /**
   * teachers_subjects createMany
   */
  export type teachers_subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teachers_subjects.
     */
    data: teachers_subjectsCreateManyInput | teachers_subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teachers_subjects update
   */
  export type teachers_subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a teachers_subjects.
     */
    data: XOR<teachers_subjectsUpdateInput, teachers_subjectsUncheckedUpdateInput>
    /**
     * Choose, which teachers_subjects to update.
     */
    where: teachers_subjectsWhereUniqueInput
  }

  /**
   * teachers_subjects updateMany
   */
  export type teachers_subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teachers_subjects.
     */
    data: XOR<teachers_subjectsUpdateManyMutationInput, teachers_subjectsUncheckedUpdateManyInput>
    /**
     * Filter which teachers_subjects to update
     */
    where?: teachers_subjectsWhereInput
  }

  /**
   * teachers_subjects upsert
   */
  export type teachers_subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the teachers_subjects to update in case it exists.
     */
    where: teachers_subjectsWhereUniqueInput
    /**
     * In case the teachers_subjects found by the `where` argument doesn't exist, create a new teachers_subjects with this data.
     */
    create: XOR<teachers_subjectsCreateInput, teachers_subjectsUncheckedCreateInput>
    /**
     * In case the teachers_subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teachers_subjectsUpdateInput, teachers_subjectsUncheckedUpdateInput>
  }

  /**
   * teachers_subjects delete
   */
  export type teachers_subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
    /**
     * Filter which teachers_subjects to delete.
     */
    where: teachers_subjectsWhereUniqueInput
  }

  /**
   * teachers_subjects deleteMany
   */
  export type teachers_subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers_subjects to delete
     */
    where?: teachers_subjectsWhereInput
  }

  /**
   * teachers_subjects without action
   */
  export type teachers_subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers_subjects
     */
    select?: teachers_subjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachers_subjectsInclude<ExtArgs> | null
  }


  /**
   * Model updates
   */

  export type AggregateUpdates = {
    _count: UpdatesCountAggregateOutputType | null
    _min: UpdatesMinAggregateOutputType | null
    _max: UpdatesMaxAggregateOutputType | null
  }

  export type UpdatesMinAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    version: string | null
    release_time: Date | null
  }

  export type UpdatesMaxAggregateOutputType = {
    id: Uint8Array | null
    description: string | null
    version: string | null
    release_time: Date | null
  }

  export type UpdatesCountAggregateOutputType = {
    id: number
    description: number
    version: number
    release_time: number
    _all: number
  }


  export type UpdatesMinAggregateInputType = {
    id?: true
    description?: true
    version?: true
    release_time?: true
  }

  export type UpdatesMaxAggregateInputType = {
    id?: true
    description?: true
    version?: true
    release_time?: true
  }

  export type UpdatesCountAggregateInputType = {
    id?: true
    description?: true
    version?: true
    release_time?: true
    _all?: true
  }

  export type UpdatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which updates to aggregate.
     */
    where?: updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of updates to fetch.
     */
    orderBy?: updatesOrderByWithRelationInput | updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned updates
    **/
    _count?: true | UpdatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpdatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpdatesMaxAggregateInputType
  }

  export type GetUpdatesAggregateType<T extends UpdatesAggregateArgs> = {
        [P in keyof T & keyof AggregateUpdates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpdates[P]>
      : GetScalarType<T[P], AggregateUpdates[P]>
  }




  export type updatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: updatesWhereInput
    orderBy?: updatesOrderByWithAggregationInput | updatesOrderByWithAggregationInput[]
    by: UpdatesScalarFieldEnum[] | UpdatesScalarFieldEnum
    having?: updatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpdatesCountAggregateInputType | true
    _min?: UpdatesMinAggregateInputType
    _max?: UpdatesMaxAggregateInputType
  }

  export type UpdatesGroupByOutputType = {
    id: Uint8Array
    description: string
    version: string
    release_time: Date
    _count: UpdatesCountAggregateOutputType | null
    _min: UpdatesMinAggregateOutputType | null
    _max: UpdatesMaxAggregateOutputType | null
  }

  type GetUpdatesGroupByPayload<T extends updatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpdatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpdatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpdatesGroupByOutputType[P]>
            : GetScalarType<T[P], UpdatesGroupByOutputType[P]>
        }
      >
    >


  export type updatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    version?: boolean
    release_time?: boolean
  }, ExtArgs["result"]["updates"]>



  export type updatesSelectScalar = {
    id?: boolean
    description?: boolean
    version?: boolean
    release_time?: boolean
  }


  export type $updatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "updates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      description: string
      version: string
      release_time: Date
    }, ExtArgs["result"]["updates"]>
    composites: {}
  }

  type updatesGetPayload<S extends boolean | null | undefined | updatesDefaultArgs> = $Result.GetResult<Prisma.$updatesPayload, S>

  type updatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<updatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UpdatesCountAggregateInputType | true
    }

  export interface updatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['updates'], meta: { name: 'updates' } }
    /**
     * Find zero or one Updates that matches the filter.
     * @param {updatesFindUniqueArgs} args - Arguments to find a Updates
     * @example
     * // Get one Updates
     * const updates = await prisma.updates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends updatesFindUniqueArgs>(args: SelectSubset<T, updatesFindUniqueArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Updates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {updatesFindUniqueOrThrowArgs} args - Arguments to find a Updates
     * @example
     * // Get one Updates
     * const updates = await prisma.updates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends updatesFindUniqueOrThrowArgs>(args: SelectSubset<T, updatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Updates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {updatesFindFirstArgs} args - Arguments to find a Updates
     * @example
     * // Get one Updates
     * const updates = await prisma.updates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends updatesFindFirstArgs>(args?: SelectSubset<T, updatesFindFirstArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Updates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {updatesFindFirstOrThrowArgs} args - Arguments to find a Updates
     * @example
     * // Get one Updates
     * const updates = await prisma.updates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends updatesFindFirstOrThrowArgs>(args?: SelectSubset<T, updatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Updates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {updatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Updates
     * const updates = await prisma.updates.findMany()
     * 
     * // Get first 10 Updates
     * const updates = await prisma.updates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const updatesWithIdOnly = await prisma.updates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends updatesFindManyArgs>(args?: SelectSubset<T, updatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Updates.
     * @param {updatesCreateArgs} args - Arguments to create a Updates.
     * @example
     * // Create one Updates
     * const Updates = await prisma.updates.create({
     *   data: {
     *     // ... data to create a Updates
     *   }
     * })
     * 
     */
    create<T extends updatesCreateArgs>(args: SelectSubset<T, updatesCreateArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Updates.
     * @param {updatesCreateManyArgs} args - Arguments to create many Updates.
     * @example
     * // Create many Updates
     * const updates = await prisma.updates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends updatesCreateManyArgs>(args?: SelectSubset<T, updatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Updates.
     * @param {updatesDeleteArgs} args - Arguments to delete one Updates.
     * @example
     * // Delete one Updates
     * const Updates = await prisma.updates.delete({
     *   where: {
     *     // ... filter to delete one Updates
     *   }
     * })
     * 
     */
    delete<T extends updatesDeleteArgs>(args: SelectSubset<T, updatesDeleteArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Updates.
     * @param {updatesUpdateArgs} args - Arguments to update one Updates.
     * @example
     * // Update one Updates
     * const updates = await prisma.updates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends updatesUpdateArgs>(args: SelectSubset<T, updatesUpdateArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Updates.
     * @param {updatesDeleteManyArgs} args - Arguments to filter Updates to delete.
     * @example
     * // Delete a few Updates
     * const { count } = await prisma.updates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends updatesDeleteManyArgs>(args?: SelectSubset<T, updatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {updatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Updates
     * const updates = await prisma.updates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends updatesUpdateManyArgs>(args: SelectSubset<T, updatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Updates.
     * @param {updatesUpsertArgs} args - Arguments to update or create a Updates.
     * @example
     * // Update or create a Updates
     * const updates = await prisma.updates.upsert({
     *   create: {
     *     // ... data to create a Updates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Updates we want to update
     *   }
     * })
     */
    upsert<T extends updatesUpsertArgs>(args: SelectSubset<T, updatesUpsertArgs<ExtArgs>>): Prisma__updatesClient<$Result.GetResult<Prisma.$updatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {updatesCountArgs} args - Arguments to filter Updates to count.
     * @example
     * // Count the number of Updates
     * const count = await prisma.updates.count({
     *   where: {
     *     // ... the filter for the Updates we want to count
     *   }
     * })
    **/
    count<T extends updatesCountArgs>(
      args?: Subset<T, updatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpdatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpdatesAggregateArgs>(args: Subset<T, UpdatesAggregateArgs>): Prisma.PrismaPromise<GetUpdatesAggregateType<T>>

    /**
     * Group by Updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {updatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends updatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: updatesGroupByArgs['orderBy'] }
        : { orderBy?: updatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, updatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpdatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the updates model
   */
  readonly fields: updatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for updates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__updatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the updates model
   */ 
  interface updatesFieldRefs {
    readonly id: FieldRef<"updates", 'Bytes'>
    readonly description: FieldRef<"updates", 'String'>
    readonly version: FieldRef<"updates", 'String'>
    readonly release_time: FieldRef<"updates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * updates findUnique
   */
  export type updatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * Filter, which updates to fetch.
     */
    where: updatesWhereUniqueInput
  }

  /**
   * updates findUniqueOrThrow
   */
  export type updatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * Filter, which updates to fetch.
     */
    where: updatesWhereUniqueInput
  }

  /**
   * updates findFirst
   */
  export type updatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * Filter, which updates to fetch.
     */
    where?: updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of updates to fetch.
     */
    orderBy?: updatesOrderByWithRelationInput | updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for updates.
     */
    cursor?: updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of updates.
     */
    distinct?: UpdatesScalarFieldEnum | UpdatesScalarFieldEnum[]
  }

  /**
   * updates findFirstOrThrow
   */
  export type updatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * Filter, which updates to fetch.
     */
    where?: updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of updates to fetch.
     */
    orderBy?: updatesOrderByWithRelationInput | updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for updates.
     */
    cursor?: updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of updates.
     */
    distinct?: UpdatesScalarFieldEnum | UpdatesScalarFieldEnum[]
  }

  /**
   * updates findMany
   */
  export type updatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * Filter, which updates to fetch.
     */
    where?: updatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of updates to fetch.
     */
    orderBy?: updatesOrderByWithRelationInput | updatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing updates.
     */
    cursor?: updatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` updates.
     */
    skip?: number
    distinct?: UpdatesScalarFieldEnum | UpdatesScalarFieldEnum[]
  }

  /**
   * updates create
   */
  export type updatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * The data needed to create a updates.
     */
    data: XOR<updatesCreateInput, updatesUncheckedCreateInput>
  }

  /**
   * updates createMany
   */
  export type updatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many updates.
     */
    data: updatesCreateManyInput | updatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * updates update
   */
  export type updatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * The data needed to update a updates.
     */
    data: XOR<updatesUpdateInput, updatesUncheckedUpdateInput>
    /**
     * Choose, which updates to update.
     */
    where: updatesWhereUniqueInput
  }

  /**
   * updates updateMany
   */
  export type updatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update updates.
     */
    data: XOR<updatesUpdateManyMutationInput, updatesUncheckedUpdateManyInput>
    /**
     * Filter which updates to update
     */
    where?: updatesWhereInput
  }

  /**
   * updates upsert
   */
  export type updatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * The filter to search for the updates to update in case it exists.
     */
    where: updatesWhereUniqueInput
    /**
     * In case the updates found by the `where` argument doesn't exist, create a new updates with this data.
     */
    create: XOR<updatesCreateInput, updatesUncheckedCreateInput>
    /**
     * In case the updates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<updatesUpdateInput, updatesUncheckedUpdateInput>
  }

  /**
   * updates delete
   */
  export type updatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
    /**
     * Filter which updates to delete.
     */
    where: updatesWhereUniqueInput
  }

  /**
   * updates deleteMany
   */
  export type updatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which updates to delete
     */
    where?: updatesWhereInput
  }

  /**
   * updates without action
   */
  export type updatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the updates
     */
    select?: updatesSelect<ExtArgs> | null
  }


  /**
   * Model administrators
   */

  export type AggregateAdministrators = {
    _count: AdministratorsCountAggregateOutputType | null
    _min: AdministratorsMinAggregateOutputType | null
    _max: AdministratorsMaxAggregateOutputType | null
  }

  export type AdministratorsMinAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
  }

  export type AdministratorsMaxAggregateOutputType = {
    id: Uint8Array | null
    pesel: string | null
    email: string | null
    phone_number: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    reset_password_token: string | null
    reset_password_expires: Date | null
  }

  export type AdministratorsCountAggregateOutputType = {
    id: number
    pesel: number
    email: number
    phone_number: number
    password: number
    first_name: number
    last_name: number
    reset_password_token: number
    reset_password_expires: number
    _all: number
  }


  export type AdministratorsMinAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
  }

  export type AdministratorsMaxAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
  }

  export type AdministratorsCountAggregateInputType = {
    id?: true
    pesel?: true
    email?: true
    phone_number?: true
    password?: true
    first_name?: true
    last_name?: true
    reset_password_token?: true
    reset_password_expires?: true
    _all?: true
  }

  export type AdministratorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administrators to aggregate.
     */
    where?: administratorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrators to fetch.
     */
    orderBy?: administratorsOrderByWithRelationInput | administratorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: administratorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned administrators
    **/
    _count?: true | AdministratorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministratorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministratorsMaxAggregateInputType
  }

  export type GetAdministratorsAggregateType<T extends AdministratorsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrators]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrators[P]>
      : GetScalarType<T[P], AggregateAdministrators[P]>
  }




  export type administratorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: administratorsWhereInput
    orderBy?: administratorsOrderByWithAggregationInput | administratorsOrderByWithAggregationInput[]
    by: AdministratorsScalarFieldEnum[] | AdministratorsScalarFieldEnum
    having?: administratorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministratorsCountAggregateInputType | true
    _min?: AdministratorsMinAggregateInputType
    _max?: AdministratorsMaxAggregateInputType
  }

  export type AdministratorsGroupByOutputType = {
    id: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token: string | null
    reset_password_expires: Date | null
    _count: AdministratorsCountAggregateOutputType | null
    _min: AdministratorsMinAggregateOutputType | null
    _max: AdministratorsMaxAggregateOutputType | null
  }

  type GetAdministratorsGroupByPayload<T extends administratorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministratorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministratorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministratorsGroupByOutputType[P]>
            : GetScalarType<T[P], AdministratorsGroupByOutputType[P]>
        }
      >
    >


  export type administratorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
  }, ExtArgs["result"]["administrators"]>



  export type administratorsSelectScalar = {
    id?: boolean
    pesel?: boolean
    email?: boolean
    phone_number?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    reset_password_token?: boolean
    reset_password_expires?: boolean
  }


  export type $administratorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "administrators"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      pesel: string
      email: string
      phone_number: string
      password: string
      first_name: string
      last_name: string
      reset_password_token: string | null
      reset_password_expires: Date | null
    }, ExtArgs["result"]["administrators"]>
    composites: {}
  }

  type administratorsGetPayload<S extends boolean | null | undefined | administratorsDefaultArgs> = $Result.GetResult<Prisma.$administratorsPayload, S>

  type administratorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<administratorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdministratorsCountAggregateInputType | true
    }

  export interface administratorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['administrators'], meta: { name: 'administrators' } }
    /**
     * Find zero or one Administrators that matches the filter.
     * @param {administratorsFindUniqueArgs} args - Arguments to find a Administrators
     * @example
     * // Get one Administrators
     * const administrators = await prisma.administrators.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends administratorsFindUniqueArgs>(args: SelectSubset<T, administratorsFindUniqueArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Administrators that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {administratorsFindUniqueOrThrowArgs} args - Arguments to find a Administrators
     * @example
     * // Get one Administrators
     * const administrators = await prisma.administrators.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends administratorsFindUniqueOrThrowArgs>(args: SelectSubset<T, administratorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Administrators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administratorsFindFirstArgs} args - Arguments to find a Administrators
     * @example
     * // Get one Administrators
     * const administrators = await prisma.administrators.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends administratorsFindFirstArgs>(args?: SelectSubset<T, administratorsFindFirstArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Administrators that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administratorsFindFirstOrThrowArgs} args - Arguments to find a Administrators
     * @example
     * // Get one Administrators
     * const administrators = await prisma.administrators.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends administratorsFindFirstOrThrowArgs>(args?: SelectSubset<T, administratorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Administrators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administratorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administrators
     * const administrators = await prisma.administrators.findMany()
     * 
     * // Get first 10 Administrators
     * const administrators = await prisma.administrators.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const administratorsWithIdOnly = await prisma.administrators.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends administratorsFindManyArgs>(args?: SelectSubset<T, administratorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Administrators.
     * @param {administratorsCreateArgs} args - Arguments to create a Administrators.
     * @example
     * // Create one Administrators
     * const Administrators = await prisma.administrators.create({
     *   data: {
     *     // ... data to create a Administrators
     *   }
     * })
     * 
     */
    create<T extends administratorsCreateArgs>(args: SelectSubset<T, administratorsCreateArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Administrators.
     * @param {administratorsCreateManyArgs} args - Arguments to create many Administrators.
     * @example
     * // Create many Administrators
     * const administrators = await prisma.administrators.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends administratorsCreateManyArgs>(args?: SelectSubset<T, administratorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Administrators.
     * @param {administratorsDeleteArgs} args - Arguments to delete one Administrators.
     * @example
     * // Delete one Administrators
     * const Administrators = await prisma.administrators.delete({
     *   where: {
     *     // ... filter to delete one Administrators
     *   }
     * })
     * 
     */
    delete<T extends administratorsDeleteArgs>(args: SelectSubset<T, administratorsDeleteArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Administrators.
     * @param {administratorsUpdateArgs} args - Arguments to update one Administrators.
     * @example
     * // Update one Administrators
     * const administrators = await prisma.administrators.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends administratorsUpdateArgs>(args: SelectSubset<T, administratorsUpdateArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Administrators.
     * @param {administratorsDeleteManyArgs} args - Arguments to filter Administrators to delete.
     * @example
     * // Delete a few Administrators
     * const { count } = await prisma.administrators.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends administratorsDeleteManyArgs>(args?: SelectSubset<T, administratorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administratorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administrators
     * const administrators = await prisma.administrators.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends administratorsUpdateManyArgs>(args: SelectSubset<T, administratorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Administrators.
     * @param {administratorsUpsertArgs} args - Arguments to update or create a Administrators.
     * @example
     * // Update or create a Administrators
     * const administrators = await prisma.administrators.upsert({
     *   create: {
     *     // ... data to create a Administrators
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administrators we want to update
     *   }
     * })
     */
    upsert<T extends administratorsUpsertArgs>(args: SelectSubset<T, administratorsUpsertArgs<ExtArgs>>): Prisma__administratorsClient<$Result.GetResult<Prisma.$administratorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administratorsCountArgs} args - Arguments to filter Administrators to count.
     * @example
     * // Count the number of Administrators
     * const count = await prisma.administrators.count({
     *   where: {
     *     // ... the filter for the Administrators we want to count
     *   }
     * })
    **/
    count<T extends administratorsCountArgs>(
      args?: Subset<T, administratorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministratorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministratorsAggregateArgs>(args: Subset<T, AdministratorsAggregateArgs>): Prisma.PrismaPromise<GetAdministratorsAggregateType<T>>

    /**
     * Group by Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administratorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends administratorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: administratorsGroupByArgs['orderBy'] }
        : { orderBy?: administratorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, administratorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministratorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the administrators model
   */
  readonly fields: administratorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for administrators.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__administratorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the administrators model
   */ 
  interface administratorsFieldRefs {
    readonly id: FieldRef<"administrators", 'Bytes'>
    readonly pesel: FieldRef<"administrators", 'String'>
    readonly email: FieldRef<"administrators", 'String'>
    readonly phone_number: FieldRef<"administrators", 'String'>
    readonly password: FieldRef<"administrators", 'String'>
    readonly first_name: FieldRef<"administrators", 'String'>
    readonly last_name: FieldRef<"administrators", 'String'>
    readonly reset_password_token: FieldRef<"administrators", 'String'>
    readonly reset_password_expires: FieldRef<"administrators", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * administrators findUnique
   */
  export type administratorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * Filter, which administrators to fetch.
     */
    where: administratorsWhereUniqueInput
  }

  /**
   * administrators findUniqueOrThrow
   */
  export type administratorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * Filter, which administrators to fetch.
     */
    where: administratorsWhereUniqueInput
  }

  /**
   * administrators findFirst
   */
  export type administratorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * Filter, which administrators to fetch.
     */
    where?: administratorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrators to fetch.
     */
    orderBy?: administratorsOrderByWithRelationInput | administratorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administrators.
     */
    cursor?: administratorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administrators.
     */
    distinct?: AdministratorsScalarFieldEnum | AdministratorsScalarFieldEnum[]
  }

  /**
   * administrators findFirstOrThrow
   */
  export type administratorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * Filter, which administrators to fetch.
     */
    where?: administratorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrators to fetch.
     */
    orderBy?: administratorsOrderByWithRelationInput | administratorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administrators.
     */
    cursor?: administratorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administrators.
     */
    distinct?: AdministratorsScalarFieldEnum | AdministratorsScalarFieldEnum[]
  }

  /**
   * administrators findMany
   */
  export type administratorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * Filter, which administrators to fetch.
     */
    where?: administratorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrators to fetch.
     */
    orderBy?: administratorsOrderByWithRelationInput | administratorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing administrators.
     */
    cursor?: administratorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrators.
     */
    skip?: number
    distinct?: AdministratorsScalarFieldEnum | AdministratorsScalarFieldEnum[]
  }

  /**
   * administrators create
   */
  export type administratorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * The data needed to create a administrators.
     */
    data: XOR<administratorsCreateInput, administratorsUncheckedCreateInput>
  }

  /**
   * administrators createMany
   */
  export type administratorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many administrators.
     */
    data: administratorsCreateManyInput | administratorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * administrators update
   */
  export type administratorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * The data needed to update a administrators.
     */
    data: XOR<administratorsUpdateInput, administratorsUncheckedUpdateInput>
    /**
     * Choose, which administrators to update.
     */
    where: administratorsWhereUniqueInput
  }

  /**
   * administrators updateMany
   */
  export type administratorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update administrators.
     */
    data: XOR<administratorsUpdateManyMutationInput, administratorsUncheckedUpdateManyInput>
    /**
     * Filter which administrators to update
     */
    where?: administratorsWhereInput
  }

  /**
   * administrators upsert
   */
  export type administratorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * The filter to search for the administrators to update in case it exists.
     */
    where: administratorsWhereUniqueInput
    /**
     * In case the administrators found by the `where` argument doesn't exist, create a new administrators with this data.
     */
    create: XOR<administratorsCreateInput, administratorsUncheckedCreateInput>
    /**
     * In case the administrators was found with the provided `where` argument, update it with this data.
     */
    update: XOR<administratorsUpdateInput, administratorsUncheckedUpdateInput>
  }

  /**
   * administrators delete
   */
  export type administratorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
    /**
     * Filter which administrators to delete.
     */
    where: administratorsWhereUniqueInput
  }

  /**
   * administrators deleteMany
   */
  export type administratorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administrators to delete
     */
    where?: administratorsWhereInput
  }

  /**
   * administrators without action
   */
  export type administratorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrators
     */
    select?: administratorsSelect<ExtArgs> | null
  }


  /**
   * Model user_types
   */

  export type AggregateUser_types = {
    _count: User_typesCountAggregateOutputType | null
    _min: User_typesMinAggregateOutputType | null
    _max: User_typesMaxAggregateOutputType | null
  }

  export type User_typesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type User_typesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type User_typesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type User_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type User_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type User_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type User_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_types to aggregate.
     */
    where?: user_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typesOrderByWithRelationInput | user_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_types
    **/
    _count?: true | User_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_typesMaxAggregateInputType
  }

  export type GetUser_typesAggregateType<T extends User_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_types[P]>
      : GetScalarType<T[P], AggregateUser_types[P]>
  }




  export type user_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_typesWhereInput
    orderBy?: user_typesOrderByWithAggregationInput | user_typesOrderByWithAggregationInput[]
    by: User_typesScalarFieldEnum[] | User_typesScalarFieldEnum
    having?: user_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_typesCountAggregateInputType | true
    _min?: User_typesMinAggregateInputType
    _max?: User_typesMaxAggregateInputType
  }

  export type User_typesGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: User_typesCountAggregateOutputType | null
    _min: User_typesMinAggregateOutputType | null
    _max: User_typesMaxAggregateOutputType | null
  }

  type GetUser_typesGroupByPayload<T extends user_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_typesGroupByOutputType[P]>
            : GetScalarType<T[P], User_typesGroupByOutputType[P]>
        }
      >
    >


  export type user_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    messages_messages_sender_type_idTouser_types?: boolean | user_types$messages_messages_sender_type_idTouser_typesArgs<ExtArgs>
    messages_messages_receiver_type_idTouser_types?: boolean | user_types$messages_messages_receiver_type_idTouser_typesArgs<ExtArgs>
    problems_gradebook?: boolean | user_types$problems_gradebookArgs<ExtArgs>
    _count?: boolean | User_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_types"]>



  export type user_typesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type user_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages_messages_sender_type_idTouser_types?: boolean | user_types$messages_messages_sender_type_idTouser_typesArgs<ExtArgs>
    messages_messages_receiver_type_idTouser_types?: boolean | user_types$messages_messages_receiver_type_idTouser_typesArgs<ExtArgs>
    problems_gradebook?: boolean | user_types$problems_gradebookArgs<ExtArgs>
    _count?: boolean | User_typesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $user_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_types"
    objects: {
      messages_messages_sender_type_idTouser_types: Prisma.$messagesPayload<ExtArgs>[]
      messages_messages_receiver_type_idTouser_types: Prisma.$messagesPayload<ExtArgs>[]
      problems_gradebook: Prisma.$problems_gradebookPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["user_types"]>
    composites: {}
  }

  type user_typesGetPayload<S extends boolean | null | undefined | user_typesDefaultArgs> = $Result.GetResult<Prisma.$user_typesPayload, S>

  type user_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_typesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_typesCountAggregateInputType | true
    }

  export interface user_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_types'], meta: { name: 'user_types' } }
    /**
     * Find zero or one User_types that matches the filter.
     * @param {user_typesFindUniqueArgs} args - Arguments to find a User_types
     * @example
     * // Get one User_types
     * const user_types = await prisma.user_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_typesFindUniqueArgs>(args: SelectSubset<T, user_typesFindUniqueArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_typesFindUniqueOrThrowArgs} args - Arguments to find a User_types
     * @example
     * // Get one User_types
     * const user_types = await prisma.user_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typesFindFirstArgs} args - Arguments to find a User_types
     * @example
     * // Get one User_types
     * const user_types = await prisma.user_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_typesFindFirstArgs>(args?: SelectSubset<T, user_typesFindFirstArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typesFindFirstOrThrowArgs} args - Arguments to find a User_types
     * @example
     * // Get one User_types
     * const user_types = await prisma.user_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_types
     * const user_types = await prisma.user_types.findMany()
     * 
     * // Get first 10 User_types
     * const user_types = await prisma.user_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_typesWithIdOnly = await prisma.user_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_typesFindManyArgs>(args?: SelectSubset<T, user_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_types.
     * @param {user_typesCreateArgs} args - Arguments to create a User_types.
     * @example
     * // Create one User_types
     * const User_types = await prisma.user_types.create({
     *   data: {
     *     // ... data to create a User_types
     *   }
     * })
     * 
     */
    create<T extends user_typesCreateArgs>(args: SelectSubset<T, user_typesCreateArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_types.
     * @param {user_typesCreateManyArgs} args - Arguments to create many User_types.
     * @example
     * // Create many User_types
     * const user_types = await prisma.user_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_typesCreateManyArgs>(args?: SelectSubset<T, user_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_types.
     * @param {user_typesDeleteArgs} args - Arguments to delete one User_types.
     * @example
     * // Delete one User_types
     * const User_types = await prisma.user_types.delete({
     *   where: {
     *     // ... filter to delete one User_types
     *   }
     * })
     * 
     */
    delete<T extends user_typesDeleteArgs>(args: SelectSubset<T, user_typesDeleteArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_types.
     * @param {user_typesUpdateArgs} args - Arguments to update one User_types.
     * @example
     * // Update one User_types
     * const user_types = await prisma.user_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_typesUpdateArgs>(args: SelectSubset<T, user_typesUpdateArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_types.
     * @param {user_typesDeleteManyArgs} args - Arguments to filter User_types to delete.
     * @example
     * // Delete a few User_types
     * const { count } = await prisma.user_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_typesDeleteManyArgs>(args?: SelectSubset<T, user_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_types
     * const user_types = await prisma.user_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_typesUpdateManyArgs>(args: SelectSubset<T, user_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_types.
     * @param {user_typesUpsertArgs} args - Arguments to update or create a User_types.
     * @example
     * // Update or create a User_types
     * const user_types = await prisma.user_types.upsert({
     *   create: {
     *     // ... data to create a User_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_types we want to update
     *   }
     * })
     */
    upsert<T extends user_typesUpsertArgs>(args: SelectSubset<T, user_typesUpsertArgs<ExtArgs>>): Prisma__user_typesClient<$Result.GetResult<Prisma.$user_typesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typesCountArgs} args - Arguments to filter User_types to count.
     * @example
     * // Count the number of User_types
     * const count = await prisma.user_types.count({
     *   where: {
     *     // ... the filter for the User_types we want to count
     *   }
     * })
    **/
    count<T extends user_typesCountArgs>(
      args?: Subset<T, user_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_typesAggregateArgs>(args: Subset<T, User_typesAggregateArgs>): Prisma.PrismaPromise<GetUser_typesAggregateType<T>>

    /**
     * Group by User_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_typesGroupByArgs['orderBy'] }
        : { orderBy?: user_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_types model
   */
  readonly fields: user_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages_messages_sender_type_idTouser_types<T extends user_types$messages_messages_sender_type_idTouser_typesArgs<ExtArgs> = {}>(args?: Subset<T, user_types$messages_messages_sender_type_idTouser_typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany"> | Null>
    messages_messages_receiver_type_idTouser_types<T extends user_types$messages_messages_receiver_type_idTouser_typesArgs<ExtArgs> = {}>(args?: Subset<T, user_types$messages_messages_receiver_type_idTouser_typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany"> | Null>
    problems_gradebook<T extends user_types$problems_gradebookArgs<ExtArgs> = {}>(args?: Subset<T, user_types$problems_gradebookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$problems_gradebookPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_types model
   */ 
  interface user_typesFieldRefs {
    readonly id: FieldRef<"user_types", 'Bytes'>
    readonly name: FieldRef<"user_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_types findUnique
   */
  export type user_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * Filter, which user_types to fetch.
     */
    where: user_typesWhereUniqueInput
  }

  /**
   * user_types findUniqueOrThrow
   */
  export type user_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * Filter, which user_types to fetch.
     */
    where: user_typesWhereUniqueInput
  }

  /**
   * user_types findFirst
   */
  export type user_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * Filter, which user_types to fetch.
     */
    where?: user_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typesOrderByWithRelationInput | user_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_types.
     */
    cursor?: user_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_types.
     */
    distinct?: User_typesScalarFieldEnum | User_typesScalarFieldEnum[]
  }

  /**
   * user_types findFirstOrThrow
   */
  export type user_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * Filter, which user_types to fetch.
     */
    where?: user_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typesOrderByWithRelationInput | user_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_types.
     */
    cursor?: user_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_types.
     */
    distinct?: User_typesScalarFieldEnum | User_typesScalarFieldEnum[]
  }

  /**
   * user_types findMany
   */
  export type user_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * Filter, which user_types to fetch.
     */
    where?: user_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_types to fetch.
     */
    orderBy?: user_typesOrderByWithRelationInput | user_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_types.
     */
    cursor?: user_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
     */
    skip?: number
    distinct?: User_typesScalarFieldEnum | User_typesScalarFieldEnum[]
  }

  /**
   * user_types create
   */
  export type user_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_types.
     */
    data: XOR<user_typesCreateInput, user_typesUncheckedCreateInput>
  }

  /**
   * user_types createMany
   */
  export type user_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_types.
     */
    data: user_typesCreateManyInput | user_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_types update
   */
  export type user_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_types.
     */
    data: XOR<user_typesUpdateInput, user_typesUncheckedUpdateInput>
    /**
     * Choose, which user_types to update.
     */
    where: user_typesWhereUniqueInput
  }

  /**
   * user_types updateMany
   */
  export type user_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_types.
     */
    data: XOR<user_typesUpdateManyMutationInput, user_typesUncheckedUpdateManyInput>
    /**
     * Filter which user_types to update
     */
    where?: user_typesWhereInput
  }

  /**
   * user_types upsert
   */
  export type user_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_types to update in case it exists.
     */
    where: user_typesWhereUniqueInput
    /**
     * In case the user_types found by the `where` argument doesn't exist, create a new user_types with this data.
     */
    create: XOR<user_typesCreateInput, user_typesUncheckedCreateInput>
    /**
     * In case the user_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_typesUpdateInput, user_typesUncheckedUpdateInput>
  }

  /**
   * user_types delete
   */
  export type user_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
    /**
     * Filter which user_types to delete.
     */
    where: user_typesWhereUniqueInput
  }

  /**
   * user_types deleteMany
   */
  export type user_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_types to delete
     */
    where?: user_typesWhereInput
  }

  /**
   * user_types.messages_messages_sender_type_idTouser_types
   */
  export type user_types$messages_messages_sender_type_idTouser_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * user_types.messages_messages_receiver_type_idTouser_types
   */
  export type user_types$messages_messages_receiver_type_idTouser_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * user_types.problems_gradebook
   */
  export type user_types$problems_gradebookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the problems_gradebook
     */
    select?: problems_gradebookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: problems_gradebookInclude<ExtArgs> | null
    where?: problems_gradebookWhereInput
    orderBy?: problems_gradebookOrderByWithRelationInput | problems_gradebookOrderByWithRelationInput[]
    cursor?: problems_gradebookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Problems_gradebookScalarFieldEnum | Problems_gradebookScalarFieldEnum[]
  }

  /**
   * user_types without action
   */
  export type user_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_types
     */
    select?: user_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_typesInclude<ExtArgs> | null
  }


  /**
   * Model school_years
   */

  export type AggregateSchool_years = {
    _count: School_yearsCountAggregateOutputType | null
    _min: School_yearsMinAggregateOutputType | null
    _max: School_yearsMaxAggregateOutputType | null
  }

  export type School_yearsMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    start_date: Date | null
    end_date: Date | null
  }

  export type School_yearsMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    start_date: Date | null
    end_date: Date | null
  }

  export type School_yearsCountAggregateOutputType = {
    id: number
    name: number
    start_date: number
    end_date: number
    _all: number
  }


  export type School_yearsMinAggregateInputType = {
    id?: true
    name?: true
    start_date?: true
    end_date?: true
  }

  export type School_yearsMaxAggregateInputType = {
    id?: true
    name?: true
    start_date?: true
    end_date?: true
  }

  export type School_yearsCountAggregateInputType = {
    id?: true
    name?: true
    start_date?: true
    end_date?: true
    _all?: true
  }

  export type School_yearsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_years to aggregate.
     */
    where?: school_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_years to fetch.
     */
    orderBy?: school_yearsOrderByWithRelationInput | school_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: school_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned school_years
    **/
    _count?: true | School_yearsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: School_yearsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: School_yearsMaxAggregateInputType
  }

  export type GetSchool_yearsAggregateType<T extends School_yearsAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool_years]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool_years[P]>
      : GetScalarType<T[P], AggregateSchool_years[P]>
  }




  export type school_yearsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_yearsWhereInput
    orderBy?: school_yearsOrderByWithAggregationInput | school_yearsOrderByWithAggregationInput[]
    by: School_yearsScalarFieldEnum[] | School_yearsScalarFieldEnum
    having?: school_yearsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: School_yearsCountAggregateInputType | true
    _min?: School_yearsMinAggregateInputType
    _max?: School_yearsMaxAggregateInputType
  }

  export type School_yearsGroupByOutputType = {
    id: Uint8Array
    name: string
    start_date: Date
    end_date: Date
    _count: School_yearsCountAggregateOutputType | null
    _min: School_yearsMinAggregateOutputType | null
    _max: School_yearsMaxAggregateOutputType | null
  }

  type GetSchool_yearsGroupByPayload<T extends school_yearsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<School_yearsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof School_yearsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], School_yearsGroupByOutputType[P]>
            : GetScalarType<T[P], School_yearsGroupByOutputType[P]>
        }
      >
    >


  export type school_yearsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    start_date?: boolean
    end_date?: boolean
    classes?: boolean | school_years$classesArgs<ExtArgs>
    semesters?: boolean | school_years$semestersArgs<ExtArgs>
    _count?: boolean | School_yearsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school_years"]>



  export type school_yearsSelectScalar = {
    id?: boolean
    name?: boolean
    start_date?: boolean
    end_date?: boolean
  }

  export type school_yearsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | school_years$classesArgs<ExtArgs>
    semesters?: boolean | school_years$semestersArgs<ExtArgs>
    _count?: boolean | School_yearsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $school_yearsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "school_years"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>[]
      semesters: Prisma.$semestersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
      start_date: Date
      end_date: Date
    }, ExtArgs["result"]["school_years"]>
    composites: {}
  }

  type school_yearsGetPayload<S extends boolean | null | undefined | school_yearsDefaultArgs> = $Result.GetResult<Prisma.$school_yearsPayload, S>

  type school_yearsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<school_yearsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: School_yearsCountAggregateInputType | true
    }

  export interface school_yearsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['school_years'], meta: { name: 'school_years' } }
    /**
     * Find zero or one School_years that matches the filter.
     * @param {school_yearsFindUniqueArgs} args - Arguments to find a School_years
     * @example
     * // Get one School_years
     * const school_years = await prisma.school_years.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends school_yearsFindUniqueArgs>(args: SelectSubset<T, school_yearsFindUniqueArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one School_years that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {school_yearsFindUniqueOrThrowArgs} args - Arguments to find a School_years
     * @example
     * // Get one School_years
     * const school_years = await prisma.school_years.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends school_yearsFindUniqueOrThrowArgs>(args: SelectSubset<T, school_yearsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first School_years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_yearsFindFirstArgs} args - Arguments to find a School_years
     * @example
     * // Get one School_years
     * const school_years = await prisma.school_years.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends school_yearsFindFirstArgs>(args?: SelectSubset<T, school_yearsFindFirstArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first School_years that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_yearsFindFirstOrThrowArgs} args - Arguments to find a School_years
     * @example
     * // Get one School_years
     * const school_years = await prisma.school_years.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends school_yearsFindFirstOrThrowArgs>(args?: SelectSubset<T, school_yearsFindFirstOrThrowArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more School_years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_yearsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all School_years
     * const school_years = await prisma.school_years.findMany()
     * 
     * // Get first 10 School_years
     * const school_years = await prisma.school_years.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const school_yearsWithIdOnly = await prisma.school_years.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends school_yearsFindManyArgs>(args?: SelectSubset<T, school_yearsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a School_years.
     * @param {school_yearsCreateArgs} args - Arguments to create a School_years.
     * @example
     * // Create one School_years
     * const School_years = await prisma.school_years.create({
     *   data: {
     *     // ... data to create a School_years
     *   }
     * })
     * 
     */
    create<T extends school_yearsCreateArgs>(args: SelectSubset<T, school_yearsCreateArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many School_years.
     * @param {school_yearsCreateManyArgs} args - Arguments to create many School_years.
     * @example
     * // Create many School_years
     * const school_years = await prisma.school_years.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends school_yearsCreateManyArgs>(args?: SelectSubset<T, school_yearsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School_years.
     * @param {school_yearsDeleteArgs} args - Arguments to delete one School_years.
     * @example
     * // Delete one School_years
     * const School_years = await prisma.school_years.delete({
     *   where: {
     *     // ... filter to delete one School_years
     *   }
     * })
     * 
     */
    delete<T extends school_yearsDeleteArgs>(args: SelectSubset<T, school_yearsDeleteArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one School_years.
     * @param {school_yearsUpdateArgs} args - Arguments to update one School_years.
     * @example
     * // Update one School_years
     * const school_years = await prisma.school_years.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends school_yearsUpdateArgs>(args: SelectSubset<T, school_yearsUpdateArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more School_years.
     * @param {school_yearsDeleteManyArgs} args - Arguments to filter School_years to delete.
     * @example
     * // Delete a few School_years
     * const { count } = await prisma.school_years.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends school_yearsDeleteManyArgs>(args?: SelectSubset<T, school_yearsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more School_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_yearsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many School_years
     * const school_years = await prisma.school_years.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends school_yearsUpdateManyArgs>(args: SelectSubset<T, school_yearsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School_years.
     * @param {school_yearsUpsertArgs} args - Arguments to update or create a School_years.
     * @example
     * // Update or create a School_years
     * const school_years = await prisma.school_years.upsert({
     *   create: {
     *     // ... data to create a School_years
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School_years we want to update
     *   }
     * })
     */
    upsert<T extends school_yearsUpsertArgs>(args: SelectSubset<T, school_yearsUpsertArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of School_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_yearsCountArgs} args - Arguments to filter School_years to count.
     * @example
     * // Count the number of School_years
     * const count = await prisma.school_years.count({
     *   where: {
     *     // ... the filter for the School_years we want to count
     *   }
     * })
    **/
    count<T extends school_yearsCountArgs>(
      args?: Subset<T, school_yearsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], School_yearsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {School_yearsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends School_yearsAggregateArgs>(args: Subset<T, School_yearsAggregateArgs>): Prisma.PrismaPromise<GetSchool_yearsAggregateType<T>>

    /**
     * Group by School_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_yearsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends school_yearsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: school_yearsGroupByArgs['orderBy'] }
        : { orderBy?: school_yearsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, school_yearsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchool_yearsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the school_years model
   */
  readonly fields: school_yearsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for school_years.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__school_yearsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends school_years$classesArgs<ExtArgs> = {}>(args?: Subset<T, school_years$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany"> | Null>
    semesters<T extends school_years$semestersArgs<ExtArgs> = {}>(args?: Subset<T, school_years$semestersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the school_years model
   */ 
  interface school_yearsFieldRefs {
    readonly id: FieldRef<"school_years", 'Bytes'>
    readonly name: FieldRef<"school_years", 'String'>
    readonly start_date: FieldRef<"school_years", 'DateTime'>
    readonly end_date: FieldRef<"school_years", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * school_years findUnique
   */
  export type school_yearsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * Filter, which school_years to fetch.
     */
    where: school_yearsWhereUniqueInput
  }

  /**
   * school_years findUniqueOrThrow
   */
  export type school_yearsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * Filter, which school_years to fetch.
     */
    where: school_yearsWhereUniqueInput
  }

  /**
   * school_years findFirst
   */
  export type school_yearsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * Filter, which school_years to fetch.
     */
    where?: school_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_years to fetch.
     */
    orderBy?: school_yearsOrderByWithRelationInput | school_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_years.
     */
    cursor?: school_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_years.
     */
    distinct?: School_yearsScalarFieldEnum | School_yearsScalarFieldEnum[]
  }

  /**
   * school_years findFirstOrThrow
   */
  export type school_yearsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * Filter, which school_years to fetch.
     */
    where?: school_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_years to fetch.
     */
    orderBy?: school_yearsOrderByWithRelationInput | school_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_years.
     */
    cursor?: school_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_years.
     */
    distinct?: School_yearsScalarFieldEnum | School_yearsScalarFieldEnum[]
  }

  /**
   * school_years findMany
   */
  export type school_yearsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * Filter, which school_years to fetch.
     */
    where?: school_yearsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_years to fetch.
     */
    orderBy?: school_yearsOrderByWithRelationInput | school_yearsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing school_years.
     */
    cursor?: school_yearsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_years.
     */
    skip?: number
    distinct?: School_yearsScalarFieldEnum | School_yearsScalarFieldEnum[]
  }

  /**
   * school_years create
   */
  export type school_yearsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * The data needed to create a school_years.
     */
    data: XOR<school_yearsCreateInput, school_yearsUncheckedCreateInput>
  }

  /**
   * school_years createMany
   */
  export type school_yearsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many school_years.
     */
    data: school_yearsCreateManyInput | school_yearsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * school_years update
   */
  export type school_yearsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * The data needed to update a school_years.
     */
    data: XOR<school_yearsUpdateInput, school_yearsUncheckedUpdateInput>
    /**
     * Choose, which school_years to update.
     */
    where: school_yearsWhereUniqueInput
  }

  /**
   * school_years updateMany
   */
  export type school_yearsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update school_years.
     */
    data: XOR<school_yearsUpdateManyMutationInput, school_yearsUncheckedUpdateManyInput>
    /**
     * Filter which school_years to update
     */
    where?: school_yearsWhereInput
  }

  /**
   * school_years upsert
   */
  export type school_yearsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * The filter to search for the school_years to update in case it exists.
     */
    where: school_yearsWhereUniqueInput
    /**
     * In case the school_years found by the `where` argument doesn't exist, create a new school_years with this data.
     */
    create: XOR<school_yearsCreateInput, school_yearsUncheckedCreateInput>
    /**
     * In case the school_years was found with the provided `where` argument, update it with this data.
     */
    update: XOR<school_yearsUpdateInput, school_yearsUncheckedUpdateInput>
  }

  /**
   * school_years delete
   */
  export type school_yearsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
    /**
     * Filter which school_years to delete.
     */
    where: school_yearsWhereUniqueInput
  }

  /**
   * school_years deleteMany
   */
  export type school_yearsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_years to delete
     */
    where?: school_yearsWhereInput
  }

  /**
   * school_years.classes
   */
  export type school_years$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    where?: classesWhereInput
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    cursor?: classesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * school_years.semesters
   */
  export type school_years$semestersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    where?: semestersWhereInput
    orderBy?: semestersOrderByWithRelationInput | semestersOrderByWithRelationInput[]
    cursor?: semestersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemestersScalarFieldEnum | SemestersScalarFieldEnum[]
  }

  /**
   * school_years without action
   */
  export type school_yearsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_years
     */
    select?: school_yearsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_yearsInclude<ExtArgs> | null
  }


  /**
   * Model semesters
   */

  export type AggregateSemesters = {
    _count: SemestersCountAggregateOutputType | null
    _avg: SemestersAvgAggregateOutputType | null
    _sum: SemestersSumAggregateOutputType | null
    _min: SemestersMinAggregateOutputType | null
    _max: SemestersMaxAggregateOutputType | null
  }

  export type SemestersAvgAggregateOutputType = {
    semester: number | null
  }

  export type SemestersSumAggregateOutputType = {
    semester: number | null
  }

  export type SemestersMinAggregateOutputType = {
    id: Uint8Array | null
    semester: number | null
    start_date: Date | null
    end_date: Date | null
    school_year_id: Uint8Array | null
  }

  export type SemestersMaxAggregateOutputType = {
    id: Uint8Array | null
    semester: number | null
    start_date: Date | null
    end_date: Date | null
    school_year_id: Uint8Array | null
  }

  export type SemestersCountAggregateOutputType = {
    id: number
    semester: number
    start_date: number
    end_date: number
    school_year_id: number
    _all: number
  }


  export type SemestersAvgAggregateInputType = {
    semester?: true
  }

  export type SemestersSumAggregateInputType = {
    semester?: true
  }

  export type SemestersMinAggregateInputType = {
    id?: true
    semester?: true
    start_date?: true
    end_date?: true
    school_year_id?: true
  }

  export type SemestersMaxAggregateInputType = {
    id?: true
    semester?: true
    start_date?: true
    end_date?: true
    school_year_id?: true
  }

  export type SemestersCountAggregateInputType = {
    id?: true
    semester?: true
    start_date?: true
    end_date?: true
    school_year_id?: true
    _all?: true
  }

  export type SemestersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which semesters to aggregate.
     */
    where?: semestersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semestersOrderByWithRelationInput | semestersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: semestersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned semesters
    **/
    _count?: true | SemestersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemestersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemestersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemestersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemestersMaxAggregateInputType
  }

  export type GetSemestersAggregateType<T extends SemestersAggregateArgs> = {
        [P in keyof T & keyof AggregateSemesters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemesters[P]>
      : GetScalarType<T[P], AggregateSemesters[P]>
  }




  export type semestersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: semestersWhereInput
    orderBy?: semestersOrderByWithAggregationInput | semestersOrderByWithAggregationInput[]
    by: SemestersScalarFieldEnum[] | SemestersScalarFieldEnum
    having?: semestersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemestersCountAggregateInputType | true
    _avg?: SemestersAvgAggregateInputType
    _sum?: SemestersSumAggregateInputType
    _min?: SemestersMinAggregateInputType
    _max?: SemestersMaxAggregateInputType
  }

  export type SemestersGroupByOutputType = {
    id: Uint8Array
    semester: number
    start_date: Date
    end_date: Date
    school_year_id: Uint8Array
    _count: SemestersCountAggregateOutputType | null
    _avg: SemestersAvgAggregateOutputType | null
    _sum: SemestersSumAggregateOutputType | null
    _min: SemestersMinAggregateOutputType | null
    _max: SemestersMaxAggregateOutputType | null
  }

  type GetSemestersGroupByPayload<T extends semestersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemestersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemestersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemestersGroupByOutputType[P]>
            : GetScalarType<T[P], SemestersGroupByOutputType[P]>
        }
      >
    >


  export type semestersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    semester?: boolean
    start_date?: boolean
    end_date?: boolean
    school_year_id?: boolean
    final_grades?: boolean | semesters$final_gradesArgs<ExtArgs>
    school_years?: boolean | school_yearsDefaultArgs<ExtArgs>
    _count?: boolean | SemestersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semesters"]>



  export type semestersSelectScalar = {
    id?: boolean
    semester?: boolean
    start_date?: boolean
    end_date?: boolean
    school_year_id?: boolean
  }

  export type semestersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grades?: boolean | semesters$final_gradesArgs<ExtArgs>
    school_years?: boolean | school_yearsDefaultArgs<ExtArgs>
    _count?: boolean | SemestersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $semestersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "semesters"
    objects: {
      final_grades: Prisma.$final_gradesPayload<ExtArgs>[]
      school_years: Prisma.$school_yearsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      semester: number
      start_date: Date
      end_date: Date
      school_year_id: Uint8Array
    }, ExtArgs["result"]["semesters"]>
    composites: {}
  }

  type semestersGetPayload<S extends boolean | null | undefined | semestersDefaultArgs> = $Result.GetResult<Prisma.$semestersPayload, S>

  type semestersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<semestersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SemestersCountAggregateInputType | true
    }

  export interface semestersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['semesters'], meta: { name: 'semesters' } }
    /**
     * Find zero or one Semesters that matches the filter.
     * @param {semestersFindUniqueArgs} args - Arguments to find a Semesters
     * @example
     * // Get one Semesters
     * const semesters = await prisma.semesters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends semestersFindUniqueArgs>(args: SelectSubset<T, semestersFindUniqueArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Semesters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {semestersFindUniqueOrThrowArgs} args - Arguments to find a Semesters
     * @example
     * // Get one Semesters
     * const semesters = await prisma.semesters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends semestersFindUniqueOrThrowArgs>(args: SelectSubset<T, semestersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Semesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semestersFindFirstArgs} args - Arguments to find a Semesters
     * @example
     * // Get one Semesters
     * const semesters = await prisma.semesters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends semestersFindFirstArgs>(args?: SelectSubset<T, semestersFindFirstArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Semesters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semestersFindFirstOrThrowArgs} args - Arguments to find a Semesters
     * @example
     * // Get one Semesters
     * const semesters = await prisma.semesters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends semestersFindFirstOrThrowArgs>(args?: SelectSubset<T, semestersFindFirstOrThrowArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Semesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semestersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Semesters
     * const semesters = await prisma.semesters.findMany()
     * 
     * // Get first 10 Semesters
     * const semesters = await prisma.semesters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semestersWithIdOnly = await prisma.semesters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends semestersFindManyArgs>(args?: SelectSubset<T, semestersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Semesters.
     * @param {semestersCreateArgs} args - Arguments to create a Semesters.
     * @example
     * // Create one Semesters
     * const Semesters = await prisma.semesters.create({
     *   data: {
     *     // ... data to create a Semesters
     *   }
     * })
     * 
     */
    create<T extends semestersCreateArgs>(args: SelectSubset<T, semestersCreateArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Semesters.
     * @param {semestersCreateManyArgs} args - Arguments to create many Semesters.
     * @example
     * // Create many Semesters
     * const semesters = await prisma.semesters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends semestersCreateManyArgs>(args?: SelectSubset<T, semestersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Semesters.
     * @param {semestersDeleteArgs} args - Arguments to delete one Semesters.
     * @example
     * // Delete one Semesters
     * const Semesters = await prisma.semesters.delete({
     *   where: {
     *     // ... filter to delete one Semesters
     *   }
     * })
     * 
     */
    delete<T extends semestersDeleteArgs>(args: SelectSubset<T, semestersDeleteArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Semesters.
     * @param {semestersUpdateArgs} args - Arguments to update one Semesters.
     * @example
     * // Update one Semesters
     * const semesters = await prisma.semesters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends semestersUpdateArgs>(args: SelectSubset<T, semestersUpdateArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Semesters.
     * @param {semestersDeleteManyArgs} args - Arguments to filter Semesters to delete.
     * @example
     * // Delete a few Semesters
     * const { count } = await prisma.semesters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends semestersDeleteManyArgs>(args?: SelectSubset<T, semestersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semestersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Semesters
     * const semesters = await prisma.semesters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends semestersUpdateManyArgs>(args: SelectSubset<T, semestersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Semesters.
     * @param {semestersUpsertArgs} args - Arguments to update or create a Semesters.
     * @example
     * // Update or create a Semesters
     * const semesters = await prisma.semesters.upsert({
     *   create: {
     *     // ... data to create a Semesters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Semesters we want to update
     *   }
     * })
     */
    upsert<T extends semestersUpsertArgs>(args: SelectSubset<T, semestersUpsertArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semestersCountArgs} args - Arguments to filter Semesters to count.
     * @example
     * // Count the number of Semesters
     * const count = await prisma.semesters.count({
     *   where: {
     *     // ... the filter for the Semesters we want to count
     *   }
     * })
    **/
    count<T extends semestersCountArgs>(
      args?: Subset<T, semestersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemestersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemestersAggregateArgs>(args: Subset<T, SemestersAggregateArgs>): Prisma.PrismaPromise<GetSemestersAggregateType<T>>

    /**
     * Group by Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semestersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends semestersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: semestersGroupByArgs['orderBy'] }
        : { orderBy?: semestersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, semestersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemestersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the semesters model
   */
  readonly fields: semestersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for semesters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__semestersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    final_grades<T extends semesters$final_gradesArgs<ExtArgs> = {}>(args?: Subset<T, semesters$final_gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findMany"> | Null>
    school_years<T extends school_yearsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, school_yearsDefaultArgs<ExtArgs>>): Prisma__school_yearsClient<$Result.GetResult<Prisma.$school_yearsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the semesters model
   */ 
  interface semestersFieldRefs {
    readonly id: FieldRef<"semesters", 'Bytes'>
    readonly semester: FieldRef<"semesters", 'Int'>
    readonly start_date: FieldRef<"semesters", 'DateTime'>
    readonly end_date: FieldRef<"semesters", 'DateTime'>
    readonly school_year_id: FieldRef<"semesters", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * semesters findUnique
   */
  export type semestersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * Filter, which semesters to fetch.
     */
    where: semestersWhereUniqueInput
  }

  /**
   * semesters findUniqueOrThrow
   */
  export type semestersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * Filter, which semesters to fetch.
     */
    where: semestersWhereUniqueInput
  }

  /**
   * semesters findFirst
   */
  export type semestersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * Filter, which semesters to fetch.
     */
    where?: semestersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semestersOrderByWithRelationInput | semestersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for semesters.
     */
    cursor?: semestersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of semesters.
     */
    distinct?: SemestersScalarFieldEnum | SemestersScalarFieldEnum[]
  }

  /**
   * semesters findFirstOrThrow
   */
  export type semestersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * Filter, which semesters to fetch.
     */
    where?: semestersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semestersOrderByWithRelationInput | semestersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for semesters.
     */
    cursor?: semestersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of semesters.
     */
    distinct?: SemestersScalarFieldEnum | SemestersScalarFieldEnum[]
  }

  /**
   * semesters findMany
   */
  export type semestersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * Filter, which semesters to fetch.
     */
    where?: semestersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semestersOrderByWithRelationInput | semestersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing semesters.
     */
    cursor?: semestersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    distinct?: SemestersScalarFieldEnum | SemestersScalarFieldEnum[]
  }

  /**
   * semesters create
   */
  export type semestersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * The data needed to create a semesters.
     */
    data: XOR<semestersCreateInput, semestersUncheckedCreateInput>
  }

  /**
   * semesters createMany
   */
  export type semestersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many semesters.
     */
    data: semestersCreateManyInput | semestersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * semesters update
   */
  export type semestersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * The data needed to update a semesters.
     */
    data: XOR<semestersUpdateInput, semestersUncheckedUpdateInput>
    /**
     * Choose, which semesters to update.
     */
    where: semestersWhereUniqueInput
  }

  /**
   * semesters updateMany
   */
  export type semestersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update semesters.
     */
    data: XOR<semestersUpdateManyMutationInput, semestersUncheckedUpdateManyInput>
    /**
     * Filter which semesters to update
     */
    where?: semestersWhereInput
  }

  /**
   * semesters upsert
   */
  export type semestersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * The filter to search for the semesters to update in case it exists.
     */
    where: semestersWhereUniqueInput
    /**
     * In case the semesters found by the `where` argument doesn't exist, create a new semesters with this data.
     */
    create: XOR<semestersCreateInput, semestersUncheckedCreateInput>
    /**
     * In case the semesters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<semestersUpdateInput, semestersUncheckedUpdateInput>
  }

  /**
   * semesters delete
   */
  export type semestersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
    /**
     * Filter which semesters to delete.
     */
    where: semestersWhereUniqueInput
  }

  /**
   * semesters deleteMany
   */
  export type semestersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which semesters to delete
     */
    where?: semestersWhereInput
  }

  /**
   * semesters.final_grades
   */
  export type semesters$final_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    where?: final_gradesWhereInput
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    cursor?: final_gradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Final_gradesScalarFieldEnum | Final_gradesScalarFieldEnum[]
  }

  /**
   * semesters without action
   */
  export type semestersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semesters
     */
    select?: semestersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semestersInclude<ExtArgs> | null
  }


  /**
   * Model class_names
   */

  export type AggregateClass_names = {
    _count: Class_namesCountAggregateOutputType | null
    _min: Class_namesMinAggregateOutputType | null
    _max: Class_namesMaxAggregateOutputType | null
  }

  export type Class_namesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Class_namesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Class_namesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Class_namesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Class_namesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Class_namesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Class_namesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_names to aggregate.
     */
    where?: class_namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_names to fetch.
     */
    orderBy?: class_namesOrderByWithRelationInput | class_namesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: class_namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_names from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_names.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned class_names
    **/
    _count?: true | Class_namesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Class_namesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Class_namesMaxAggregateInputType
  }

  export type GetClass_namesAggregateType<T extends Class_namesAggregateArgs> = {
        [P in keyof T & keyof AggregateClass_names]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass_names[P]>
      : GetScalarType<T[P], AggregateClass_names[P]>
  }




  export type class_namesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_namesWhereInput
    orderBy?: class_namesOrderByWithAggregationInput | class_namesOrderByWithAggregationInput[]
    by: Class_namesScalarFieldEnum[] | Class_namesScalarFieldEnum
    having?: class_namesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Class_namesCountAggregateInputType | true
    _min?: Class_namesMinAggregateInputType
    _max?: Class_namesMaxAggregateInputType
  }

  export type Class_namesGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: Class_namesCountAggregateOutputType | null
    _min: Class_namesMinAggregateOutputType | null
    _max: Class_namesMaxAggregateOutputType | null
  }

  type GetClass_namesGroupByPayload<T extends class_namesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Class_namesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Class_namesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Class_namesGroupByOutputType[P]>
            : GetScalarType<T[P], Class_namesGroupByOutputType[P]>
        }
      >
    >


  export type class_namesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    classes?: boolean | class_names$classesArgs<ExtArgs>
    _count?: boolean | Class_namesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class_names"]>



  export type class_namesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type class_namesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | class_names$classesArgs<ExtArgs>
    _count?: boolean | Class_namesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $class_namesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "class_names"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["class_names"]>
    composites: {}
  }

  type class_namesGetPayload<S extends boolean | null | undefined | class_namesDefaultArgs> = $Result.GetResult<Prisma.$class_namesPayload, S>

  type class_namesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<class_namesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Class_namesCountAggregateInputType | true
    }

  export interface class_namesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['class_names'], meta: { name: 'class_names' } }
    /**
     * Find zero or one Class_names that matches the filter.
     * @param {class_namesFindUniqueArgs} args - Arguments to find a Class_names
     * @example
     * // Get one Class_names
     * const class_names = await prisma.class_names.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends class_namesFindUniqueArgs>(args: SelectSubset<T, class_namesFindUniqueArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Class_names that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {class_namesFindUniqueOrThrowArgs} args - Arguments to find a Class_names
     * @example
     * // Get one Class_names
     * const class_names = await prisma.class_names.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends class_namesFindUniqueOrThrowArgs>(args: SelectSubset<T, class_namesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Class_names that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_namesFindFirstArgs} args - Arguments to find a Class_names
     * @example
     * // Get one Class_names
     * const class_names = await prisma.class_names.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends class_namesFindFirstArgs>(args?: SelectSubset<T, class_namesFindFirstArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Class_names that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_namesFindFirstOrThrowArgs} args - Arguments to find a Class_names
     * @example
     * // Get one Class_names
     * const class_names = await prisma.class_names.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends class_namesFindFirstOrThrowArgs>(args?: SelectSubset<T, class_namesFindFirstOrThrowArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Class_names that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_namesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Class_names
     * const class_names = await prisma.class_names.findMany()
     * 
     * // Get first 10 Class_names
     * const class_names = await prisma.class_names.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const class_namesWithIdOnly = await prisma.class_names.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends class_namesFindManyArgs>(args?: SelectSubset<T, class_namesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Class_names.
     * @param {class_namesCreateArgs} args - Arguments to create a Class_names.
     * @example
     * // Create one Class_names
     * const Class_names = await prisma.class_names.create({
     *   data: {
     *     // ... data to create a Class_names
     *   }
     * })
     * 
     */
    create<T extends class_namesCreateArgs>(args: SelectSubset<T, class_namesCreateArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Class_names.
     * @param {class_namesCreateManyArgs} args - Arguments to create many Class_names.
     * @example
     * // Create many Class_names
     * const class_names = await prisma.class_names.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends class_namesCreateManyArgs>(args?: SelectSubset<T, class_namesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Class_names.
     * @param {class_namesDeleteArgs} args - Arguments to delete one Class_names.
     * @example
     * // Delete one Class_names
     * const Class_names = await prisma.class_names.delete({
     *   where: {
     *     // ... filter to delete one Class_names
     *   }
     * })
     * 
     */
    delete<T extends class_namesDeleteArgs>(args: SelectSubset<T, class_namesDeleteArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Class_names.
     * @param {class_namesUpdateArgs} args - Arguments to update one Class_names.
     * @example
     * // Update one Class_names
     * const class_names = await prisma.class_names.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends class_namesUpdateArgs>(args: SelectSubset<T, class_namesUpdateArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Class_names.
     * @param {class_namesDeleteManyArgs} args - Arguments to filter Class_names to delete.
     * @example
     * // Delete a few Class_names
     * const { count } = await prisma.class_names.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends class_namesDeleteManyArgs>(args?: SelectSubset<T, class_namesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_namesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Class_names
     * const class_names = await prisma.class_names.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends class_namesUpdateManyArgs>(args: SelectSubset<T, class_namesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class_names.
     * @param {class_namesUpsertArgs} args - Arguments to update or create a Class_names.
     * @example
     * // Update or create a Class_names
     * const class_names = await prisma.class_names.upsert({
     *   create: {
     *     // ... data to create a Class_names
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class_names we want to update
     *   }
     * })
     */
    upsert<T extends class_namesUpsertArgs>(args: SelectSubset<T, class_namesUpsertArgs<ExtArgs>>): Prisma__class_namesClient<$Result.GetResult<Prisma.$class_namesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Class_names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_namesCountArgs} args - Arguments to filter Class_names to count.
     * @example
     * // Count the number of Class_names
     * const count = await prisma.class_names.count({
     *   where: {
     *     // ... the filter for the Class_names we want to count
     *   }
     * })
    **/
    count<T extends class_namesCountArgs>(
      args?: Subset<T, class_namesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Class_namesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class_names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Class_namesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Class_namesAggregateArgs>(args: Subset<T, Class_namesAggregateArgs>): Prisma.PrismaPromise<GetClass_namesAggregateType<T>>

    /**
     * Group by Class_names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_namesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends class_namesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: class_namesGroupByArgs['orderBy'] }
        : { orderBy?: class_namesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, class_namesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClass_namesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the class_names model
   */
  readonly fields: class_namesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for class_names.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__class_namesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends class_names$classesArgs<ExtArgs> = {}>(args?: Subset<T, class_names$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the class_names model
   */ 
  interface class_namesFieldRefs {
    readonly id: FieldRef<"class_names", 'Bytes'>
    readonly name: FieldRef<"class_names", 'String'>
  }
    

  // Custom InputTypes
  /**
   * class_names findUnique
   */
  export type class_namesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * Filter, which class_names to fetch.
     */
    where: class_namesWhereUniqueInput
  }

  /**
   * class_names findUniqueOrThrow
   */
  export type class_namesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * Filter, which class_names to fetch.
     */
    where: class_namesWhereUniqueInput
  }

  /**
   * class_names findFirst
   */
  export type class_namesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * Filter, which class_names to fetch.
     */
    where?: class_namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_names to fetch.
     */
    orderBy?: class_namesOrderByWithRelationInput | class_namesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_names.
     */
    cursor?: class_namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_names from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_names.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_names.
     */
    distinct?: Class_namesScalarFieldEnum | Class_namesScalarFieldEnum[]
  }

  /**
   * class_names findFirstOrThrow
   */
  export type class_namesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * Filter, which class_names to fetch.
     */
    where?: class_namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_names to fetch.
     */
    orderBy?: class_namesOrderByWithRelationInput | class_namesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_names.
     */
    cursor?: class_namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_names from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_names.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_names.
     */
    distinct?: Class_namesScalarFieldEnum | Class_namesScalarFieldEnum[]
  }

  /**
   * class_names findMany
   */
  export type class_namesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * Filter, which class_names to fetch.
     */
    where?: class_namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_names to fetch.
     */
    orderBy?: class_namesOrderByWithRelationInput | class_namesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing class_names.
     */
    cursor?: class_namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_names from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_names.
     */
    skip?: number
    distinct?: Class_namesScalarFieldEnum | Class_namesScalarFieldEnum[]
  }

  /**
   * class_names create
   */
  export type class_namesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * The data needed to create a class_names.
     */
    data: XOR<class_namesCreateInput, class_namesUncheckedCreateInput>
  }

  /**
   * class_names createMany
   */
  export type class_namesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many class_names.
     */
    data: class_namesCreateManyInput | class_namesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * class_names update
   */
  export type class_namesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * The data needed to update a class_names.
     */
    data: XOR<class_namesUpdateInput, class_namesUncheckedUpdateInput>
    /**
     * Choose, which class_names to update.
     */
    where: class_namesWhereUniqueInput
  }

  /**
   * class_names updateMany
   */
  export type class_namesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update class_names.
     */
    data: XOR<class_namesUpdateManyMutationInput, class_namesUncheckedUpdateManyInput>
    /**
     * Filter which class_names to update
     */
    where?: class_namesWhereInput
  }

  /**
   * class_names upsert
   */
  export type class_namesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * The filter to search for the class_names to update in case it exists.
     */
    where: class_namesWhereUniqueInput
    /**
     * In case the class_names found by the `where` argument doesn't exist, create a new class_names with this data.
     */
    create: XOR<class_namesCreateInput, class_namesUncheckedCreateInput>
    /**
     * In case the class_names was found with the provided `where` argument, update it with this data.
     */
    update: XOR<class_namesUpdateInput, class_namesUncheckedUpdateInput>
  }

  /**
   * class_names delete
   */
  export type class_namesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
    /**
     * Filter which class_names to delete.
     */
    where: class_namesWhereUniqueInput
  }

  /**
   * class_names deleteMany
   */
  export type class_namesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_names to delete
     */
    where?: class_namesWhereInput
  }

  /**
   * class_names.classes
   */
  export type class_names$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    where?: classesWhereInput
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    cursor?: classesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * class_names without action
   */
  export type class_namesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_names
     */
    select?: class_namesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_namesInclude<ExtArgs> | null
  }


  /**
   * Model exams
   */

  export type AggregateExams = {
    _count: ExamsCountAggregateOutputType | null
    _avg: ExamsAvgAggregateOutputType | null
    _sum: ExamsSumAggregateOutputType | null
    _min: ExamsMinAggregateOutputType | null
    _max: ExamsMaxAggregateOutputType | null
  }

  export type ExamsAvgAggregateOutputType = {
    number_of_questions: number | null
    duration: number | null
    number_of_tries: number | null
  }

  export type ExamsSumAggregateOutputType = {
    number_of_questions: number | null
    duration: number | null
    number_of_tries: number | null
  }

  export type ExamsMinAggregateOutputType = {
    id: Uint8Array | null
    lesson_id: Uint8Array | null
    title: string | null
    topic: string | null
    scope: string | null
    start_date_time: Date | null
    end_date_time: Date | null
    visibility: boolean | null
    number_of_questions: number | null
    duration: number | null
    teacher_id: Uint8Array | null
    description: string | null
    number_of_tries: number | null
    multiple_tries: boolean | null
    time_limit_for_each_question: boolean | null
    randomise_questions: boolean | null
    end_test_after_leaving_window: boolean | null
    block_copying_pasting: boolean | null
    randomise_answers: boolean | null
    latest_attempt_counts: boolean | null
    best_attempt_counts: boolean | null
    hide_results: boolean | null
    display_points_per_question: boolean | null
    show_correct_answers: boolean | null
    allow_navigation: boolean | null
    allow_review: boolean | null
  }

  export type ExamsMaxAggregateOutputType = {
    id: Uint8Array | null
    lesson_id: Uint8Array | null
    title: string | null
    topic: string | null
    scope: string | null
    start_date_time: Date | null
    end_date_time: Date | null
    visibility: boolean | null
    number_of_questions: number | null
    duration: number | null
    teacher_id: Uint8Array | null
    description: string | null
    number_of_tries: number | null
    multiple_tries: boolean | null
    time_limit_for_each_question: boolean | null
    randomise_questions: boolean | null
    end_test_after_leaving_window: boolean | null
    block_copying_pasting: boolean | null
    randomise_answers: boolean | null
    latest_attempt_counts: boolean | null
    best_attempt_counts: boolean | null
    hide_results: boolean | null
    display_points_per_question: boolean | null
    show_correct_answers: boolean | null
    allow_navigation: boolean | null
    allow_review: boolean | null
  }

  export type ExamsCountAggregateOutputType = {
    id: number
    lesson_id: number
    title: number
    topic: number
    scope: number
    start_date_time: number
    end_date_time: number
    visibility: number
    number_of_questions: number
    duration: number
    teacher_id: number
    description: number
    number_of_tries: number
    multiple_tries: number
    time_limit_for_each_question: number
    randomise_questions: number
    end_test_after_leaving_window: number
    block_copying_pasting: number
    randomise_answers: number
    latest_attempt_counts: number
    best_attempt_counts: number
    hide_results: number
    display_points_per_question: number
    show_correct_answers: number
    allow_navigation: number
    allow_review: number
    _all: number
  }


  export type ExamsAvgAggregateInputType = {
    number_of_questions?: true
    duration?: true
    number_of_tries?: true
  }

  export type ExamsSumAggregateInputType = {
    number_of_questions?: true
    duration?: true
    number_of_tries?: true
  }

  export type ExamsMinAggregateInputType = {
    id?: true
    lesson_id?: true
    title?: true
    topic?: true
    scope?: true
    start_date_time?: true
    end_date_time?: true
    visibility?: true
    number_of_questions?: true
    duration?: true
    teacher_id?: true
    description?: true
    number_of_tries?: true
    multiple_tries?: true
    time_limit_for_each_question?: true
    randomise_questions?: true
    end_test_after_leaving_window?: true
    block_copying_pasting?: true
    randomise_answers?: true
    latest_attempt_counts?: true
    best_attempt_counts?: true
    hide_results?: true
    display_points_per_question?: true
    show_correct_answers?: true
    allow_navigation?: true
    allow_review?: true
  }

  export type ExamsMaxAggregateInputType = {
    id?: true
    lesson_id?: true
    title?: true
    topic?: true
    scope?: true
    start_date_time?: true
    end_date_time?: true
    visibility?: true
    number_of_questions?: true
    duration?: true
    teacher_id?: true
    description?: true
    number_of_tries?: true
    multiple_tries?: true
    time_limit_for_each_question?: true
    randomise_questions?: true
    end_test_after_leaving_window?: true
    block_copying_pasting?: true
    randomise_answers?: true
    latest_attempt_counts?: true
    best_attempt_counts?: true
    hide_results?: true
    display_points_per_question?: true
    show_correct_answers?: true
    allow_navigation?: true
    allow_review?: true
  }

  export type ExamsCountAggregateInputType = {
    id?: true
    lesson_id?: true
    title?: true
    topic?: true
    scope?: true
    start_date_time?: true
    end_date_time?: true
    visibility?: true
    number_of_questions?: true
    duration?: true
    teacher_id?: true
    description?: true
    number_of_tries?: true
    multiple_tries?: true
    time_limit_for_each_question?: true
    randomise_questions?: true
    end_test_after_leaving_window?: true
    block_copying_pasting?: true
    randomise_answers?: true
    latest_attempt_counts?: true
    best_attempt_counts?: true
    hide_results?: true
    display_points_per_question?: true
    show_correct_answers?: true
    allow_navigation?: true
    allow_review?: true
    _all?: true
  }

  export type ExamsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exams to aggregate.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exams
    **/
    _count?: true | ExamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamsMaxAggregateInputType
  }

  export type GetExamsAggregateType<T extends ExamsAggregateArgs> = {
        [P in keyof T & keyof AggregateExams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExams[P]>
      : GetScalarType<T[P], AggregateExams[P]>
  }




  export type examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examsWhereInput
    orderBy?: examsOrderByWithAggregationInput | examsOrderByWithAggregationInput[]
    by: ExamsScalarFieldEnum[] | ExamsScalarFieldEnum
    having?: examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamsCountAggregateInputType | true
    _avg?: ExamsAvgAggregateInputType
    _sum?: ExamsSumAggregateInputType
    _min?: ExamsMinAggregateInputType
    _max?: ExamsMaxAggregateInputType
  }

  export type ExamsGroupByOutputType = {
    id: Uint8Array
    lesson_id: Uint8Array
    title: string | null
    topic: string | null
    scope: string | null
    start_date_time: Date
    end_date_time: Date
    visibility: boolean
    number_of_questions: number | null
    duration: number
    teacher_id: Uint8Array
    description: string | null
    number_of_tries: number | null
    multiple_tries: boolean
    time_limit_for_each_question: boolean
    randomise_questions: boolean
    end_test_after_leaving_window: boolean
    block_copying_pasting: boolean
    randomise_answers: boolean
    latest_attempt_counts: boolean
    best_attempt_counts: boolean
    hide_results: boolean
    display_points_per_question: boolean
    show_correct_answers: boolean
    allow_navigation: boolean
    allow_review: boolean
    _count: ExamsCountAggregateOutputType | null
    _avg: ExamsAvgAggregateOutputType | null
    _sum: ExamsSumAggregateOutputType | null
    _min: ExamsMinAggregateOutputType | null
    _max: ExamsMaxAggregateOutputType | null
  }

  type GetExamsGroupByPayload<T extends examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamsGroupByOutputType[P]>
            : GetScalarType<T[P], ExamsGroupByOutputType[P]>
        }
      >
    >


  export type examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lesson_id?: boolean
    title?: boolean
    topic?: boolean
    scope?: boolean
    start_date_time?: boolean
    end_date_time?: boolean
    visibility?: boolean
    number_of_questions?: boolean
    duration?: boolean
    teacher_id?: boolean
    description?: boolean
    number_of_tries?: boolean
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: boolean | exams$attemptsArgs<ExtArgs>
    classes_exams?: boolean | exams$classes_examsArgs<ExtArgs>
    closed_questions?: boolean | exams$closed_questionsArgs<ExtArgs>
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    files_repository?: boolean | exams$files_repositoryArgs<ExtArgs>
    grades_exams?: boolean | exams$grades_examsArgs<ExtArgs>
    notifications?: boolean | exams$notificationsArgs<ExtArgs>
    open_questions?: boolean | exams$open_questionsArgs<ExtArgs>
    students_exams?: boolean | exams$students_examsArgs<ExtArgs>
    _count?: boolean | ExamsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exams"]>



  export type examsSelectScalar = {
    id?: boolean
    lesson_id?: boolean
    title?: boolean
    topic?: boolean
    scope?: boolean
    start_date_time?: boolean
    end_date_time?: boolean
    visibility?: boolean
    number_of_questions?: boolean
    duration?: boolean
    teacher_id?: boolean
    description?: boolean
    number_of_tries?: boolean
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
  }

  export type examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | exams$attemptsArgs<ExtArgs>
    classes_exams?: boolean | exams$classes_examsArgs<ExtArgs>
    closed_questions?: boolean | exams$closed_questionsArgs<ExtArgs>
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    files_repository?: boolean | exams$files_repositoryArgs<ExtArgs>
    grades_exams?: boolean | exams$grades_examsArgs<ExtArgs>
    notifications?: boolean | exams$notificationsArgs<ExtArgs>
    open_questions?: boolean | exams$open_questionsArgs<ExtArgs>
    students_exams?: boolean | exams$students_examsArgs<ExtArgs>
    _count?: boolean | ExamsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exams"
    objects: {
      attempts: Prisma.$attemptsPayload<ExtArgs>[]
      classes_exams: Prisma.$classes_examsPayload<ExtArgs>[]
      closed_questions: Prisma.$closed_questionsPayload<ExtArgs>[]
      lessons: Prisma.$lessonsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs>
      files_repository: Prisma.$files_repositoryPayload<ExtArgs>[]
      grades_exams: Prisma.$grades_examsPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      open_questions: Prisma.$open_questionsPayload<ExtArgs>[]
      students_exams: Prisma.$students_examsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      lesson_id: Uint8Array
      title: string | null
      topic: string | null
      scope: string | null
      start_date_time: Date
      end_date_time: Date
      visibility: boolean
      number_of_questions: number | null
      duration: number
      teacher_id: Uint8Array
      description: string | null
      number_of_tries: number | null
      multiple_tries: boolean
      time_limit_for_each_question: boolean
      randomise_questions: boolean
      end_test_after_leaving_window: boolean
      block_copying_pasting: boolean
      randomise_answers: boolean
      latest_attempt_counts: boolean
      best_attempt_counts: boolean
      hide_results: boolean
      display_points_per_question: boolean
      show_correct_answers: boolean
      allow_navigation: boolean
      allow_review: boolean
    }, ExtArgs["result"]["exams"]>
    composites: {}
  }

  type examsGetPayload<S extends boolean | null | undefined | examsDefaultArgs> = $Result.GetResult<Prisma.$examsPayload, S>

  type examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<examsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamsCountAggregateInputType | true
    }

  export interface examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exams'], meta: { name: 'exams' } }
    /**
     * Find zero or one Exams that matches the filter.
     * @param {examsFindUniqueArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends examsFindUniqueArgs>(args: SelectSubset<T, examsFindUniqueArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {examsFindUniqueOrThrowArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends examsFindUniqueOrThrowArgs>(args: SelectSubset<T, examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindFirstArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends examsFindFirstArgs>(args?: SelectSubset<T, examsFindFirstArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindFirstOrThrowArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends examsFindFirstOrThrowArgs>(args?: SelectSubset<T, examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exams.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examsWithIdOnly = await prisma.exams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends examsFindManyArgs>(args?: SelectSubset<T, examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exams.
     * @param {examsCreateArgs} args - Arguments to create a Exams.
     * @example
     * // Create one Exams
     * const Exams = await prisma.exams.create({
     *   data: {
     *     // ... data to create a Exams
     *   }
     * })
     * 
     */
    create<T extends examsCreateArgs>(args: SelectSubset<T, examsCreateArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exams.
     * @param {examsCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exams = await prisma.exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends examsCreateManyArgs>(args?: SelectSubset<T, examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exams.
     * @param {examsDeleteArgs} args - Arguments to delete one Exams.
     * @example
     * // Delete one Exams
     * const Exams = await prisma.exams.delete({
     *   where: {
     *     // ... filter to delete one Exams
     *   }
     * })
     * 
     */
    delete<T extends examsDeleteArgs>(args: SelectSubset<T, examsDeleteArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exams.
     * @param {examsUpdateArgs} args - Arguments to update one Exams.
     * @example
     * // Update one Exams
     * const exams = await prisma.exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends examsUpdateArgs>(args: SelectSubset<T, examsUpdateArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exams.
     * @param {examsDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends examsDeleteManyArgs>(args?: SelectSubset<T, examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exams = await prisma.exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends examsUpdateManyArgs>(args: SelectSubset<T, examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exams.
     * @param {examsUpsertArgs} args - Arguments to update or create a Exams.
     * @example
     * // Update or create a Exams
     * const exams = await prisma.exams.upsert({
     *   create: {
     *     // ... data to create a Exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exams we want to update
     *   }
     * })
     */
    upsert<T extends examsUpsertArgs>(args: SelectSubset<T, examsUpsertArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exams.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends examsCountArgs>(
      args?: Subset<T, examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamsAggregateArgs>(args: Subset<T, ExamsAggregateArgs>): Prisma.PrismaPromise<GetExamsAggregateType<T>>

    /**
     * Group by Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: examsGroupByArgs['orderBy'] }
        : { orderBy?: examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exams model
   */
  readonly fields: examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempts<T extends exams$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, exams$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findMany"> | Null>
    classes_exams<T extends exams$classes_examsArgs<ExtArgs> = {}>(args?: Subset<T, exams$classes_examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "findMany"> | Null>
    closed_questions<T extends exams$closed_questionsArgs<ExtArgs> = {}>(args?: Subset<T, exams$closed_questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findMany"> | Null>
    lessons<T extends lessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, lessonsDefaultArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    files_repository<T extends exams$files_repositoryArgs<ExtArgs> = {}>(args?: Subset<T, exams$files_repositoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "findMany"> | Null>
    grades_exams<T extends exams$grades_examsArgs<ExtArgs> = {}>(args?: Subset<T, exams$grades_examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends exams$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, exams$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    open_questions<T extends exams$open_questionsArgs<ExtArgs> = {}>(args?: Subset<T, exams$open_questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findMany"> | Null>
    students_exams<T extends exams$students_examsArgs<ExtArgs> = {}>(args?: Subset<T, exams$students_examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exams model
   */ 
  interface examsFieldRefs {
    readonly id: FieldRef<"exams", 'Bytes'>
    readonly lesson_id: FieldRef<"exams", 'Bytes'>
    readonly title: FieldRef<"exams", 'String'>
    readonly topic: FieldRef<"exams", 'String'>
    readonly scope: FieldRef<"exams", 'String'>
    readonly start_date_time: FieldRef<"exams", 'DateTime'>
    readonly end_date_time: FieldRef<"exams", 'DateTime'>
    readonly visibility: FieldRef<"exams", 'Boolean'>
    readonly number_of_questions: FieldRef<"exams", 'Int'>
    readonly duration: FieldRef<"exams", 'Int'>
    readonly teacher_id: FieldRef<"exams", 'Bytes'>
    readonly description: FieldRef<"exams", 'String'>
    readonly number_of_tries: FieldRef<"exams", 'Int'>
    readonly multiple_tries: FieldRef<"exams", 'Boolean'>
    readonly time_limit_for_each_question: FieldRef<"exams", 'Boolean'>
    readonly randomise_questions: FieldRef<"exams", 'Boolean'>
    readonly end_test_after_leaving_window: FieldRef<"exams", 'Boolean'>
    readonly block_copying_pasting: FieldRef<"exams", 'Boolean'>
    readonly randomise_answers: FieldRef<"exams", 'Boolean'>
    readonly latest_attempt_counts: FieldRef<"exams", 'Boolean'>
    readonly best_attempt_counts: FieldRef<"exams", 'Boolean'>
    readonly hide_results: FieldRef<"exams", 'Boolean'>
    readonly display_points_per_question: FieldRef<"exams", 'Boolean'>
    readonly show_correct_answers: FieldRef<"exams", 'Boolean'>
    readonly allow_navigation: FieldRef<"exams", 'Boolean'>
    readonly allow_review: FieldRef<"exams", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * exams findUnique
   */
  export type examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams findUniqueOrThrow
   */
  export type examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams findFirst
   */
  export type examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     */
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams findFirstOrThrow
   */
  export type examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     */
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams findMany
   */
  export type examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams create
   */
  export type examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The data needed to create a exams.
     */
    data: XOR<examsCreateInput, examsUncheckedCreateInput>
  }

  /**
   * exams createMany
   */
  export type examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exams.
     */
    data: examsCreateManyInput | examsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exams update
   */
  export type examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The data needed to update a exams.
     */
    data: XOR<examsUpdateInput, examsUncheckedUpdateInput>
    /**
     * Choose, which exams to update.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams updateMany
   */
  export type examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exams.
     */
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyInput>
    /**
     * Filter which exams to update
     */
    where?: examsWhereInput
  }

  /**
   * exams upsert
   */
  export type examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The filter to search for the exams to update in case it exists.
     */
    where: examsWhereUniqueInput
    /**
     * In case the exams found by the `where` argument doesn't exist, create a new exams with this data.
     */
    create: XOR<examsCreateInput, examsUncheckedCreateInput>
    /**
     * In case the exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<examsUpdateInput, examsUncheckedUpdateInput>
  }

  /**
   * exams delete
   */
  export type examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter which exams to delete.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams deleteMany
   */
  export type examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exams to delete
     */
    where?: examsWhereInput
  }

  /**
   * exams.attempts
   */
  export type exams$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    where?: attemptsWhereInput
    orderBy?: attemptsOrderByWithRelationInput | attemptsOrderByWithRelationInput[]
    cursor?: attemptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttemptsScalarFieldEnum | AttemptsScalarFieldEnum[]
  }

  /**
   * exams.classes_exams
   */
  export type exams$classes_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    where?: classes_examsWhereInput
    orderBy?: classes_examsOrderByWithRelationInput | classes_examsOrderByWithRelationInput[]
    cursor?: classes_examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Classes_examsScalarFieldEnum | Classes_examsScalarFieldEnum[]
  }

  /**
   * exams.closed_questions
   */
  export type exams$closed_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    where?: closed_questionsWhereInput
    orderBy?: closed_questionsOrderByWithRelationInput | closed_questionsOrderByWithRelationInput[]
    cursor?: closed_questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Closed_questionsScalarFieldEnum | Closed_questionsScalarFieldEnum[]
  }

  /**
   * exams.files_repository
   */
  export type exams$files_repositoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    where?: files_repositoryWhereInput
    orderBy?: files_repositoryOrderByWithRelationInput | files_repositoryOrderByWithRelationInput[]
    cursor?: files_repositoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Files_repositoryScalarFieldEnum | Files_repositoryScalarFieldEnum[]
  }

  /**
   * exams.grades_exams
   */
  export type exams$grades_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    where?: grades_examsWhereInput
    orderBy?: grades_examsOrderByWithRelationInput | grades_examsOrderByWithRelationInput[]
    cursor?: grades_examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Grades_examsScalarFieldEnum | Grades_examsScalarFieldEnum[]
  }

  /**
   * exams.notifications
   */
  export type exams$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * exams.open_questions
   */
  export type exams$open_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    where?: open_questionsWhereInput
    orderBy?: open_questionsOrderByWithRelationInput | open_questionsOrderByWithRelationInput[]
    cursor?: open_questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Open_questionsScalarFieldEnum | Open_questionsScalarFieldEnum[]
  }

  /**
   * exams.students_exams
   */
  export type exams$students_examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    where?: students_examsWhereInput
    orderBy?: students_examsOrderByWithRelationInput | students_examsOrderByWithRelationInput[]
    cursor?: students_examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Students_examsScalarFieldEnum | Students_examsScalarFieldEnum[]
  }

  /**
   * exams without action
   */
  export type examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
  }


  /**
   * Model final_grades
   */

  export type AggregateFinal_grades = {
    _count: Final_gradesCountAggregateOutputType | null
    _avg: Final_gradesAvgAggregateOutputType | null
    _sum: Final_gradesSumAggregateOutputType | null
    _min: Final_gradesMinAggregateOutputType | null
    _max: Final_gradesMaxAggregateOutputType | null
  }

  export type Final_gradesAvgAggregateOutputType = {
    grade: number | null
  }

  export type Final_gradesSumAggregateOutputType = {
    grade: number | null
  }

  export type Final_gradesMinAggregateOutputType = {
    id: Uint8Array | null
    grade: number | null
    student_id: Uint8Array | null
    subject_id: Uint8Array | null
    teacher_id: Uint8Array | null
    semester_id: Uint8Array | null
  }

  export type Final_gradesMaxAggregateOutputType = {
    id: Uint8Array | null
    grade: number | null
    student_id: Uint8Array | null
    subject_id: Uint8Array | null
    teacher_id: Uint8Array | null
    semester_id: Uint8Array | null
  }

  export type Final_gradesCountAggregateOutputType = {
    id: number
    grade: number
    student_id: number
    subject_id: number
    teacher_id: number
    semester_id: number
    _all: number
  }


  export type Final_gradesAvgAggregateInputType = {
    grade?: true
  }

  export type Final_gradesSumAggregateInputType = {
    grade?: true
  }

  export type Final_gradesMinAggregateInputType = {
    id?: true
    grade?: true
    student_id?: true
    subject_id?: true
    teacher_id?: true
    semester_id?: true
  }

  export type Final_gradesMaxAggregateInputType = {
    id?: true
    grade?: true
    student_id?: true
    subject_id?: true
    teacher_id?: true
    semester_id?: true
  }

  export type Final_gradesCountAggregateInputType = {
    id?: true
    grade?: true
    student_id?: true
    subject_id?: true
    teacher_id?: true
    semester_id?: true
    _all?: true
  }

  export type Final_gradesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which final_grades to aggregate.
     */
    where?: final_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: final_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned final_grades
    **/
    _count?: true | Final_gradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Final_gradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Final_gradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Final_gradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Final_gradesMaxAggregateInputType
  }

  export type GetFinal_gradesAggregateType<T extends Final_gradesAggregateArgs> = {
        [P in keyof T & keyof AggregateFinal_grades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinal_grades[P]>
      : GetScalarType<T[P], AggregateFinal_grades[P]>
  }




  export type final_gradesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradesWhereInput
    orderBy?: final_gradesOrderByWithAggregationInput | final_gradesOrderByWithAggregationInput[]
    by: Final_gradesScalarFieldEnum[] | Final_gradesScalarFieldEnum
    having?: final_gradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Final_gradesCountAggregateInputType | true
    _avg?: Final_gradesAvgAggregateInputType
    _sum?: Final_gradesSumAggregateInputType
    _min?: Final_gradesMinAggregateInputType
    _max?: Final_gradesMaxAggregateInputType
  }

  export type Final_gradesGroupByOutputType = {
    id: Uint8Array
    grade: number
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
    semester_id: Uint8Array
    _count: Final_gradesCountAggregateOutputType | null
    _avg: Final_gradesAvgAggregateOutputType | null
    _sum: Final_gradesSumAggregateOutputType | null
    _min: Final_gradesMinAggregateOutputType | null
    _max: Final_gradesMaxAggregateOutputType | null
  }

  type GetFinal_gradesGroupByPayload<T extends final_gradesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Final_gradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Final_gradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Final_gradesGroupByOutputType[P]>
            : GetScalarType<T[P], Final_gradesGroupByOutputType[P]>
        }
      >
    >


  export type final_gradesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    student_id?: boolean
    subject_id?: boolean
    teacher_id?: boolean
    semester_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    semesters?: boolean | semestersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["final_grades"]>



  export type final_gradesSelectScalar = {
    id?: boolean
    grade?: boolean
    student_id?: boolean
    subject_id?: boolean
    teacher_id?: boolean
    semester_id?: boolean
  }

  export type final_gradesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    semesters?: boolean | semestersDefaultArgs<ExtArgs>
  }

  export type $final_gradesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "final_grades"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      subjects: Prisma.$subjectsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs>
      semesters: Prisma.$semestersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      grade: number
      student_id: Uint8Array
      subject_id: Uint8Array
      teacher_id: Uint8Array
      semester_id: Uint8Array
    }, ExtArgs["result"]["final_grades"]>
    composites: {}
  }

  type final_gradesGetPayload<S extends boolean | null | undefined | final_gradesDefaultArgs> = $Result.GetResult<Prisma.$final_gradesPayload, S>

  type final_gradesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<final_gradesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Final_gradesCountAggregateInputType | true
    }

  export interface final_gradesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['final_grades'], meta: { name: 'final_grades' } }
    /**
     * Find zero or one Final_grades that matches the filter.
     * @param {final_gradesFindUniqueArgs} args - Arguments to find a Final_grades
     * @example
     * // Get one Final_grades
     * const final_grades = await prisma.final_grades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends final_gradesFindUniqueArgs>(args: SelectSubset<T, final_gradesFindUniqueArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Final_grades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {final_gradesFindUniqueOrThrowArgs} args - Arguments to find a Final_grades
     * @example
     * // Get one Final_grades
     * const final_grades = await prisma.final_grades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends final_gradesFindUniqueOrThrowArgs>(args: SelectSubset<T, final_gradesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Final_grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradesFindFirstArgs} args - Arguments to find a Final_grades
     * @example
     * // Get one Final_grades
     * const final_grades = await prisma.final_grades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends final_gradesFindFirstArgs>(args?: SelectSubset<T, final_gradesFindFirstArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Final_grades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradesFindFirstOrThrowArgs} args - Arguments to find a Final_grades
     * @example
     * // Get one Final_grades
     * const final_grades = await prisma.final_grades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends final_gradesFindFirstOrThrowArgs>(args?: SelectSubset<T, final_gradesFindFirstOrThrowArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Final_grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Final_grades
     * const final_grades = await prisma.final_grades.findMany()
     * 
     * // Get first 10 Final_grades
     * const final_grades = await prisma.final_grades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const final_gradesWithIdOnly = await prisma.final_grades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends final_gradesFindManyArgs>(args?: SelectSubset<T, final_gradesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Final_grades.
     * @param {final_gradesCreateArgs} args - Arguments to create a Final_grades.
     * @example
     * // Create one Final_grades
     * const Final_grades = await prisma.final_grades.create({
     *   data: {
     *     // ... data to create a Final_grades
     *   }
     * })
     * 
     */
    create<T extends final_gradesCreateArgs>(args: SelectSubset<T, final_gradesCreateArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Final_grades.
     * @param {final_gradesCreateManyArgs} args - Arguments to create many Final_grades.
     * @example
     * // Create many Final_grades
     * const final_grades = await prisma.final_grades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends final_gradesCreateManyArgs>(args?: SelectSubset<T, final_gradesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Final_grades.
     * @param {final_gradesDeleteArgs} args - Arguments to delete one Final_grades.
     * @example
     * // Delete one Final_grades
     * const Final_grades = await prisma.final_grades.delete({
     *   where: {
     *     // ... filter to delete one Final_grades
     *   }
     * })
     * 
     */
    delete<T extends final_gradesDeleteArgs>(args: SelectSubset<T, final_gradesDeleteArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Final_grades.
     * @param {final_gradesUpdateArgs} args - Arguments to update one Final_grades.
     * @example
     * // Update one Final_grades
     * const final_grades = await prisma.final_grades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends final_gradesUpdateArgs>(args: SelectSubset<T, final_gradesUpdateArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Final_grades.
     * @param {final_gradesDeleteManyArgs} args - Arguments to filter Final_grades to delete.
     * @example
     * // Delete a few Final_grades
     * const { count } = await prisma.final_grades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends final_gradesDeleteManyArgs>(args?: SelectSubset<T, final_gradesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Final_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Final_grades
     * const final_grades = await prisma.final_grades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends final_gradesUpdateManyArgs>(args: SelectSubset<T, final_gradesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Final_grades.
     * @param {final_gradesUpsertArgs} args - Arguments to update or create a Final_grades.
     * @example
     * // Update or create a Final_grades
     * const final_grades = await prisma.final_grades.upsert({
     *   create: {
     *     // ... data to create a Final_grades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Final_grades we want to update
     *   }
     * })
     */
    upsert<T extends final_gradesUpsertArgs>(args: SelectSubset<T, final_gradesUpsertArgs<ExtArgs>>): Prisma__final_gradesClient<$Result.GetResult<Prisma.$final_gradesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Final_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradesCountArgs} args - Arguments to filter Final_grades to count.
     * @example
     * // Count the number of Final_grades
     * const count = await prisma.final_grades.count({
     *   where: {
     *     // ... the filter for the Final_grades we want to count
     *   }
     * })
    **/
    count<T extends final_gradesCountArgs>(
      args?: Subset<T, final_gradesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Final_gradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Final_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Final_gradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Final_gradesAggregateArgs>(args: Subset<T, Final_gradesAggregateArgs>): Prisma.PrismaPromise<GetFinal_gradesAggregateType<T>>

    /**
     * Group by Final_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends final_gradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: final_gradesGroupByArgs['orderBy'] }
        : { orderBy?: final_gradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, final_gradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinal_gradesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the final_grades model
   */
  readonly fields: final_gradesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for final_grades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__final_gradesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    semesters<T extends semestersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, semestersDefaultArgs<ExtArgs>>): Prisma__semestersClient<$Result.GetResult<Prisma.$semestersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the final_grades model
   */ 
  interface final_gradesFieldRefs {
    readonly id: FieldRef<"final_grades", 'Bytes'>
    readonly grade: FieldRef<"final_grades", 'Int'>
    readonly student_id: FieldRef<"final_grades", 'Bytes'>
    readonly subject_id: FieldRef<"final_grades", 'Bytes'>
    readonly teacher_id: FieldRef<"final_grades", 'Bytes'>
    readonly semester_id: FieldRef<"final_grades", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * final_grades findUnique
   */
  export type final_gradesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * Filter, which final_grades to fetch.
     */
    where: final_gradesWhereUniqueInput
  }

  /**
   * final_grades findUniqueOrThrow
   */
  export type final_gradesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * Filter, which final_grades to fetch.
     */
    where: final_gradesWhereUniqueInput
  }

  /**
   * final_grades findFirst
   */
  export type final_gradesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * Filter, which final_grades to fetch.
     */
    where?: final_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for final_grades.
     */
    cursor?: final_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of final_grades.
     */
    distinct?: Final_gradesScalarFieldEnum | Final_gradesScalarFieldEnum[]
  }

  /**
   * final_grades findFirstOrThrow
   */
  export type final_gradesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * Filter, which final_grades to fetch.
     */
    where?: final_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for final_grades.
     */
    cursor?: final_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of final_grades.
     */
    distinct?: Final_gradesScalarFieldEnum | Final_gradesScalarFieldEnum[]
  }

  /**
   * final_grades findMany
   */
  export type final_gradesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * Filter, which final_grades to fetch.
     */
    where?: final_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradesOrderByWithRelationInput | final_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing final_grades.
     */
    cursor?: final_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    distinct?: Final_gradesScalarFieldEnum | Final_gradesScalarFieldEnum[]
  }

  /**
   * final_grades create
   */
  export type final_gradesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * The data needed to create a final_grades.
     */
    data: XOR<final_gradesCreateInput, final_gradesUncheckedCreateInput>
  }

  /**
   * final_grades createMany
   */
  export type final_gradesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many final_grades.
     */
    data: final_gradesCreateManyInput | final_gradesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * final_grades update
   */
  export type final_gradesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * The data needed to update a final_grades.
     */
    data: XOR<final_gradesUpdateInput, final_gradesUncheckedUpdateInput>
    /**
     * Choose, which final_grades to update.
     */
    where: final_gradesWhereUniqueInput
  }

  /**
   * final_grades updateMany
   */
  export type final_gradesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update final_grades.
     */
    data: XOR<final_gradesUpdateManyMutationInput, final_gradesUncheckedUpdateManyInput>
    /**
     * Filter which final_grades to update
     */
    where?: final_gradesWhereInput
  }

  /**
   * final_grades upsert
   */
  export type final_gradesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * The filter to search for the final_grades to update in case it exists.
     */
    where: final_gradesWhereUniqueInput
    /**
     * In case the final_grades found by the `where` argument doesn't exist, create a new final_grades with this data.
     */
    create: XOR<final_gradesCreateInput, final_gradesUncheckedCreateInput>
    /**
     * In case the final_grades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<final_gradesUpdateInput, final_gradesUncheckedUpdateInput>
  }

  /**
   * final_grades delete
   */
  export type final_gradesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
    /**
     * Filter which final_grades to delete.
     */
    where: final_gradesWhereUniqueInput
  }

  /**
   * final_grades deleteMany
   */
  export type final_gradesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which final_grades to delete
     */
    where?: final_gradesWhereInput
  }

  /**
   * final_grades without action
   */
  export type final_gradesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grades
     */
    select?: final_gradesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradesInclude<ExtArgs> | null
  }


  /**
   * Model questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    survey_id: Uint8Array | null
    question_type_id: Uint8Array | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    survey_id: Uint8Array | null
    question_type_id: Uint8Array | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    content: number
    survey_id: number
    question_type_id: number
    _all: number
  }


  export type QuestionsMinAggregateInputType = {
    id?: true
    content?: true
    survey_id?: true
    question_type_id?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    content?: true
    survey_id?: true
    question_type_id?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    content?: true
    survey_id?: true
    question_type_id?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to aggregate.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithAggregationInput | questionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: Uint8Array
    content: string
    survey_id: Uint8Array
    question_type_id: Uint8Array
    _count: QuestionsCountAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    survey_id?: boolean
    question_type_id?: boolean
    surveys?: boolean | surveysDefaultArgs<ExtArgs>
    questions_types?: boolean | questions_typesDefaultArgs<ExtArgs>
    questions_possible_responses?: boolean | questions$questions_possible_responsesArgs<ExtArgs>
    questions_responses?: boolean | questions$questions_responsesArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>



  export type questionsSelectScalar = {
    id?: boolean
    content?: boolean
    survey_id?: boolean
    question_type_id?: boolean
  }

  export type questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveys?: boolean | surveysDefaultArgs<ExtArgs>
    questions_types?: boolean | questions_typesDefaultArgs<ExtArgs>
    questions_possible_responses?: boolean | questions$questions_possible_responsesArgs<ExtArgs>
    questions_responses?: boolean | questions$questions_responsesArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions"
    objects: {
      surveys: Prisma.$surveysPayload<ExtArgs>
      questions_types: Prisma.$questions_typesPayload<ExtArgs>
      questions_possible_responses: Prisma.$questions_possible_responsesPayload<ExtArgs>[]
      questions_responses: Prisma.$questions_responsesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      content: string
      survey_id: Uint8Array
      question_type_id: Uint8Array
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type questionsGetPayload<S extends boolean | null | undefined | questionsDefaultArgs> = $Result.GetResult<Prisma.$questionsPayload, S>

  type questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions'], meta: { name: 'questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {questionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionsFindUniqueArgs>(args: SelectSubset<T, questionsFindUniqueArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionsFindFirstArgs>(args?: SelectSubset<T, questionsFindFirstArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionsFindManyArgs>(args?: SelectSubset<T, questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions.
     * @param {questionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends questionsCreateArgs>(args: SelectSubset<T, questionsCreateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {questionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionsCreateManyArgs>(args?: SelectSubset<T, questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions.
     * @param {questionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends questionsDeleteArgs>(args: SelectSubset<T, questionsDeleteArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions.
     * @param {questionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionsUpdateArgs>(args: SelectSubset<T, questionsUpdateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {questionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionsDeleteManyArgs>(args?: SelectSubset<T, questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionsUpdateManyArgs>(args: SelectSubset<T, questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions.
     * @param {questionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends questionsUpsertArgs>(args: SelectSubset<T, questionsUpsertArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionsCountArgs>(
      args?: Subset<T, questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionsGroupByArgs['orderBy'] }
        : { orderBy?: questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions model
   */
  readonly fields: questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveys<T extends surveysDefaultArgs<ExtArgs> = {}>(args?: Subset<T, surveysDefaultArgs<ExtArgs>>): Prisma__surveysClient<$Result.GetResult<Prisma.$surveysPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    questions_types<T extends questions_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questions_typesDefaultArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    questions_possible_responses<T extends questions$questions_possible_responsesArgs<ExtArgs> = {}>(args?: Subset<T, questions$questions_possible_responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "findMany"> | Null>
    questions_responses<T extends questions$questions_responsesArgs<ExtArgs> = {}>(args?: Subset<T, questions$questions_responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions model
   */ 
  interface questionsFieldRefs {
    readonly id: FieldRef<"questions", 'Bytes'>
    readonly content: FieldRef<"questions", 'String'>
    readonly survey_id: FieldRef<"questions", 'Bytes'>
    readonly question_type_id: FieldRef<"questions", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * questions findUnique
   */
  export type questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findUniqueOrThrow
   */
  export type questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findFirst
   */
  export type questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findFirstOrThrow
   */
  export type questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findMany
   */
  export type questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions create
   */
  export type questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a questions.
     */
    data: XOR<questionsCreateInput, questionsUncheckedCreateInput>
  }

  /**
   * questions createMany
   */
  export type questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions update
   */
  export type questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a questions.
     */
    data: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
    /**
     * Choose, which questions to update.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions updateMany
   */
  export type questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
  }

  /**
   * questions upsert
   */
  export type questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the questions to update in case it exists.
     */
    where: questionsWhereUniqueInput
    /**
     * In case the questions found by the `where` argument doesn't exist, create a new questions with this data.
     */
    create: XOR<questionsCreateInput, questionsUncheckedCreateInput>
    /**
     * In case the questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
  }

  /**
   * questions delete
   */
  export type questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter which questions to delete.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions deleteMany
   */
  export type questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionsWhereInput
  }

  /**
   * questions.questions_possible_responses
   */
  export type questions$questions_possible_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    where?: questions_possible_responsesWhereInput
    orderBy?: questions_possible_responsesOrderByWithRelationInput | questions_possible_responsesOrderByWithRelationInput[]
    cursor?: questions_possible_responsesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Questions_possible_responsesScalarFieldEnum | Questions_possible_responsesScalarFieldEnum[]
  }

  /**
   * questions.questions_responses
   */
  export type questions$questions_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    where?: questions_responsesWhereInput
    orderBy?: questions_responsesOrderByWithRelationInput | questions_responsesOrderByWithRelationInput[]
    cursor?: questions_responsesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Questions_responsesScalarFieldEnum | Questions_responsesScalarFieldEnum[]
  }

  /**
   * questions without action
   */
  export type questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
  }


  /**
   * Model questions_possible_responses
   */

  export type AggregateQuestions_possible_responses = {
    _count: Questions_possible_responsesCountAggregateOutputType | null
    _min: Questions_possible_responsesMinAggregateOutputType | null
    _max: Questions_possible_responsesMaxAggregateOutputType | null
  }

  export type Questions_possible_responsesMinAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    question_id: Uint8Array | null
  }

  export type Questions_possible_responsesMaxAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    question_id: Uint8Array | null
  }

  export type Questions_possible_responsesCountAggregateOutputType = {
    id: number
    content: number
    question_id: number
    _all: number
  }


  export type Questions_possible_responsesMinAggregateInputType = {
    id?: true
    content?: true
    question_id?: true
  }

  export type Questions_possible_responsesMaxAggregateInputType = {
    id?: true
    content?: true
    question_id?: true
  }

  export type Questions_possible_responsesCountAggregateInputType = {
    id?: true
    content?: true
    question_id?: true
    _all?: true
  }

  export type Questions_possible_responsesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions_possible_responses to aggregate.
     */
    where?: questions_possible_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_possible_responses to fetch.
     */
    orderBy?: questions_possible_responsesOrderByWithRelationInput | questions_possible_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questions_possible_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_possible_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_possible_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions_possible_responses
    **/
    _count?: true | Questions_possible_responsesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Questions_possible_responsesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Questions_possible_responsesMaxAggregateInputType
  }

  export type GetQuestions_possible_responsesAggregateType<T extends Questions_possible_responsesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions_possible_responses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions_possible_responses[P]>
      : GetScalarType<T[P], AggregateQuestions_possible_responses[P]>
  }




  export type questions_possible_responsesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questions_possible_responsesWhereInput
    orderBy?: questions_possible_responsesOrderByWithAggregationInput | questions_possible_responsesOrderByWithAggregationInput[]
    by: Questions_possible_responsesScalarFieldEnum[] | Questions_possible_responsesScalarFieldEnum
    having?: questions_possible_responsesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Questions_possible_responsesCountAggregateInputType | true
    _min?: Questions_possible_responsesMinAggregateInputType
    _max?: Questions_possible_responsesMaxAggregateInputType
  }

  export type Questions_possible_responsesGroupByOutputType = {
    id: Uint8Array
    content: string
    question_id: Uint8Array
    _count: Questions_possible_responsesCountAggregateOutputType | null
    _min: Questions_possible_responsesMinAggregateOutputType | null
    _max: Questions_possible_responsesMaxAggregateOutputType | null
  }

  type GetQuestions_possible_responsesGroupByPayload<T extends questions_possible_responsesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Questions_possible_responsesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Questions_possible_responsesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Questions_possible_responsesGroupByOutputType[P]>
            : GetScalarType<T[P], Questions_possible_responsesGroupByOutputType[P]>
        }
      >
    >


  export type questions_possible_responsesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    question_id?: boolean
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions_possible_responses"]>



  export type questions_possible_responsesSelectScalar = {
    id?: boolean
    content?: boolean
    question_id?: boolean
  }

  export type questions_possible_responsesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }

  export type $questions_possible_responsesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions_possible_responses"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      content: string
      question_id: Uint8Array
    }, ExtArgs["result"]["questions_possible_responses"]>
    composites: {}
  }

  type questions_possible_responsesGetPayload<S extends boolean | null | undefined | questions_possible_responsesDefaultArgs> = $Result.GetResult<Prisma.$questions_possible_responsesPayload, S>

  type questions_possible_responsesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questions_possible_responsesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Questions_possible_responsesCountAggregateInputType | true
    }

  export interface questions_possible_responsesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions_possible_responses'], meta: { name: 'questions_possible_responses' } }
    /**
     * Find zero or one Questions_possible_responses that matches the filter.
     * @param {questions_possible_responsesFindUniqueArgs} args - Arguments to find a Questions_possible_responses
     * @example
     * // Get one Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questions_possible_responsesFindUniqueArgs>(args: SelectSubset<T, questions_possible_responsesFindUniqueArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions_possible_responses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questions_possible_responsesFindUniqueOrThrowArgs} args - Arguments to find a Questions_possible_responses
     * @example
     * // Get one Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questions_possible_responsesFindUniqueOrThrowArgs>(args: SelectSubset<T, questions_possible_responsesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions_possible_responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_possible_responsesFindFirstArgs} args - Arguments to find a Questions_possible_responses
     * @example
     * // Get one Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questions_possible_responsesFindFirstArgs>(args?: SelectSubset<T, questions_possible_responsesFindFirstArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions_possible_responses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_possible_responsesFindFirstOrThrowArgs} args - Arguments to find a Questions_possible_responses
     * @example
     * // Get one Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questions_possible_responsesFindFirstOrThrowArgs>(args?: SelectSubset<T, questions_possible_responsesFindFirstOrThrowArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions_possible_responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_possible_responsesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.findMany()
     * 
     * // Get first 10 Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questions_possible_responsesWithIdOnly = await prisma.questions_possible_responses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questions_possible_responsesFindManyArgs>(args?: SelectSubset<T, questions_possible_responsesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions_possible_responses.
     * @param {questions_possible_responsesCreateArgs} args - Arguments to create a Questions_possible_responses.
     * @example
     * // Create one Questions_possible_responses
     * const Questions_possible_responses = await prisma.questions_possible_responses.create({
     *   data: {
     *     // ... data to create a Questions_possible_responses
     *   }
     * })
     * 
     */
    create<T extends questions_possible_responsesCreateArgs>(args: SelectSubset<T, questions_possible_responsesCreateArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions_possible_responses.
     * @param {questions_possible_responsesCreateManyArgs} args - Arguments to create many Questions_possible_responses.
     * @example
     * // Create many Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questions_possible_responsesCreateManyArgs>(args?: SelectSubset<T, questions_possible_responsesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions_possible_responses.
     * @param {questions_possible_responsesDeleteArgs} args - Arguments to delete one Questions_possible_responses.
     * @example
     * // Delete one Questions_possible_responses
     * const Questions_possible_responses = await prisma.questions_possible_responses.delete({
     *   where: {
     *     // ... filter to delete one Questions_possible_responses
     *   }
     * })
     * 
     */
    delete<T extends questions_possible_responsesDeleteArgs>(args: SelectSubset<T, questions_possible_responsesDeleteArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions_possible_responses.
     * @param {questions_possible_responsesUpdateArgs} args - Arguments to update one Questions_possible_responses.
     * @example
     * // Update one Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questions_possible_responsesUpdateArgs>(args: SelectSubset<T, questions_possible_responsesUpdateArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions_possible_responses.
     * @param {questions_possible_responsesDeleteManyArgs} args - Arguments to filter Questions_possible_responses to delete.
     * @example
     * // Delete a few Questions_possible_responses
     * const { count } = await prisma.questions_possible_responses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questions_possible_responsesDeleteManyArgs>(args?: SelectSubset<T, questions_possible_responsesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions_possible_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_possible_responsesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questions_possible_responsesUpdateManyArgs>(args: SelectSubset<T, questions_possible_responsesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions_possible_responses.
     * @param {questions_possible_responsesUpsertArgs} args - Arguments to update or create a Questions_possible_responses.
     * @example
     * // Update or create a Questions_possible_responses
     * const questions_possible_responses = await prisma.questions_possible_responses.upsert({
     *   create: {
     *     // ... data to create a Questions_possible_responses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions_possible_responses we want to update
     *   }
     * })
     */
    upsert<T extends questions_possible_responsesUpsertArgs>(args: SelectSubset<T, questions_possible_responsesUpsertArgs<ExtArgs>>): Prisma__questions_possible_responsesClient<$Result.GetResult<Prisma.$questions_possible_responsesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions_possible_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_possible_responsesCountArgs} args - Arguments to filter Questions_possible_responses to count.
     * @example
     * // Count the number of Questions_possible_responses
     * const count = await prisma.questions_possible_responses.count({
     *   where: {
     *     // ... the filter for the Questions_possible_responses we want to count
     *   }
     * })
    **/
    count<T extends questions_possible_responsesCountArgs>(
      args?: Subset<T, questions_possible_responsesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Questions_possible_responsesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions_possible_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Questions_possible_responsesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Questions_possible_responsesAggregateArgs>(args: Subset<T, Questions_possible_responsesAggregateArgs>): Prisma.PrismaPromise<GetQuestions_possible_responsesAggregateType<T>>

    /**
     * Group by Questions_possible_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_possible_responsesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questions_possible_responsesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questions_possible_responsesGroupByArgs['orderBy'] }
        : { orderBy?: questions_possible_responsesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questions_possible_responsesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestions_possible_responsesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions_possible_responses model
   */
  readonly fields: questions_possible_responsesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions_possible_responses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questions_possible_responsesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionsDefaultArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions_possible_responses model
   */ 
  interface questions_possible_responsesFieldRefs {
    readonly id: FieldRef<"questions_possible_responses", 'Bytes'>
    readonly content: FieldRef<"questions_possible_responses", 'String'>
    readonly question_id: FieldRef<"questions_possible_responses", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * questions_possible_responses findUnique
   */
  export type questions_possible_responsesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_possible_responses to fetch.
     */
    where: questions_possible_responsesWhereUniqueInput
  }

  /**
   * questions_possible_responses findUniqueOrThrow
   */
  export type questions_possible_responsesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_possible_responses to fetch.
     */
    where: questions_possible_responsesWhereUniqueInput
  }

  /**
   * questions_possible_responses findFirst
   */
  export type questions_possible_responsesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_possible_responses to fetch.
     */
    where?: questions_possible_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_possible_responses to fetch.
     */
    orderBy?: questions_possible_responsesOrderByWithRelationInput | questions_possible_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions_possible_responses.
     */
    cursor?: questions_possible_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_possible_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_possible_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions_possible_responses.
     */
    distinct?: Questions_possible_responsesScalarFieldEnum | Questions_possible_responsesScalarFieldEnum[]
  }

  /**
   * questions_possible_responses findFirstOrThrow
   */
  export type questions_possible_responsesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_possible_responses to fetch.
     */
    where?: questions_possible_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_possible_responses to fetch.
     */
    orderBy?: questions_possible_responsesOrderByWithRelationInput | questions_possible_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions_possible_responses.
     */
    cursor?: questions_possible_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_possible_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_possible_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions_possible_responses.
     */
    distinct?: Questions_possible_responsesScalarFieldEnum | Questions_possible_responsesScalarFieldEnum[]
  }

  /**
   * questions_possible_responses findMany
   */
  export type questions_possible_responsesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_possible_responses to fetch.
     */
    where?: questions_possible_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_possible_responses to fetch.
     */
    orderBy?: questions_possible_responsesOrderByWithRelationInput | questions_possible_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions_possible_responses.
     */
    cursor?: questions_possible_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_possible_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_possible_responses.
     */
    skip?: number
    distinct?: Questions_possible_responsesScalarFieldEnum | Questions_possible_responsesScalarFieldEnum[]
  }

  /**
   * questions_possible_responses create
   */
  export type questions_possible_responsesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * The data needed to create a questions_possible_responses.
     */
    data: XOR<questions_possible_responsesCreateInput, questions_possible_responsesUncheckedCreateInput>
  }

  /**
   * questions_possible_responses createMany
   */
  export type questions_possible_responsesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions_possible_responses.
     */
    data: questions_possible_responsesCreateManyInput | questions_possible_responsesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions_possible_responses update
   */
  export type questions_possible_responsesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * The data needed to update a questions_possible_responses.
     */
    data: XOR<questions_possible_responsesUpdateInput, questions_possible_responsesUncheckedUpdateInput>
    /**
     * Choose, which questions_possible_responses to update.
     */
    where: questions_possible_responsesWhereUniqueInput
  }

  /**
   * questions_possible_responses updateMany
   */
  export type questions_possible_responsesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions_possible_responses.
     */
    data: XOR<questions_possible_responsesUpdateManyMutationInput, questions_possible_responsesUncheckedUpdateManyInput>
    /**
     * Filter which questions_possible_responses to update
     */
    where?: questions_possible_responsesWhereInput
  }

  /**
   * questions_possible_responses upsert
   */
  export type questions_possible_responsesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * The filter to search for the questions_possible_responses to update in case it exists.
     */
    where: questions_possible_responsesWhereUniqueInput
    /**
     * In case the questions_possible_responses found by the `where` argument doesn't exist, create a new questions_possible_responses with this data.
     */
    create: XOR<questions_possible_responsesCreateInput, questions_possible_responsesUncheckedCreateInput>
    /**
     * In case the questions_possible_responses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questions_possible_responsesUpdateInput, questions_possible_responsesUncheckedUpdateInput>
  }

  /**
   * questions_possible_responses delete
   */
  export type questions_possible_responsesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
    /**
     * Filter which questions_possible_responses to delete.
     */
    where: questions_possible_responsesWhereUniqueInput
  }

  /**
   * questions_possible_responses deleteMany
   */
  export type questions_possible_responsesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions_possible_responses to delete
     */
    where?: questions_possible_responsesWhereInput
  }

  /**
   * questions_possible_responses without action
   */
  export type questions_possible_responsesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_possible_responses
     */
    select?: questions_possible_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_possible_responsesInclude<ExtArgs> | null
  }


  /**
   * Model questions_responses
   */

  export type AggregateQuestions_responses = {
    _count: Questions_responsesCountAggregateOutputType | null
    _min: Questions_responsesMinAggregateOutputType | null
    _max: Questions_responsesMaxAggregateOutputType | null
  }

  export type Questions_responsesMinAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    student_id: Uint8Array | null
    question_id: Uint8Array | null
  }

  export type Questions_responsesMaxAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    student_id: Uint8Array | null
    question_id: Uint8Array | null
  }

  export type Questions_responsesCountAggregateOutputType = {
    id: number
    content: number
    student_id: number
    question_id: number
    _all: number
  }


  export type Questions_responsesMinAggregateInputType = {
    id?: true
    content?: true
    student_id?: true
    question_id?: true
  }

  export type Questions_responsesMaxAggregateInputType = {
    id?: true
    content?: true
    student_id?: true
    question_id?: true
  }

  export type Questions_responsesCountAggregateInputType = {
    id?: true
    content?: true
    student_id?: true
    question_id?: true
    _all?: true
  }

  export type Questions_responsesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions_responses to aggregate.
     */
    where?: questions_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_responses to fetch.
     */
    orderBy?: questions_responsesOrderByWithRelationInput | questions_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questions_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions_responses
    **/
    _count?: true | Questions_responsesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Questions_responsesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Questions_responsesMaxAggregateInputType
  }

  export type GetQuestions_responsesAggregateType<T extends Questions_responsesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions_responses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions_responses[P]>
      : GetScalarType<T[P], AggregateQuestions_responses[P]>
  }




  export type questions_responsesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questions_responsesWhereInput
    orderBy?: questions_responsesOrderByWithAggregationInput | questions_responsesOrderByWithAggregationInput[]
    by: Questions_responsesScalarFieldEnum[] | Questions_responsesScalarFieldEnum
    having?: questions_responsesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Questions_responsesCountAggregateInputType | true
    _min?: Questions_responsesMinAggregateInputType
    _max?: Questions_responsesMaxAggregateInputType
  }

  export type Questions_responsesGroupByOutputType = {
    id: Uint8Array
    content: string
    student_id: Uint8Array
    question_id: Uint8Array
    _count: Questions_responsesCountAggregateOutputType | null
    _min: Questions_responsesMinAggregateOutputType | null
    _max: Questions_responsesMaxAggregateOutputType | null
  }

  type GetQuestions_responsesGroupByPayload<T extends questions_responsesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Questions_responsesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Questions_responsesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Questions_responsesGroupByOutputType[P]>
            : GetScalarType<T[P], Questions_responsesGroupByOutputType[P]>
        }
      >
    >


  export type questions_responsesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    student_id?: boolean
    question_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions_responses"]>



  export type questions_responsesSelectScalar = {
    id?: boolean
    content?: boolean
    student_id?: boolean
    question_id?: boolean
  }

  export type questions_responsesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }

  export type $questions_responsesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions_responses"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      questions: Prisma.$questionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      content: string
      student_id: Uint8Array
      question_id: Uint8Array
    }, ExtArgs["result"]["questions_responses"]>
    composites: {}
  }

  type questions_responsesGetPayload<S extends boolean | null | undefined | questions_responsesDefaultArgs> = $Result.GetResult<Prisma.$questions_responsesPayload, S>

  type questions_responsesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questions_responsesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Questions_responsesCountAggregateInputType | true
    }

  export interface questions_responsesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions_responses'], meta: { name: 'questions_responses' } }
    /**
     * Find zero or one Questions_responses that matches the filter.
     * @param {questions_responsesFindUniqueArgs} args - Arguments to find a Questions_responses
     * @example
     * // Get one Questions_responses
     * const questions_responses = await prisma.questions_responses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questions_responsesFindUniqueArgs>(args: SelectSubset<T, questions_responsesFindUniqueArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions_responses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questions_responsesFindUniqueOrThrowArgs} args - Arguments to find a Questions_responses
     * @example
     * // Get one Questions_responses
     * const questions_responses = await prisma.questions_responses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questions_responsesFindUniqueOrThrowArgs>(args: SelectSubset<T, questions_responsesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions_responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_responsesFindFirstArgs} args - Arguments to find a Questions_responses
     * @example
     * // Get one Questions_responses
     * const questions_responses = await prisma.questions_responses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questions_responsesFindFirstArgs>(args?: SelectSubset<T, questions_responsesFindFirstArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions_responses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_responsesFindFirstOrThrowArgs} args - Arguments to find a Questions_responses
     * @example
     * // Get one Questions_responses
     * const questions_responses = await prisma.questions_responses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questions_responsesFindFirstOrThrowArgs>(args?: SelectSubset<T, questions_responsesFindFirstOrThrowArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions_responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_responsesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions_responses
     * const questions_responses = await prisma.questions_responses.findMany()
     * 
     * // Get first 10 Questions_responses
     * const questions_responses = await prisma.questions_responses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questions_responsesWithIdOnly = await prisma.questions_responses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questions_responsesFindManyArgs>(args?: SelectSubset<T, questions_responsesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions_responses.
     * @param {questions_responsesCreateArgs} args - Arguments to create a Questions_responses.
     * @example
     * // Create one Questions_responses
     * const Questions_responses = await prisma.questions_responses.create({
     *   data: {
     *     // ... data to create a Questions_responses
     *   }
     * })
     * 
     */
    create<T extends questions_responsesCreateArgs>(args: SelectSubset<T, questions_responsesCreateArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions_responses.
     * @param {questions_responsesCreateManyArgs} args - Arguments to create many Questions_responses.
     * @example
     * // Create many Questions_responses
     * const questions_responses = await prisma.questions_responses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questions_responsesCreateManyArgs>(args?: SelectSubset<T, questions_responsesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions_responses.
     * @param {questions_responsesDeleteArgs} args - Arguments to delete one Questions_responses.
     * @example
     * // Delete one Questions_responses
     * const Questions_responses = await prisma.questions_responses.delete({
     *   where: {
     *     // ... filter to delete one Questions_responses
     *   }
     * })
     * 
     */
    delete<T extends questions_responsesDeleteArgs>(args: SelectSubset<T, questions_responsesDeleteArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions_responses.
     * @param {questions_responsesUpdateArgs} args - Arguments to update one Questions_responses.
     * @example
     * // Update one Questions_responses
     * const questions_responses = await prisma.questions_responses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questions_responsesUpdateArgs>(args: SelectSubset<T, questions_responsesUpdateArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions_responses.
     * @param {questions_responsesDeleteManyArgs} args - Arguments to filter Questions_responses to delete.
     * @example
     * // Delete a few Questions_responses
     * const { count } = await prisma.questions_responses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questions_responsesDeleteManyArgs>(args?: SelectSubset<T, questions_responsesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_responsesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions_responses
     * const questions_responses = await prisma.questions_responses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questions_responsesUpdateManyArgs>(args: SelectSubset<T, questions_responsesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions_responses.
     * @param {questions_responsesUpsertArgs} args - Arguments to update or create a Questions_responses.
     * @example
     * // Update or create a Questions_responses
     * const questions_responses = await prisma.questions_responses.upsert({
     *   create: {
     *     // ... data to create a Questions_responses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions_responses we want to update
     *   }
     * })
     */
    upsert<T extends questions_responsesUpsertArgs>(args: SelectSubset<T, questions_responsesUpsertArgs<ExtArgs>>): Prisma__questions_responsesClient<$Result.GetResult<Prisma.$questions_responsesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_responsesCountArgs} args - Arguments to filter Questions_responses to count.
     * @example
     * // Count the number of Questions_responses
     * const count = await prisma.questions_responses.count({
     *   where: {
     *     // ... the filter for the Questions_responses we want to count
     *   }
     * })
    **/
    count<T extends questions_responsesCountArgs>(
      args?: Subset<T, questions_responsesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Questions_responsesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Questions_responsesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Questions_responsesAggregateArgs>(args: Subset<T, Questions_responsesAggregateArgs>): Prisma.PrismaPromise<GetQuestions_responsesAggregateType<T>>

    /**
     * Group by Questions_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_responsesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questions_responsesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questions_responsesGroupByArgs['orderBy'] }
        : { orderBy?: questions_responsesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questions_responsesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestions_responsesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions_responses model
   */
  readonly fields: questions_responsesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions_responses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questions_responsesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    questions<T extends questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionsDefaultArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions_responses model
   */ 
  interface questions_responsesFieldRefs {
    readonly id: FieldRef<"questions_responses", 'Bytes'>
    readonly content: FieldRef<"questions_responses", 'String'>
    readonly student_id: FieldRef<"questions_responses", 'Bytes'>
    readonly question_id: FieldRef<"questions_responses", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * questions_responses findUnique
   */
  export type questions_responsesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_responses to fetch.
     */
    where: questions_responsesWhereUniqueInput
  }

  /**
   * questions_responses findUniqueOrThrow
   */
  export type questions_responsesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_responses to fetch.
     */
    where: questions_responsesWhereUniqueInput
  }

  /**
   * questions_responses findFirst
   */
  export type questions_responsesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_responses to fetch.
     */
    where?: questions_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_responses to fetch.
     */
    orderBy?: questions_responsesOrderByWithRelationInput | questions_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions_responses.
     */
    cursor?: questions_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions_responses.
     */
    distinct?: Questions_responsesScalarFieldEnum | Questions_responsesScalarFieldEnum[]
  }

  /**
   * questions_responses findFirstOrThrow
   */
  export type questions_responsesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_responses to fetch.
     */
    where?: questions_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_responses to fetch.
     */
    orderBy?: questions_responsesOrderByWithRelationInput | questions_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions_responses.
     */
    cursor?: questions_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions_responses.
     */
    distinct?: Questions_responsesScalarFieldEnum | Questions_responsesScalarFieldEnum[]
  }

  /**
   * questions_responses findMany
   */
  export type questions_responsesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * Filter, which questions_responses to fetch.
     */
    where?: questions_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_responses to fetch.
     */
    orderBy?: questions_responsesOrderByWithRelationInput | questions_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions_responses.
     */
    cursor?: questions_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_responses.
     */
    skip?: number
    distinct?: Questions_responsesScalarFieldEnum | Questions_responsesScalarFieldEnum[]
  }

  /**
   * questions_responses create
   */
  export type questions_responsesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * The data needed to create a questions_responses.
     */
    data: XOR<questions_responsesCreateInput, questions_responsesUncheckedCreateInput>
  }

  /**
   * questions_responses createMany
   */
  export type questions_responsesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions_responses.
     */
    data: questions_responsesCreateManyInput | questions_responsesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions_responses update
   */
  export type questions_responsesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * The data needed to update a questions_responses.
     */
    data: XOR<questions_responsesUpdateInput, questions_responsesUncheckedUpdateInput>
    /**
     * Choose, which questions_responses to update.
     */
    where: questions_responsesWhereUniqueInput
  }

  /**
   * questions_responses updateMany
   */
  export type questions_responsesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions_responses.
     */
    data: XOR<questions_responsesUpdateManyMutationInput, questions_responsesUncheckedUpdateManyInput>
    /**
     * Filter which questions_responses to update
     */
    where?: questions_responsesWhereInput
  }

  /**
   * questions_responses upsert
   */
  export type questions_responsesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * The filter to search for the questions_responses to update in case it exists.
     */
    where: questions_responsesWhereUniqueInput
    /**
     * In case the questions_responses found by the `where` argument doesn't exist, create a new questions_responses with this data.
     */
    create: XOR<questions_responsesCreateInput, questions_responsesUncheckedCreateInput>
    /**
     * In case the questions_responses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questions_responsesUpdateInput, questions_responsesUncheckedUpdateInput>
  }

  /**
   * questions_responses delete
   */
  export type questions_responsesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
    /**
     * Filter which questions_responses to delete.
     */
    where: questions_responsesWhereUniqueInput
  }

  /**
   * questions_responses deleteMany
   */
  export type questions_responsesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions_responses to delete
     */
    where?: questions_responsesWhereInput
  }

  /**
   * questions_responses without action
   */
  export type questions_responsesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_responses
     */
    select?: questions_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_responsesInclude<ExtArgs> | null
  }


  /**
   * Model questions_types
   */

  export type AggregateQuestions_types = {
    _count: Questions_typesCountAggregateOutputType | null
    _min: Questions_typesMinAggregateOutputType | null
    _max: Questions_typesMaxAggregateOutputType | null
  }

  export type Questions_typesMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Questions_typesMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
  }

  export type Questions_typesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Questions_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Questions_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Questions_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Questions_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions_types to aggregate.
     */
    where?: questions_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_types to fetch.
     */
    orderBy?: questions_typesOrderByWithRelationInput | questions_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questions_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions_types
    **/
    _count?: true | Questions_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Questions_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Questions_typesMaxAggregateInputType
  }

  export type GetQuestions_typesAggregateType<T extends Questions_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions_types[P]>
      : GetScalarType<T[P], AggregateQuestions_types[P]>
  }




  export type questions_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questions_typesWhereInput
    orderBy?: questions_typesOrderByWithAggregationInput | questions_typesOrderByWithAggregationInput[]
    by: Questions_typesScalarFieldEnum[] | Questions_typesScalarFieldEnum
    having?: questions_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Questions_typesCountAggregateInputType | true
    _min?: Questions_typesMinAggregateInputType
    _max?: Questions_typesMaxAggregateInputType
  }

  export type Questions_typesGroupByOutputType = {
    id: Uint8Array
    name: string
    _count: Questions_typesCountAggregateOutputType | null
    _min: Questions_typesMinAggregateOutputType | null
    _max: Questions_typesMaxAggregateOutputType | null
  }

  type GetQuestions_typesGroupByPayload<T extends questions_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Questions_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Questions_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Questions_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Questions_typesGroupByOutputType[P]>
        }
      >
    >


  export type questions_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    questions?: boolean | questions_types$questionsArgs<ExtArgs>
    _count?: boolean | Questions_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions_types"]>



  export type questions_typesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type questions_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | questions_types$questionsArgs<ExtArgs>
    _count?: boolean | Questions_typesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questions_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions_types"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
    }, ExtArgs["result"]["questions_types"]>
    composites: {}
  }

  type questions_typesGetPayload<S extends boolean | null | undefined | questions_typesDefaultArgs> = $Result.GetResult<Prisma.$questions_typesPayload, S>

  type questions_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questions_typesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Questions_typesCountAggregateInputType | true
    }

  export interface questions_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions_types'], meta: { name: 'questions_types' } }
    /**
     * Find zero or one Questions_types that matches the filter.
     * @param {questions_typesFindUniqueArgs} args - Arguments to find a Questions_types
     * @example
     * // Get one Questions_types
     * const questions_types = await prisma.questions_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questions_typesFindUniqueArgs>(args: SelectSubset<T, questions_typesFindUniqueArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questions_typesFindUniqueOrThrowArgs} args - Arguments to find a Questions_types
     * @example
     * // Get one Questions_types
     * const questions_types = await prisma.questions_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questions_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, questions_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_typesFindFirstArgs} args - Arguments to find a Questions_types
     * @example
     * // Get one Questions_types
     * const questions_types = await prisma.questions_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questions_typesFindFirstArgs>(args?: SelectSubset<T, questions_typesFindFirstArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_typesFindFirstOrThrowArgs} args - Arguments to find a Questions_types
     * @example
     * // Get one Questions_types
     * const questions_types = await prisma.questions_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questions_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, questions_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions_types
     * const questions_types = await prisma.questions_types.findMany()
     * 
     * // Get first 10 Questions_types
     * const questions_types = await prisma.questions_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questions_typesWithIdOnly = await prisma.questions_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questions_typesFindManyArgs>(args?: SelectSubset<T, questions_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions_types.
     * @param {questions_typesCreateArgs} args - Arguments to create a Questions_types.
     * @example
     * // Create one Questions_types
     * const Questions_types = await prisma.questions_types.create({
     *   data: {
     *     // ... data to create a Questions_types
     *   }
     * })
     * 
     */
    create<T extends questions_typesCreateArgs>(args: SelectSubset<T, questions_typesCreateArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions_types.
     * @param {questions_typesCreateManyArgs} args - Arguments to create many Questions_types.
     * @example
     * // Create many Questions_types
     * const questions_types = await prisma.questions_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questions_typesCreateManyArgs>(args?: SelectSubset<T, questions_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions_types.
     * @param {questions_typesDeleteArgs} args - Arguments to delete one Questions_types.
     * @example
     * // Delete one Questions_types
     * const Questions_types = await prisma.questions_types.delete({
     *   where: {
     *     // ... filter to delete one Questions_types
     *   }
     * })
     * 
     */
    delete<T extends questions_typesDeleteArgs>(args: SelectSubset<T, questions_typesDeleteArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions_types.
     * @param {questions_typesUpdateArgs} args - Arguments to update one Questions_types.
     * @example
     * // Update one Questions_types
     * const questions_types = await prisma.questions_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questions_typesUpdateArgs>(args: SelectSubset<T, questions_typesUpdateArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions_types.
     * @param {questions_typesDeleteManyArgs} args - Arguments to filter Questions_types to delete.
     * @example
     * // Delete a few Questions_types
     * const { count } = await prisma.questions_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questions_typesDeleteManyArgs>(args?: SelectSubset<T, questions_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions_types
     * const questions_types = await prisma.questions_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questions_typesUpdateManyArgs>(args: SelectSubset<T, questions_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions_types.
     * @param {questions_typesUpsertArgs} args - Arguments to update or create a Questions_types.
     * @example
     * // Update or create a Questions_types
     * const questions_types = await prisma.questions_types.upsert({
     *   create: {
     *     // ... data to create a Questions_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions_types we want to update
     *   }
     * })
     */
    upsert<T extends questions_typesUpsertArgs>(args: SelectSubset<T, questions_typesUpsertArgs<ExtArgs>>): Prisma__questions_typesClient<$Result.GetResult<Prisma.$questions_typesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_typesCountArgs} args - Arguments to filter Questions_types to count.
     * @example
     * // Count the number of Questions_types
     * const count = await prisma.questions_types.count({
     *   where: {
     *     // ... the filter for the Questions_types we want to count
     *   }
     * })
    **/
    count<T extends questions_typesCountArgs>(
      args?: Subset<T, questions_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Questions_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Questions_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Questions_typesAggregateArgs>(args: Subset<T, Questions_typesAggregateArgs>): Prisma.PrismaPromise<GetQuestions_typesAggregateType<T>>

    /**
     * Group by Questions_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questions_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questions_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questions_typesGroupByArgs['orderBy'] }
        : { orderBy?: questions_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questions_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestions_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions_types model
   */
  readonly fields: questions_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questions_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends questions_types$questionsArgs<ExtArgs> = {}>(args?: Subset<T, questions_types$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions_types model
   */ 
  interface questions_typesFieldRefs {
    readonly id: FieldRef<"questions_types", 'Bytes'>
    readonly name: FieldRef<"questions_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * questions_types findUnique
   */
  export type questions_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * Filter, which questions_types to fetch.
     */
    where: questions_typesWhereUniqueInput
  }

  /**
   * questions_types findUniqueOrThrow
   */
  export type questions_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * Filter, which questions_types to fetch.
     */
    where: questions_typesWhereUniqueInput
  }

  /**
   * questions_types findFirst
   */
  export type questions_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * Filter, which questions_types to fetch.
     */
    where?: questions_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_types to fetch.
     */
    orderBy?: questions_typesOrderByWithRelationInput | questions_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions_types.
     */
    cursor?: questions_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions_types.
     */
    distinct?: Questions_typesScalarFieldEnum | Questions_typesScalarFieldEnum[]
  }

  /**
   * questions_types findFirstOrThrow
   */
  export type questions_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * Filter, which questions_types to fetch.
     */
    where?: questions_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_types to fetch.
     */
    orderBy?: questions_typesOrderByWithRelationInput | questions_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions_types.
     */
    cursor?: questions_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions_types.
     */
    distinct?: Questions_typesScalarFieldEnum | Questions_typesScalarFieldEnum[]
  }

  /**
   * questions_types findMany
   */
  export type questions_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * Filter, which questions_types to fetch.
     */
    where?: questions_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions_types to fetch.
     */
    orderBy?: questions_typesOrderByWithRelationInput | questions_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions_types.
     */
    cursor?: questions_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions_types.
     */
    skip?: number
    distinct?: Questions_typesScalarFieldEnum | Questions_typesScalarFieldEnum[]
  }

  /**
   * questions_types create
   */
  export type questions_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a questions_types.
     */
    data: XOR<questions_typesCreateInput, questions_typesUncheckedCreateInput>
  }

  /**
   * questions_types createMany
   */
  export type questions_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions_types.
     */
    data: questions_typesCreateManyInput | questions_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions_types update
   */
  export type questions_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a questions_types.
     */
    data: XOR<questions_typesUpdateInput, questions_typesUncheckedUpdateInput>
    /**
     * Choose, which questions_types to update.
     */
    where: questions_typesWhereUniqueInput
  }

  /**
   * questions_types updateMany
   */
  export type questions_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions_types.
     */
    data: XOR<questions_typesUpdateManyMutationInput, questions_typesUncheckedUpdateManyInput>
    /**
     * Filter which questions_types to update
     */
    where?: questions_typesWhereInput
  }

  /**
   * questions_types upsert
   */
  export type questions_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the questions_types to update in case it exists.
     */
    where: questions_typesWhereUniqueInput
    /**
     * In case the questions_types found by the `where` argument doesn't exist, create a new questions_types with this data.
     */
    create: XOR<questions_typesCreateInput, questions_typesUncheckedCreateInput>
    /**
     * In case the questions_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questions_typesUpdateInput, questions_typesUncheckedUpdateInput>
  }

  /**
   * questions_types delete
   */
  export type questions_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
    /**
     * Filter which questions_types to delete.
     */
    where: questions_typesWhereUniqueInput
  }

  /**
   * questions_types deleteMany
   */
  export type questions_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions_types to delete
     */
    where?: questions_typesWhereInput
  }

  /**
   * questions_types.questions
   */
  export type questions_types$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions_types without action
   */
  export type questions_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions_types
     */
    select?: questions_typesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questions_typesInclude<ExtArgs> | null
  }


  /**
   * Model attempt_questions
   */

  export type AggregateAttempt_questions = {
    _count: Attempt_questionsCountAggregateOutputType | null
    _min: Attempt_questionsMinAggregateOutputType | null
    _max: Attempt_questionsMaxAggregateOutputType | null
  }

  export type Attempt_questionsMinAggregateOutputType = {
    id: Uint8Array | null
    attempt_id: Uint8Array | null
    open_question_id: Uint8Array | null
    closed_question_id: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type | null
    created_at: Date | null
  }

  export type Attempt_questionsMaxAggregateOutputType = {
    id: Uint8Array | null
    attempt_id: Uint8Array | null
    open_question_id: Uint8Array | null
    closed_question_id: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type | null
    created_at: Date | null
  }

  export type Attempt_questionsCountAggregateOutputType = {
    id: number
    attempt_id: number
    open_question_id: number
    closed_question_id: number
    question_type: number
    created_at: number
    _all: number
  }


  export type Attempt_questionsMinAggregateInputType = {
    id?: true
    attempt_id?: true
    open_question_id?: true
    closed_question_id?: true
    question_type?: true
    created_at?: true
  }

  export type Attempt_questionsMaxAggregateInputType = {
    id?: true
    attempt_id?: true
    open_question_id?: true
    closed_question_id?: true
    question_type?: true
    created_at?: true
  }

  export type Attempt_questionsCountAggregateInputType = {
    id?: true
    attempt_id?: true
    open_question_id?: true
    closed_question_id?: true
    question_type?: true
    created_at?: true
    _all?: true
  }

  export type Attempt_questionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attempt_questions to aggregate.
     */
    where?: attempt_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempt_questions to fetch.
     */
    orderBy?: attempt_questionsOrderByWithRelationInput | attempt_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attempt_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempt_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempt_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attempt_questions
    **/
    _count?: true | Attempt_questionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Attempt_questionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Attempt_questionsMaxAggregateInputType
  }

  export type GetAttempt_questionsAggregateType<T extends Attempt_questionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAttempt_questions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttempt_questions[P]>
      : GetScalarType<T[P], AggregateAttempt_questions[P]>
  }




  export type attempt_questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attempt_questionsWhereInput
    orderBy?: attempt_questionsOrderByWithAggregationInput | attempt_questionsOrderByWithAggregationInput[]
    by: Attempt_questionsScalarFieldEnum[] | Attempt_questionsScalarFieldEnum
    having?: attempt_questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Attempt_questionsCountAggregateInputType | true
    _min?: Attempt_questionsMinAggregateInputType
    _max?: Attempt_questionsMaxAggregateInputType
  }

  export type Attempt_questionsGroupByOutputType = {
    id: Uint8Array
    attempt_id: Uint8Array
    open_question_id: Uint8Array | null
    closed_question_id: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at: Date | null
    _count: Attempt_questionsCountAggregateOutputType | null
    _min: Attempt_questionsMinAggregateOutputType | null
    _max: Attempt_questionsMaxAggregateOutputType | null
  }

  type GetAttempt_questionsGroupByPayload<T extends attempt_questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Attempt_questionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Attempt_questionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Attempt_questionsGroupByOutputType[P]>
            : GetScalarType<T[P], Attempt_questionsGroupByOutputType[P]>
        }
      >
    >


  export type attempt_questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attempt_id?: boolean
    open_question_id?: boolean
    closed_question_id?: boolean
    question_type?: boolean
    created_at?: boolean
    attempts?: boolean | attemptsDefaultArgs<ExtArgs>
    open_questions?: boolean | attempt_questions$open_questionsArgs<ExtArgs>
    closed_questions?: boolean | attempt_questions$closed_questionsArgs<ExtArgs>
  }, ExtArgs["result"]["attempt_questions"]>



  export type attempt_questionsSelectScalar = {
    id?: boolean
    attempt_id?: boolean
    open_question_id?: boolean
    closed_question_id?: boolean
    question_type?: boolean
    created_at?: boolean
  }

  export type attempt_questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | attemptsDefaultArgs<ExtArgs>
    open_questions?: boolean | attempt_questions$open_questionsArgs<ExtArgs>
    closed_questions?: boolean | attempt_questions$closed_questionsArgs<ExtArgs>
  }

  export type $attempt_questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attempt_questions"
    objects: {
      attempts: Prisma.$attemptsPayload<ExtArgs>
      open_questions: Prisma.$open_questionsPayload<ExtArgs> | null
      closed_questions: Prisma.$closed_questionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      attempt_id: Uint8Array
      open_question_id: Uint8Array | null
      closed_question_id: Uint8Array | null
      question_type: $Enums.attempt_questions_question_type
      created_at: Date | null
    }, ExtArgs["result"]["attempt_questions"]>
    composites: {}
  }

  type attempt_questionsGetPayload<S extends boolean | null | undefined | attempt_questionsDefaultArgs> = $Result.GetResult<Prisma.$attempt_questionsPayload, S>

  type attempt_questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attempt_questionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Attempt_questionsCountAggregateInputType | true
    }

  export interface attempt_questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attempt_questions'], meta: { name: 'attempt_questions' } }
    /**
     * Find zero or one Attempt_questions that matches the filter.
     * @param {attempt_questionsFindUniqueArgs} args - Arguments to find a Attempt_questions
     * @example
     * // Get one Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attempt_questionsFindUniqueArgs>(args: SelectSubset<T, attempt_questionsFindUniqueArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attempt_questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attempt_questionsFindUniqueOrThrowArgs} args - Arguments to find a Attempt_questions
     * @example
     * // Get one Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attempt_questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, attempt_questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attempt_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attempt_questionsFindFirstArgs} args - Arguments to find a Attempt_questions
     * @example
     * // Get one Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attempt_questionsFindFirstArgs>(args?: SelectSubset<T, attempt_questionsFindFirstArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attempt_questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attempt_questionsFindFirstOrThrowArgs} args - Arguments to find a Attempt_questions
     * @example
     * // Get one Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attempt_questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, attempt_questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attempt_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attempt_questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.findMany()
     * 
     * // Get first 10 Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attempt_questionsWithIdOnly = await prisma.attempt_questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attempt_questionsFindManyArgs>(args?: SelectSubset<T, attempt_questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attempt_questions.
     * @param {attempt_questionsCreateArgs} args - Arguments to create a Attempt_questions.
     * @example
     * // Create one Attempt_questions
     * const Attempt_questions = await prisma.attempt_questions.create({
     *   data: {
     *     // ... data to create a Attempt_questions
     *   }
     * })
     * 
     */
    create<T extends attempt_questionsCreateArgs>(args: SelectSubset<T, attempt_questionsCreateArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attempt_questions.
     * @param {attempt_questionsCreateManyArgs} args - Arguments to create many Attempt_questions.
     * @example
     * // Create many Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attempt_questionsCreateManyArgs>(args?: SelectSubset<T, attempt_questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attempt_questions.
     * @param {attempt_questionsDeleteArgs} args - Arguments to delete one Attempt_questions.
     * @example
     * // Delete one Attempt_questions
     * const Attempt_questions = await prisma.attempt_questions.delete({
     *   where: {
     *     // ... filter to delete one Attempt_questions
     *   }
     * })
     * 
     */
    delete<T extends attempt_questionsDeleteArgs>(args: SelectSubset<T, attempt_questionsDeleteArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attempt_questions.
     * @param {attempt_questionsUpdateArgs} args - Arguments to update one Attempt_questions.
     * @example
     * // Update one Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attempt_questionsUpdateArgs>(args: SelectSubset<T, attempt_questionsUpdateArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attempt_questions.
     * @param {attempt_questionsDeleteManyArgs} args - Arguments to filter Attempt_questions to delete.
     * @example
     * // Delete a few Attempt_questions
     * const { count } = await prisma.attempt_questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attempt_questionsDeleteManyArgs>(args?: SelectSubset<T, attempt_questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attempt_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attempt_questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attempt_questionsUpdateManyArgs>(args: SelectSubset<T, attempt_questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attempt_questions.
     * @param {attempt_questionsUpsertArgs} args - Arguments to update or create a Attempt_questions.
     * @example
     * // Update or create a Attempt_questions
     * const attempt_questions = await prisma.attempt_questions.upsert({
     *   create: {
     *     // ... data to create a Attempt_questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attempt_questions we want to update
     *   }
     * })
     */
    upsert<T extends attempt_questionsUpsertArgs>(args: SelectSubset<T, attempt_questionsUpsertArgs<ExtArgs>>): Prisma__attempt_questionsClient<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attempt_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attempt_questionsCountArgs} args - Arguments to filter Attempt_questions to count.
     * @example
     * // Count the number of Attempt_questions
     * const count = await prisma.attempt_questions.count({
     *   where: {
     *     // ... the filter for the Attempt_questions we want to count
     *   }
     * })
    **/
    count<T extends attempt_questionsCountArgs>(
      args?: Subset<T, attempt_questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Attempt_questionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attempt_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Attempt_questionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Attempt_questionsAggregateArgs>(args: Subset<T, Attempt_questionsAggregateArgs>): Prisma.PrismaPromise<GetAttempt_questionsAggregateType<T>>

    /**
     * Group by Attempt_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attempt_questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attempt_questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attempt_questionsGroupByArgs['orderBy'] }
        : { orderBy?: attempt_questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attempt_questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttempt_questionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attempt_questions model
   */
  readonly fields: attempt_questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attempt_questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attempt_questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempts<T extends attemptsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, attemptsDefaultArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    open_questions<T extends attempt_questions$open_questionsArgs<ExtArgs> = {}>(args?: Subset<T, attempt_questions$open_questionsArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    closed_questions<T extends attempt_questions$closed_questionsArgs<ExtArgs> = {}>(args?: Subset<T, attempt_questions$closed_questionsArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attempt_questions model
   */ 
  interface attempt_questionsFieldRefs {
    readonly id: FieldRef<"attempt_questions", 'Bytes'>
    readonly attempt_id: FieldRef<"attempt_questions", 'Bytes'>
    readonly open_question_id: FieldRef<"attempt_questions", 'Bytes'>
    readonly closed_question_id: FieldRef<"attempt_questions", 'Bytes'>
    readonly question_type: FieldRef<"attempt_questions", 'attempt_questions_question_type'>
    readonly created_at: FieldRef<"attempt_questions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attempt_questions findUnique
   */
  export type attempt_questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * Filter, which attempt_questions to fetch.
     */
    where: attempt_questionsWhereUniqueInput
  }

  /**
   * attempt_questions findUniqueOrThrow
   */
  export type attempt_questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * Filter, which attempt_questions to fetch.
     */
    where: attempt_questionsWhereUniqueInput
  }

  /**
   * attempt_questions findFirst
   */
  export type attempt_questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * Filter, which attempt_questions to fetch.
     */
    where?: attempt_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempt_questions to fetch.
     */
    orderBy?: attempt_questionsOrderByWithRelationInput | attempt_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attempt_questions.
     */
    cursor?: attempt_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempt_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempt_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attempt_questions.
     */
    distinct?: Attempt_questionsScalarFieldEnum | Attempt_questionsScalarFieldEnum[]
  }

  /**
   * attempt_questions findFirstOrThrow
   */
  export type attempt_questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * Filter, which attempt_questions to fetch.
     */
    where?: attempt_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempt_questions to fetch.
     */
    orderBy?: attempt_questionsOrderByWithRelationInput | attempt_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attempt_questions.
     */
    cursor?: attempt_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempt_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempt_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attempt_questions.
     */
    distinct?: Attempt_questionsScalarFieldEnum | Attempt_questionsScalarFieldEnum[]
  }

  /**
   * attempt_questions findMany
   */
  export type attempt_questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * Filter, which attempt_questions to fetch.
     */
    where?: attempt_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempt_questions to fetch.
     */
    orderBy?: attempt_questionsOrderByWithRelationInput | attempt_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attempt_questions.
     */
    cursor?: attempt_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempt_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempt_questions.
     */
    skip?: number
    distinct?: Attempt_questionsScalarFieldEnum | Attempt_questionsScalarFieldEnum[]
  }

  /**
   * attempt_questions create
   */
  export type attempt_questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a attempt_questions.
     */
    data: XOR<attempt_questionsCreateInput, attempt_questionsUncheckedCreateInput>
  }

  /**
   * attempt_questions createMany
   */
  export type attempt_questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attempt_questions.
     */
    data: attempt_questionsCreateManyInput | attempt_questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attempt_questions update
   */
  export type attempt_questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a attempt_questions.
     */
    data: XOR<attempt_questionsUpdateInput, attempt_questionsUncheckedUpdateInput>
    /**
     * Choose, which attempt_questions to update.
     */
    where: attempt_questionsWhereUniqueInput
  }

  /**
   * attempt_questions updateMany
   */
  export type attempt_questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attempt_questions.
     */
    data: XOR<attempt_questionsUpdateManyMutationInput, attempt_questionsUncheckedUpdateManyInput>
    /**
     * Filter which attempt_questions to update
     */
    where?: attempt_questionsWhereInput
  }

  /**
   * attempt_questions upsert
   */
  export type attempt_questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the attempt_questions to update in case it exists.
     */
    where: attempt_questionsWhereUniqueInput
    /**
     * In case the attempt_questions found by the `where` argument doesn't exist, create a new attempt_questions with this data.
     */
    create: XOR<attempt_questionsCreateInput, attempt_questionsUncheckedCreateInput>
    /**
     * In case the attempt_questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attempt_questionsUpdateInput, attempt_questionsUncheckedUpdateInput>
  }

  /**
   * attempt_questions delete
   */
  export type attempt_questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    /**
     * Filter which attempt_questions to delete.
     */
    where: attempt_questionsWhereUniqueInput
  }

  /**
   * attempt_questions deleteMany
   */
  export type attempt_questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attempt_questions to delete
     */
    where?: attempt_questionsWhereInput
  }

  /**
   * attempt_questions.open_questions
   */
  export type attempt_questions$open_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    where?: open_questionsWhereInput
  }

  /**
   * attempt_questions.closed_questions
   */
  export type attempt_questions$closed_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    where?: closed_questionsWhereInput
  }

  /**
   * attempt_questions without action
   */
  export type attempt_questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
  }


  /**
   * Model attempts
   */

  export type AggregateAttempts = {
    _count: AttemptsCountAggregateOutputType | null
    _avg: AttemptsAvgAggregateOutputType | null
    _sum: AttemptsSumAggregateOutputType | null
    _min: AttemptsMinAggregateOutputType | null
    _max: AttemptsMaxAggregateOutputType | null
  }

  export type AttemptsAvgAggregateOutputType = {
    attempt_number: number | null
    total_score: number | null
    max_score: number | null
  }

  export type AttemptsSumAggregateOutputType = {
    attempt_number: number | null
    total_score: number | null
    max_score: number | null
  }

  export type AttemptsMinAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    exam_id: Uint8Array | null
    attempt_number: number | null
    total_score: number | null
    max_score: number | null
    graded: boolean | null
    start_time: Date | null
    end_time: Date | null
  }

  export type AttemptsMaxAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    exam_id: Uint8Array | null
    attempt_number: number | null
    total_score: number | null
    max_score: number | null
    graded: boolean | null
    start_time: Date | null
    end_time: Date | null
  }

  export type AttemptsCountAggregateOutputType = {
    id: number
    student_id: number
    exam_id: number
    attempt_number: number
    total_score: number
    max_score: number
    graded: number
    start_time: number
    end_time: number
    _all: number
  }


  export type AttemptsAvgAggregateInputType = {
    attempt_number?: true
    total_score?: true
    max_score?: true
  }

  export type AttemptsSumAggregateInputType = {
    attempt_number?: true
    total_score?: true
    max_score?: true
  }

  export type AttemptsMinAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    attempt_number?: true
    total_score?: true
    max_score?: true
    graded?: true
    start_time?: true
    end_time?: true
  }

  export type AttemptsMaxAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    attempt_number?: true
    total_score?: true
    max_score?: true
    graded?: true
    start_time?: true
    end_time?: true
  }

  export type AttemptsCountAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    attempt_number?: true
    total_score?: true
    max_score?: true
    graded?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type AttemptsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attempts to aggregate.
     */
    where?: attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempts to fetch.
     */
    orderBy?: attemptsOrderByWithRelationInput | attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attempts
    **/
    _count?: true | AttemptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttemptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttemptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttemptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttemptsMaxAggregateInputType
  }

  export type GetAttemptsAggregateType<T extends AttemptsAggregateArgs> = {
        [P in keyof T & keyof AggregateAttempts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttempts[P]>
      : GetScalarType<T[P], AggregateAttempts[P]>
  }




  export type attemptsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attemptsWhereInput
    orderBy?: attemptsOrderByWithAggregationInput | attemptsOrderByWithAggregationInput[]
    by: AttemptsScalarFieldEnum[] | AttemptsScalarFieldEnum
    having?: attemptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttemptsCountAggregateInputType | true
    _avg?: AttemptsAvgAggregateInputType
    _sum?: AttemptsSumAggregateInputType
    _min?: AttemptsMinAggregateInputType
    _max?: AttemptsMaxAggregateInputType
  }

  export type AttemptsGroupByOutputType = {
    id: Uint8Array
    student_id: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score: number | null
    max_score: number | null
    graded: boolean
    start_time: Date
    end_time: Date | null
    _count: AttemptsCountAggregateOutputType | null
    _avg: AttemptsAvgAggregateOutputType | null
    _sum: AttemptsSumAggregateOutputType | null
    _min: AttemptsMinAggregateOutputType | null
    _max: AttemptsMaxAggregateOutputType | null
  }

  type GetAttemptsGroupByPayload<T extends attemptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttemptsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttemptsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttemptsGroupByOutputType[P]>
            : GetScalarType<T[P], AttemptsGroupByOutputType[P]>
        }
      >
    >


  export type attemptsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    exam_id?: boolean
    attempt_number?: boolean
    total_score?: boolean
    max_score?: boolean
    graded?: boolean
    start_time?: boolean
    end_time?: boolean
    attempt_questions?: boolean | attempts$attempt_questionsArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
    student_closed_answers?: boolean | attempts$student_closed_answersArgs<ExtArgs>
    student_open_answers?: boolean | attempts$student_open_answersArgs<ExtArgs>
    _count?: boolean | AttemptsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attempts"]>



  export type attemptsSelectScalar = {
    id?: boolean
    student_id?: boolean
    exam_id?: boolean
    attempt_number?: boolean
    total_score?: boolean
    max_score?: boolean
    graded?: boolean
    start_time?: boolean
    end_time?: boolean
  }

  export type attemptsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt_questions?: boolean | attempts$attempt_questionsArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
    student_closed_answers?: boolean | attempts$student_closed_answersArgs<ExtArgs>
    student_open_answers?: boolean | attempts$student_open_answersArgs<ExtArgs>
    _count?: boolean | AttemptsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $attemptsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attempts"
    objects: {
      attempt_questions: Prisma.$attempt_questionsPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs>
      exams: Prisma.$examsPayload<ExtArgs>
      student_closed_answers: Prisma.$student_closed_answersPayload<ExtArgs>[]
      student_open_answers: Prisma.$student_open_answersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      student_id: Uint8Array
      exam_id: Uint8Array
      attempt_number: number
      total_score: number | null
      max_score: number | null
      graded: boolean
      start_time: Date
      end_time: Date | null
    }, ExtArgs["result"]["attempts"]>
    composites: {}
  }

  type attemptsGetPayload<S extends boolean | null | undefined | attemptsDefaultArgs> = $Result.GetResult<Prisma.$attemptsPayload, S>

  type attemptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attemptsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttemptsCountAggregateInputType | true
    }

  export interface attemptsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attempts'], meta: { name: 'attempts' } }
    /**
     * Find zero or one Attempts that matches the filter.
     * @param {attemptsFindUniqueArgs} args - Arguments to find a Attempts
     * @example
     * // Get one Attempts
     * const attempts = await prisma.attempts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attemptsFindUniqueArgs>(args: SelectSubset<T, attemptsFindUniqueArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attempts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attemptsFindUniqueOrThrowArgs} args - Arguments to find a Attempts
     * @example
     * // Get one Attempts
     * const attempts = await prisma.attempts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attemptsFindUniqueOrThrowArgs>(args: SelectSubset<T, attemptsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attemptsFindFirstArgs} args - Arguments to find a Attempts
     * @example
     * // Get one Attempts
     * const attempts = await prisma.attempts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attemptsFindFirstArgs>(args?: SelectSubset<T, attemptsFindFirstArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attempts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attemptsFindFirstOrThrowArgs} args - Arguments to find a Attempts
     * @example
     * // Get one Attempts
     * const attempts = await prisma.attempts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attemptsFindFirstOrThrowArgs>(args?: SelectSubset<T, attemptsFindFirstOrThrowArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attemptsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attempts
     * const attempts = await prisma.attempts.findMany()
     * 
     * // Get first 10 Attempts
     * const attempts = await prisma.attempts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attemptsWithIdOnly = await prisma.attempts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attemptsFindManyArgs>(args?: SelectSubset<T, attemptsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attempts.
     * @param {attemptsCreateArgs} args - Arguments to create a Attempts.
     * @example
     * // Create one Attempts
     * const Attempts = await prisma.attempts.create({
     *   data: {
     *     // ... data to create a Attempts
     *   }
     * })
     * 
     */
    create<T extends attemptsCreateArgs>(args: SelectSubset<T, attemptsCreateArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attempts.
     * @param {attemptsCreateManyArgs} args - Arguments to create many Attempts.
     * @example
     * // Create many Attempts
     * const attempts = await prisma.attempts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attemptsCreateManyArgs>(args?: SelectSubset<T, attemptsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attempts.
     * @param {attemptsDeleteArgs} args - Arguments to delete one Attempts.
     * @example
     * // Delete one Attempts
     * const Attempts = await prisma.attempts.delete({
     *   where: {
     *     // ... filter to delete one Attempts
     *   }
     * })
     * 
     */
    delete<T extends attemptsDeleteArgs>(args: SelectSubset<T, attemptsDeleteArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attempts.
     * @param {attemptsUpdateArgs} args - Arguments to update one Attempts.
     * @example
     * // Update one Attempts
     * const attempts = await prisma.attempts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attemptsUpdateArgs>(args: SelectSubset<T, attemptsUpdateArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attempts.
     * @param {attemptsDeleteManyArgs} args - Arguments to filter Attempts to delete.
     * @example
     * // Delete a few Attempts
     * const { count } = await prisma.attempts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attemptsDeleteManyArgs>(args?: SelectSubset<T, attemptsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attemptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attempts
     * const attempts = await prisma.attempts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attemptsUpdateManyArgs>(args: SelectSubset<T, attemptsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attempts.
     * @param {attemptsUpsertArgs} args - Arguments to update or create a Attempts.
     * @example
     * // Update or create a Attempts
     * const attempts = await prisma.attempts.upsert({
     *   create: {
     *     // ... data to create a Attempts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attempts we want to update
     *   }
     * })
     */
    upsert<T extends attemptsUpsertArgs>(args: SelectSubset<T, attemptsUpsertArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attemptsCountArgs} args - Arguments to filter Attempts to count.
     * @example
     * // Count the number of Attempts
     * const count = await prisma.attempts.count({
     *   where: {
     *     // ... the filter for the Attempts we want to count
     *   }
     * })
    **/
    count<T extends attemptsCountArgs>(
      args?: Subset<T, attemptsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttemptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttemptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttemptsAggregateArgs>(args: Subset<T, AttemptsAggregateArgs>): Prisma.PrismaPromise<GetAttemptsAggregateType<T>>

    /**
     * Group by Attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attemptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attemptsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attemptsGroupByArgs['orderBy'] }
        : { orderBy?: attemptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attemptsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttemptsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attempts model
   */
  readonly fields: attemptsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attempts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attemptsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt_questions<T extends attempts$attempt_questionsArgs<ExtArgs> = {}>(args?: Subset<T, attempts$attempt_questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exams<T extends examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examsDefaultArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student_closed_answers<T extends attempts$student_closed_answersArgs<ExtArgs> = {}>(args?: Subset<T, attempts$student_closed_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findMany"> | Null>
    student_open_answers<T extends attempts$student_open_answersArgs<ExtArgs> = {}>(args?: Subset<T, attempts$student_open_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attempts model
   */ 
  interface attemptsFieldRefs {
    readonly id: FieldRef<"attempts", 'Bytes'>
    readonly student_id: FieldRef<"attempts", 'Bytes'>
    readonly exam_id: FieldRef<"attempts", 'Bytes'>
    readonly attempt_number: FieldRef<"attempts", 'Int'>
    readonly total_score: FieldRef<"attempts", 'Int'>
    readonly max_score: FieldRef<"attempts", 'Int'>
    readonly graded: FieldRef<"attempts", 'Boolean'>
    readonly start_time: FieldRef<"attempts", 'DateTime'>
    readonly end_time: FieldRef<"attempts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attempts findUnique
   */
  export type attemptsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * Filter, which attempts to fetch.
     */
    where: attemptsWhereUniqueInput
  }

  /**
   * attempts findUniqueOrThrow
   */
  export type attemptsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * Filter, which attempts to fetch.
     */
    where: attemptsWhereUniqueInput
  }

  /**
   * attempts findFirst
   */
  export type attemptsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * Filter, which attempts to fetch.
     */
    where?: attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempts to fetch.
     */
    orderBy?: attemptsOrderByWithRelationInput | attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attempts.
     */
    cursor?: attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attempts.
     */
    distinct?: AttemptsScalarFieldEnum | AttemptsScalarFieldEnum[]
  }

  /**
   * attempts findFirstOrThrow
   */
  export type attemptsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * Filter, which attempts to fetch.
     */
    where?: attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempts to fetch.
     */
    orderBy?: attemptsOrderByWithRelationInput | attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attempts.
     */
    cursor?: attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attempts.
     */
    distinct?: AttemptsScalarFieldEnum | AttemptsScalarFieldEnum[]
  }

  /**
   * attempts findMany
   */
  export type attemptsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * Filter, which attempts to fetch.
     */
    where?: attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attempts to fetch.
     */
    orderBy?: attemptsOrderByWithRelationInput | attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attempts.
     */
    cursor?: attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attempts.
     */
    skip?: number
    distinct?: AttemptsScalarFieldEnum | AttemptsScalarFieldEnum[]
  }

  /**
   * attempts create
   */
  export type attemptsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * The data needed to create a attempts.
     */
    data: XOR<attemptsCreateInput, attemptsUncheckedCreateInput>
  }

  /**
   * attempts createMany
   */
  export type attemptsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attempts.
     */
    data: attemptsCreateManyInput | attemptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attempts update
   */
  export type attemptsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * The data needed to update a attempts.
     */
    data: XOR<attemptsUpdateInput, attemptsUncheckedUpdateInput>
    /**
     * Choose, which attempts to update.
     */
    where: attemptsWhereUniqueInput
  }

  /**
   * attempts updateMany
   */
  export type attemptsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attempts.
     */
    data: XOR<attemptsUpdateManyMutationInput, attemptsUncheckedUpdateManyInput>
    /**
     * Filter which attempts to update
     */
    where?: attemptsWhereInput
  }

  /**
   * attempts upsert
   */
  export type attemptsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * The filter to search for the attempts to update in case it exists.
     */
    where: attemptsWhereUniqueInput
    /**
     * In case the attempts found by the `where` argument doesn't exist, create a new attempts with this data.
     */
    create: XOR<attemptsCreateInput, attemptsUncheckedCreateInput>
    /**
     * In case the attempts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attemptsUpdateInput, attemptsUncheckedUpdateInput>
  }

  /**
   * attempts delete
   */
  export type attemptsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
    /**
     * Filter which attempts to delete.
     */
    where: attemptsWhereUniqueInput
  }

  /**
   * attempts deleteMany
   */
  export type attemptsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attempts to delete
     */
    where?: attemptsWhereInput
  }

  /**
   * attempts.attempt_questions
   */
  export type attempts$attempt_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    where?: attempt_questionsWhereInput
    orderBy?: attempt_questionsOrderByWithRelationInput | attempt_questionsOrderByWithRelationInput[]
    cursor?: attempt_questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Attempt_questionsScalarFieldEnum | Attempt_questionsScalarFieldEnum[]
  }

  /**
   * attempts.student_closed_answers
   */
  export type attempts$student_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    where?: student_closed_answersWhereInput
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    cursor?: student_closed_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_closed_answersScalarFieldEnum | Student_closed_answersScalarFieldEnum[]
  }

  /**
   * attempts.student_open_answers
   */
  export type attempts$student_open_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    where?: student_open_answersWhereInput
    orderBy?: student_open_answersOrderByWithRelationInput | student_open_answersOrderByWithRelationInput[]
    cursor?: student_open_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_open_answersScalarFieldEnum | Student_open_answersScalarFieldEnum[]
  }

  /**
   * attempts without action
   */
  export type attemptsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempts
     */
    select?: attemptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attemptsInclude<ExtArgs> | null
  }


  /**
   * Model classes_exams
   */

  export type AggregateClasses_exams = {
    _count: Classes_examsCountAggregateOutputType | null
    _min: Classes_examsMinAggregateOutputType | null
    _max: Classes_examsMaxAggregateOutputType | null
  }

  export type Classes_examsMinAggregateOutputType = {
    class_id: Uint8Array | null
    exam_id: Uint8Array | null
  }

  export type Classes_examsMaxAggregateOutputType = {
    class_id: Uint8Array | null
    exam_id: Uint8Array | null
  }

  export type Classes_examsCountAggregateOutputType = {
    class_id: number
    exam_id: number
    _all: number
  }


  export type Classes_examsMinAggregateInputType = {
    class_id?: true
    exam_id?: true
  }

  export type Classes_examsMaxAggregateInputType = {
    class_id?: true
    exam_id?: true
  }

  export type Classes_examsCountAggregateInputType = {
    class_id?: true
    exam_id?: true
    _all?: true
  }

  export type Classes_examsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes_exams to aggregate.
     */
    where?: classes_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes_exams to fetch.
     */
    orderBy?: classes_examsOrderByWithRelationInput | classes_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: classes_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned classes_exams
    **/
    _count?: true | Classes_examsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Classes_examsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Classes_examsMaxAggregateInputType
  }

  export type GetClasses_examsAggregateType<T extends Classes_examsAggregateArgs> = {
        [P in keyof T & keyof AggregateClasses_exams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasses_exams[P]>
      : GetScalarType<T[P], AggregateClasses_exams[P]>
  }




  export type classes_examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classes_examsWhereInput
    orderBy?: classes_examsOrderByWithAggregationInput | classes_examsOrderByWithAggregationInput[]
    by: Classes_examsScalarFieldEnum[] | Classes_examsScalarFieldEnum
    having?: classes_examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Classes_examsCountAggregateInputType | true
    _min?: Classes_examsMinAggregateInputType
    _max?: Classes_examsMaxAggregateInputType
  }

  export type Classes_examsGroupByOutputType = {
    class_id: Uint8Array
    exam_id: Uint8Array
    _count: Classes_examsCountAggregateOutputType | null
    _min: Classes_examsMinAggregateOutputType | null
    _max: Classes_examsMaxAggregateOutputType | null
  }

  type GetClasses_examsGroupByPayload<T extends classes_examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Classes_examsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Classes_examsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Classes_examsGroupByOutputType[P]>
            : GetScalarType<T[P], Classes_examsGroupByOutputType[P]>
        }
      >
    >


  export type classes_examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_id?: boolean
    exam_id?: boolean
    classes?: boolean | classesDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classes_exams"]>



  export type classes_examsSelectScalar = {
    class_id?: boolean
    exam_id?: boolean
  }

  export type classes_examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | classesDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }

  export type $classes_examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "classes_exams"
    objects: {
      classes: Prisma.$classesPayload<ExtArgs>
      exams: Prisma.$examsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      class_id: Uint8Array
      exam_id: Uint8Array
    }, ExtArgs["result"]["classes_exams"]>
    composites: {}
  }

  type classes_examsGetPayload<S extends boolean | null | undefined | classes_examsDefaultArgs> = $Result.GetResult<Prisma.$classes_examsPayload, S>

  type classes_examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<classes_examsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Classes_examsCountAggregateInputType | true
    }

  export interface classes_examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['classes_exams'], meta: { name: 'classes_exams' } }
    /**
     * Find zero or one Classes_exams that matches the filter.
     * @param {classes_examsFindUniqueArgs} args - Arguments to find a Classes_exams
     * @example
     * // Get one Classes_exams
     * const classes_exams = await prisma.classes_exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends classes_examsFindUniqueArgs>(args: SelectSubset<T, classes_examsFindUniqueArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Classes_exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {classes_examsFindUniqueOrThrowArgs} args - Arguments to find a Classes_exams
     * @example
     * // Get one Classes_exams
     * const classes_exams = await prisma.classes_exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends classes_examsFindUniqueOrThrowArgs>(args: SelectSubset<T, classes_examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Classes_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classes_examsFindFirstArgs} args - Arguments to find a Classes_exams
     * @example
     * // Get one Classes_exams
     * const classes_exams = await prisma.classes_exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends classes_examsFindFirstArgs>(args?: SelectSubset<T, classes_examsFindFirstArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Classes_exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classes_examsFindFirstOrThrowArgs} args - Arguments to find a Classes_exams
     * @example
     * // Get one Classes_exams
     * const classes_exams = await prisma.classes_exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends classes_examsFindFirstOrThrowArgs>(args?: SelectSubset<T, classes_examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classes_examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes_exams
     * const classes_exams = await prisma.classes_exams.findMany()
     * 
     * // Get first 10 Classes_exams
     * const classes_exams = await prisma.classes_exams.findMany({ take: 10 })
     * 
     * // Only select the `class_id`
     * const classes_examsWithClass_idOnly = await prisma.classes_exams.findMany({ select: { class_id: true } })
     * 
     */
    findMany<T extends classes_examsFindManyArgs>(args?: SelectSubset<T, classes_examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Classes_exams.
     * @param {classes_examsCreateArgs} args - Arguments to create a Classes_exams.
     * @example
     * // Create one Classes_exams
     * const Classes_exams = await prisma.classes_exams.create({
     *   data: {
     *     // ... data to create a Classes_exams
     *   }
     * })
     * 
     */
    create<T extends classes_examsCreateArgs>(args: SelectSubset<T, classes_examsCreateArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes_exams.
     * @param {classes_examsCreateManyArgs} args - Arguments to create many Classes_exams.
     * @example
     * // Create many Classes_exams
     * const classes_exams = await prisma.classes_exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends classes_examsCreateManyArgs>(args?: SelectSubset<T, classes_examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Classes_exams.
     * @param {classes_examsDeleteArgs} args - Arguments to delete one Classes_exams.
     * @example
     * // Delete one Classes_exams
     * const Classes_exams = await prisma.classes_exams.delete({
     *   where: {
     *     // ... filter to delete one Classes_exams
     *   }
     * })
     * 
     */
    delete<T extends classes_examsDeleteArgs>(args: SelectSubset<T, classes_examsDeleteArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Classes_exams.
     * @param {classes_examsUpdateArgs} args - Arguments to update one Classes_exams.
     * @example
     * // Update one Classes_exams
     * const classes_exams = await prisma.classes_exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends classes_examsUpdateArgs>(args: SelectSubset<T, classes_examsUpdateArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes_exams.
     * @param {classes_examsDeleteManyArgs} args - Arguments to filter Classes_exams to delete.
     * @example
     * // Delete a few Classes_exams
     * const { count } = await prisma.classes_exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends classes_examsDeleteManyArgs>(args?: SelectSubset<T, classes_examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classes_examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes_exams
     * const classes_exams = await prisma.classes_exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends classes_examsUpdateManyArgs>(args: SelectSubset<T, classes_examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Classes_exams.
     * @param {classes_examsUpsertArgs} args - Arguments to update or create a Classes_exams.
     * @example
     * // Update or create a Classes_exams
     * const classes_exams = await prisma.classes_exams.upsert({
     *   create: {
     *     // ... data to create a Classes_exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classes_exams we want to update
     *   }
     * })
     */
    upsert<T extends classes_examsUpsertArgs>(args: SelectSubset<T, classes_examsUpsertArgs<ExtArgs>>): Prisma__classes_examsClient<$Result.GetResult<Prisma.$classes_examsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classes_examsCountArgs} args - Arguments to filter Classes_exams to count.
     * @example
     * // Count the number of Classes_exams
     * const count = await prisma.classes_exams.count({
     *   where: {
     *     // ... the filter for the Classes_exams we want to count
     *   }
     * })
    **/
    count<T extends classes_examsCountArgs>(
      args?: Subset<T, classes_examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Classes_examsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classes_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Classes_examsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Classes_examsAggregateArgs>(args: Subset<T, Classes_examsAggregateArgs>): Prisma.PrismaPromise<GetClasses_examsAggregateType<T>>

    /**
     * Group by Classes_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classes_examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends classes_examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: classes_examsGroupByArgs['orderBy'] }
        : { orderBy?: classes_examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, classes_examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClasses_examsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the classes_exams model
   */
  readonly fields: classes_examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for classes_exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__classes_examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends classesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classesDefaultArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exams<T extends examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examsDefaultArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the classes_exams model
   */ 
  interface classes_examsFieldRefs {
    readonly class_id: FieldRef<"classes_exams", 'Bytes'>
    readonly exam_id: FieldRef<"classes_exams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * classes_exams findUnique
   */
  export type classes_examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * Filter, which classes_exams to fetch.
     */
    where: classes_examsWhereUniqueInput
  }

  /**
   * classes_exams findUniqueOrThrow
   */
  export type classes_examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * Filter, which classes_exams to fetch.
     */
    where: classes_examsWhereUniqueInput
  }

  /**
   * classes_exams findFirst
   */
  export type classes_examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * Filter, which classes_exams to fetch.
     */
    where?: classes_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes_exams to fetch.
     */
    orderBy?: classes_examsOrderByWithRelationInput | classes_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes_exams.
     */
    cursor?: classes_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes_exams.
     */
    distinct?: Classes_examsScalarFieldEnum | Classes_examsScalarFieldEnum[]
  }

  /**
   * classes_exams findFirstOrThrow
   */
  export type classes_examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * Filter, which classes_exams to fetch.
     */
    where?: classes_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes_exams to fetch.
     */
    orderBy?: classes_examsOrderByWithRelationInput | classes_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes_exams.
     */
    cursor?: classes_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes_exams.
     */
    distinct?: Classes_examsScalarFieldEnum | Classes_examsScalarFieldEnum[]
  }

  /**
   * classes_exams findMany
   */
  export type classes_examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * Filter, which classes_exams to fetch.
     */
    where?: classes_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes_exams to fetch.
     */
    orderBy?: classes_examsOrderByWithRelationInput | classes_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing classes_exams.
     */
    cursor?: classes_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes_exams.
     */
    skip?: number
    distinct?: Classes_examsScalarFieldEnum | Classes_examsScalarFieldEnum[]
  }

  /**
   * classes_exams create
   */
  export type classes_examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * The data needed to create a classes_exams.
     */
    data: XOR<classes_examsCreateInput, classes_examsUncheckedCreateInput>
  }

  /**
   * classes_exams createMany
   */
  export type classes_examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many classes_exams.
     */
    data: classes_examsCreateManyInput | classes_examsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * classes_exams update
   */
  export type classes_examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * The data needed to update a classes_exams.
     */
    data: XOR<classes_examsUpdateInput, classes_examsUncheckedUpdateInput>
    /**
     * Choose, which classes_exams to update.
     */
    where: classes_examsWhereUniqueInput
  }

  /**
   * classes_exams updateMany
   */
  export type classes_examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update classes_exams.
     */
    data: XOR<classes_examsUpdateManyMutationInput, classes_examsUncheckedUpdateManyInput>
    /**
     * Filter which classes_exams to update
     */
    where?: classes_examsWhereInput
  }

  /**
   * classes_exams upsert
   */
  export type classes_examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * The filter to search for the classes_exams to update in case it exists.
     */
    where: classes_examsWhereUniqueInput
    /**
     * In case the classes_exams found by the `where` argument doesn't exist, create a new classes_exams with this data.
     */
    create: XOR<classes_examsCreateInput, classes_examsUncheckedCreateInput>
    /**
     * In case the classes_exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<classes_examsUpdateInput, classes_examsUncheckedUpdateInput>
  }

  /**
   * classes_exams delete
   */
  export type classes_examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
    /**
     * Filter which classes_exams to delete.
     */
    where: classes_examsWhereUniqueInput
  }

  /**
   * classes_exams deleteMany
   */
  export type classes_examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes_exams to delete
     */
    where?: classes_examsWhereInput
  }

  /**
   * classes_exams without action
   */
  export type classes_examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes_exams
     */
    select?: classes_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classes_examsInclude<ExtArgs> | null
  }


  /**
   * Model closed_answers
   */

  export type AggregateClosed_answers = {
    _count: Closed_answersCountAggregateOutputType | null
    _min: Closed_answersMinAggregateOutputType | null
    _max: Closed_answersMaxAggregateOutputType | null
  }

  export type Closed_answersMinAggregateOutputType = {
    id: Uint8Array | null
    closed_question_id: Uint8Array | null
    is_correct: boolean | null
    description: string | null
  }

  export type Closed_answersMaxAggregateOutputType = {
    id: Uint8Array | null
    closed_question_id: Uint8Array | null
    is_correct: boolean | null
    description: string | null
  }

  export type Closed_answersCountAggregateOutputType = {
    id: number
    closed_question_id: number
    is_correct: number
    description: number
    _all: number
  }


  export type Closed_answersMinAggregateInputType = {
    id?: true
    closed_question_id?: true
    is_correct?: true
    description?: true
  }

  export type Closed_answersMaxAggregateInputType = {
    id?: true
    closed_question_id?: true
    is_correct?: true
    description?: true
  }

  export type Closed_answersCountAggregateInputType = {
    id?: true
    closed_question_id?: true
    is_correct?: true
    description?: true
    _all?: true
  }

  export type Closed_answersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which closed_answers to aggregate.
     */
    where?: closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_answers to fetch.
     */
    orderBy?: closed_answersOrderByWithRelationInput | closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned closed_answers
    **/
    _count?: true | Closed_answersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Closed_answersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Closed_answersMaxAggregateInputType
  }

  export type GetClosed_answersAggregateType<T extends Closed_answersAggregateArgs> = {
        [P in keyof T & keyof AggregateClosed_answers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClosed_answers[P]>
      : GetScalarType<T[P], AggregateClosed_answers[P]>
  }




  export type closed_answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: closed_answersWhereInput
    orderBy?: closed_answersOrderByWithAggregationInput | closed_answersOrderByWithAggregationInput[]
    by: Closed_answersScalarFieldEnum[] | Closed_answersScalarFieldEnum
    having?: closed_answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Closed_answersCountAggregateInputType | true
    _min?: Closed_answersMinAggregateInputType
    _max?: Closed_answersMaxAggregateInputType
  }

  export type Closed_answersGroupByOutputType = {
    id: Uint8Array
    closed_question_id: Uint8Array
    is_correct: boolean | null
    description: string
    _count: Closed_answersCountAggregateOutputType | null
    _min: Closed_answersMinAggregateOutputType | null
    _max: Closed_answersMaxAggregateOutputType | null
  }

  type GetClosed_answersGroupByPayload<T extends closed_answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Closed_answersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Closed_answersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Closed_answersGroupByOutputType[P]>
            : GetScalarType<T[P], Closed_answersGroupByOutputType[P]>
        }
      >
    >


  export type closed_answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    closed_question_id?: boolean
    is_correct?: boolean
    description?: boolean
    closed_questions?: boolean | closed_questionsDefaultArgs<ExtArgs>
    student_closed_answers?: boolean | closed_answers$student_closed_answersArgs<ExtArgs>
    _count?: boolean | Closed_answersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closed_answers"]>



  export type closed_answersSelectScalar = {
    id?: boolean
    closed_question_id?: boolean
    is_correct?: boolean
    description?: boolean
  }

  export type closed_answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closed_questions?: boolean | closed_questionsDefaultArgs<ExtArgs>
    student_closed_answers?: boolean | closed_answers$student_closed_answersArgs<ExtArgs>
    _count?: boolean | Closed_answersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $closed_answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "closed_answers"
    objects: {
      closed_questions: Prisma.$closed_questionsPayload<ExtArgs>
      student_closed_answers: Prisma.$student_closed_answersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      closed_question_id: Uint8Array
      is_correct: boolean | null
      description: string
    }, ExtArgs["result"]["closed_answers"]>
    composites: {}
  }

  type closed_answersGetPayload<S extends boolean | null | undefined | closed_answersDefaultArgs> = $Result.GetResult<Prisma.$closed_answersPayload, S>

  type closed_answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<closed_answersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Closed_answersCountAggregateInputType | true
    }

  export interface closed_answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['closed_answers'], meta: { name: 'closed_answers' } }
    /**
     * Find zero or one Closed_answers that matches the filter.
     * @param {closed_answersFindUniqueArgs} args - Arguments to find a Closed_answers
     * @example
     * // Get one Closed_answers
     * const closed_answers = await prisma.closed_answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends closed_answersFindUniqueArgs>(args: SelectSubset<T, closed_answersFindUniqueArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Closed_answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {closed_answersFindUniqueOrThrowArgs} args - Arguments to find a Closed_answers
     * @example
     * // Get one Closed_answers
     * const closed_answers = await prisma.closed_answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends closed_answersFindUniqueOrThrowArgs>(args: SelectSubset<T, closed_answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Closed_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_answersFindFirstArgs} args - Arguments to find a Closed_answers
     * @example
     * // Get one Closed_answers
     * const closed_answers = await prisma.closed_answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends closed_answersFindFirstArgs>(args?: SelectSubset<T, closed_answersFindFirstArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Closed_answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_answersFindFirstOrThrowArgs} args - Arguments to find a Closed_answers
     * @example
     * // Get one Closed_answers
     * const closed_answers = await prisma.closed_answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends closed_answersFindFirstOrThrowArgs>(args?: SelectSubset<T, closed_answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Closed_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Closed_answers
     * const closed_answers = await prisma.closed_answers.findMany()
     * 
     * // Get first 10 Closed_answers
     * const closed_answers = await prisma.closed_answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const closed_answersWithIdOnly = await prisma.closed_answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends closed_answersFindManyArgs>(args?: SelectSubset<T, closed_answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Closed_answers.
     * @param {closed_answersCreateArgs} args - Arguments to create a Closed_answers.
     * @example
     * // Create one Closed_answers
     * const Closed_answers = await prisma.closed_answers.create({
     *   data: {
     *     // ... data to create a Closed_answers
     *   }
     * })
     * 
     */
    create<T extends closed_answersCreateArgs>(args: SelectSubset<T, closed_answersCreateArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Closed_answers.
     * @param {closed_answersCreateManyArgs} args - Arguments to create many Closed_answers.
     * @example
     * // Create many Closed_answers
     * const closed_answers = await prisma.closed_answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends closed_answersCreateManyArgs>(args?: SelectSubset<T, closed_answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Closed_answers.
     * @param {closed_answersDeleteArgs} args - Arguments to delete one Closed_answers.
     * @example
     * // Delete one Closed_answers
     * const Closed_answers = await prisma.closed_answers.delete({
     *   where: {
     *     // ... filter to delete one Closed_answers
     *   }
     * })
     * 
     */
    delete<T extends closed_answersDeleteArgs>(args: SelectSubset<T, closed_answersDeleteArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Closed_answers.
     * @param {closed_answersUpdateArgs} args - Arguments to update one Closed_answers.
     * @example
     * // Update one Closed_answers
     * const closed_answers = await prisma.closed_answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends closed_answersUpdateArgs>(args: SelectSubset<T, closed_answersUpdateArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Closed_answers.
     * @param {closed_answersDeleteManyArgs} args - Arguments to filter Closed_answers to delete.
     * @example
     * // Delete a few Closed_answers
     * const { count } = await prisma.closed_answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends closed_answersDeleteManyArgs>(args?: SelectSubset<T, closed_answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Closed_answers
     * const closed_answers = await prisma.closed_answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends closed_answersUpdateManyArgs>(args: SelectSubset<T, closed_answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Closed_answers.
     * @param {closed_answersUpsertArgs} args - Arguments to update or create a Closed_answers.
     * @example
     * // Update or create a Closed_answers
     * const closed_answers = await prisma.closed_answers.upsert({
     *   create: {
     *     // ... data to create a Closed_answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Closed_answers we want to update
     *   }
     * })
     */
    upsert<T extends closed_answersUpsertArgs>(args: SelectSubset<T, closed_answersUpsertArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_answersCountArgs} args - Arguments to filter Closed_answers to count.
     * @example
     * // Count the number of Closed_answers
     * const count = await prisma.closed_answers.count({
     *   where: {
     *     // ... the filter for the Closed_answers we want to count
     *   }
     * })
    **/
    count<T extends closed_answersCountArgs>(
      args?: Subset<T, closed_answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Closed_answersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Closed_answersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Closed_answersAggregateArgs>(args: Subset<T, Closed_answersAggregateArgs>): Prisma.PrismaPromise<GetClosed_answersAggregateType<T>>

    /**
     * Group by Closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends closed_answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: closed_answersGroupByArgs['orderBy'] }
        : { orderBy?: closed_answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, closed_answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClosed_answersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the closed_answers model
   */
  readonly fields: closed_answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for closed_answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__closed_answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    closed_questions<T extends closed_questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, closed_questionsDefaultArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student_closed_answers<T extends closed_answers$student_closed_answersArgs<ExtArgs> = {}>(args?: Subset<T, closed_answers$student_closed_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the closed_answers model
   */ 
  interface closed_answersFieldRefs {
    readonly id: FieldRef<"closed_answers", 'Bytes'>
    readonly closed_question_id: FieldRef<"closed_answers", 'Bytes'>
    readonly is_correct: FieldRef<"closed_answers", 'Boolean'>
    readonly description: FieldRef<"closed_answers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * closed_answers findUnique
   */
  export type closed_answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which closed_answers to fetch.
     */
    where: closed_answersWhereUniqueInput
  }

  /**
   * closed_answers findUniqueOrThrow
   */
  export type closed_answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which closed_answers to fetch.
     */
    where: closed_answersWhereUniqueInput
  }

  /**
   * closed_answers findFirst
   */
  export type closed_answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which closed_answers to fetch.
     */
    where?: closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_answers to fetch.
     */
    orderBy?: closed_answersOrderByWithRelationInput | closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for closed_answers.
     */
    cursor?: closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of closed_answers.
     */
    distinct?: Closed_answersScalarFieldEnum | Closed_answersScalarFieldEnum[]
  }

  /**
   * closed_answers findFirstOrThrow
   */
  export type closed_answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which closed_answers to fetch.
     */
    where?: closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_answers to fetch.
     */
    orderBy?: closed_answersOrderByWithRelationInput | closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for closed_answers.
     */
    cursor?: closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of closed_answers.
     */
    distinct?: Closed_answersScalarFieldEnum | Closed_answersScalarFieldEnum[]
  }

  /**
   * closed_answers findMany
   */
  export type closed_answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which closed_answers to fetch.
     */
    where?: closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_answers to fetch.
     */
    orderBy?: closed_answersOrderByWithRelationInput | closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing closed_answers.
     */
    cursor?: closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_answers.
     */
    skip?: number
    distinct?: Closed_answersScalarFieldEnum | Closed_answersScalarFieldEnum[]
  }

  /**
   * closed_answers create
   */
  export type closed_answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * The data needed to create a closed_answers.
     */
    data: XOR<closed_answersCreateInput, closed_answersUncheckedCreateInput>
  }

  /**
   * closed_answers createMany
   */
  export type closed_answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many closed_answers.
     */
    data: closed_answersCreateManyInput | closed_answersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * closed_answers update
   */
  export type closed_answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * The data needed to update a closed_answers.
     */
    data: XOR<closed_answersUpdateInput, closed_answersUncheckedUpdateInput>
    /**
     * Choose, which closed_answers to update.
     */
    where: closed_answersWhereUniqueInput
  }

  /**
   * closed_answers updateMany
   */
  export type closed_answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update closed_answers.
     */
    data: XOR<closed_answersUpdateManyMutationInput, closed_answersUncheckedUpdateManyInput>
    /**
     * Filter which closed_answers to update
     */
    where?: closed_answersWhereInput
  }

  /**
   * closed_answers upsert
   */
  export type closed_answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * The filter to search for the closed_answers to update in case it exists.
     */
    where: closed_answersWhereUniqueInput
    /**
     * In case the closed_answers found by the `where` argument doesn't exist, create a new closed_answers with this data.
     */
    create: XOR<closed_answersCreateInput, closed_answersUncheckedCreateInput>
    /**
     * In case the closed_answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<closed_answersUpdateInput, closed_answersUncheckedUpdateInput>
  }

  /**
   * closed_answers delete
   */
  export type closed_answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    /**
     * Filter which closed_answers to delete.
     */
    where: closed_answersWhereUniqueInput
  }

  /**
   * closed_answers deleteMany
   */
  export type closed_answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which closed_answers to delete
     */
    where?: closed_answersWhereInput
  }

  /**
   * closed_answers.student_closed_answers
   */
  export type closed_answers$student_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    where?: student_closed_answersWhereInput
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    cursor?: student_closed_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_closed_answersScalarFieldEnum | Student_closed_answersScalarFieldEnum[]
  }

  /**
   * closed_answers without action
   */
  export type closed_answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
  }


  /**
   * Model closed_questions
   */

  export type AggregateClosed_questions = {
    _count: Closed_questionsCountAggregateOutputType | null
    _avg: Closed_questionsAvgAggregateOutputType | null
    _sum: Closed_questionsSumAggregateOutputType | null
    _min: Closed_questionsMinAggregateOutputType | null
    _max: Closed_questionsMaxAggregateOutputType | null
  }

  export type Closed_questionsAvgAggregateOutputType = {
    score: number | null
  }

  export type Closed_questionsSumAggregateOutputType = {
    score: number | null
  }

  export type Closed_questionsMinAggregateOutputType = {
    id: Uint8Array | null
    exam_id: Uint8Array | null
    score: number | null
    is_multiple: boolean | null
    description: string | null
  }

  export type Closed_questionsMaxAggregateOutputType = {
    id: Uint8Array | null
    exam_id: Uint8Array | null
    score: number | null
    is_multiple: boolean | null
    description: string | null
  }

  export type Closed_questionsCountAggregateOutputType = {
    id: number
    exam_id: number
    score: number
    is_multiple: number
    description: number
    _all: number
  }


  export type Closed_questionsAvgAggregateInputType = {
    score?: true
  }

  export type Closed_questionsSumAggregateInputType = {
    score?: true
  }

  export type Closed_questionsMinAggregateInputType = {
    id?: true
    exam_id?: true
    score?: true
    is_multiple?: true
    description?: true
  }

  export type Closed_questionsMaxAggregateInputType = {
    id?: true
    exam_id?: true
    score?: true
    is_multiple?: true
    description?: true
  }

  export type Closed_questionsCountAggregateInputType = {
    id?: true
    exam_id?: true
    score?: true
    is_multiple?: true
    description?: true
    _all?: true
  }

  export type Closed_questionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which closed_questions to aggregate.
     */
    where?: closed_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_questions to fetch.
     */
    orderBy?: closed_questionsOrderByWithRelationInput | closed_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: closed_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned closed_questions
    **/
    _count?: true | Closed_questionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Closed_questionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Closed_questionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Closed_questionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Closed_questionsMaxAggregateInputType
  }

  export type GetClosed_questionsAggregateType<T extends Closed_questionsAggregateArgs> = {
        [P in keyof T & keyof AggregateClosed_questions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClosed_questions[P]>
      : GetScalarType<T[P], AggregateClosed_questions[P]>
  }




  export type closed_questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: closed_questionsWhereInput
    orderBy?: closed_questionsOrderByWithAggregationInput | closed_questionsOrderByWithAggregationInput[]
    by: Closed_questionsScalarFieldEnum[] | Closed_questionsScalarFieldEnum
    having?: closed_questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Closed_questionsCountAggregateInputType | true
    _avg?: Closed_questionsAvgAggregateInputType
    _sum?: Closed_questionsSumAggregateInputType
    _min?: Closed_questionsMinAggregateInputType
    _max?: Closed_questionsMaxAggregateInputType
  }

  export type Closed_questionsGroupByOutputType = {
    id: Uint8Array
    exam_id: Uint8Array
    score: number | null
    is_multiple: boolean | null
    description: string
    _count: Closed_questionsCountAggregateOutputType | null
    _avg: Closed_questionsAvgAggregateOutputType | null
    _sum: Closed_questionsSumAggregateOutputType | null
    _min: Closed_questionsMinAggregateOutputType | null
    _max: Closed_questionsMaxAggregateOutputType | null
  }

  type GetClosed_questionsGroupByPayload<T extends closed_questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Closed_questionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Closed_questionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Closed_questionsGroupByOutputType[P]>
            : GetScalarType<T[P], Closed_questionsGroupByOutputType[P]>
        }
      >
    >


  export type closed_questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exam_id?: boolean
    score?: boolean
    is_multiple?: boolean
    description?: boolean
    attempt_questions?: boolean | closed_questions$attempt_questionsArgs<ExtArgs>
    closed_answers?: boolean | closed_questions$closed_answersArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
    student_closed_answers?: boolean | closed_questions$student_closed_answersArgs<ExtArgs>
    _count?: boolean | Closed_questionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closed_questions"]>



  export type closed_questionsSelectScalar = {
    id?: boolean
    exam_id?: boolean
    score?: boolean
    is_multiple?: boolean
    description?: boolean
  }

  export type closed_questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt_questions?: boolean | closed_questions$attempt_questionsArgs<ExtArgs>
    closed_answers?: boolean | closed_questions$closed_answersArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
    student_closed_answers?: boolean | closed_questions$student_closed_answersArgs<ExtArgs>
    _count?: boolean | Closed_questionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $closed_questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "closed_questions"
    objects: {
      attempt_questions: Prisma.$attempt_questionsPayload<ExtArgs>[]
      closed_answers: Prisma.$closed_answersPayload<ExtArgs>[]
      exams: Prisma.$examsPayload<ExtArgs>
      student_closed_answers: Prisma.$student_closed_answersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      exam_id: Uint8Array
      score: number | null
      is_multiple: boolean | null
      description: string
    }, ExtArgs["result"]["closed_questions"]>
    composites: {}
  }

  type closed_questionsGetPayload<S extends boolean | null | undefined | closed_questionsDefaultArgs> = $Result.GetResult<Prisma.$closed_questionsPayload, S>

  type closed_questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<closed_questionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Closed_questionsCountAggregateInputType | true
    }

  export interface closed_questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['closed_questions'], meta: { name: 'closed_questions' } }
    /**
     * Find zero or one Closed_questions that matches the filter.
     * @param {closed_questionsFindUniqueArgs} args - Arguments to find a Closed_questions
     * @example
     * // Get one Closed_questions
     * const closed_questions = await prisma.closed_questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends closed_questionsFindUniqueArgs>(args: SelectSubset<T, closed_questionsFindUniqueArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Closed_questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {closed_questionsFindUniqueOrThrowArgs} args - Arguments to find a Closed_questions
     * @example
     * // Get one Closed_questions
     * const closed_questions = await prisma.closed_questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends closed_questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, closed_questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Closed_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_questionsFindFirstArgs} args - Arguments to find a Closed_questions
     * @example
     * // Get one Closed_questions
     * const closed_questions = await prisma.closed_questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends closed_questionsFindFirstArgs>(args?: SelectSubset<T, closed_questionsFindFirstArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Closed_questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_questionsFindFirstOrThrowArgs} args - Arguments to find a Closed_questions
     * @example
     * // Get one Closed_questions
     * const closed_questions = await prisma.closed_questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends closed_questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, closed_questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Closed_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Closed_questions
     * const closed_questions = await prisma.closed_questions.findMany()
     * 
     * // Get first 10 Closed_questions
     * const closed_questions = await prisma.closed_questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const closed_questionsWithIdOnly = await prisma.closed_questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends closed_questionsFindManyArgs>(args?: SelectSubset<T, closed_questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Closed_questions.
     * @param {closed_questionsCreateArgs} args - Arguments to create a Closed_questions.
     * @example
     * // Create one Closed_questions
     * const Closed_questions = await prisma.closed_questions.create({
     *   data: {
     *     // ... data to create a Closed_questions
     *   }
     * })
     * 
     */
    create<T extends closed_questionsCreateArgs>(args: SelectSubset<T, closed_questionsCreateArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Closed_questions.
     * @param {closed_questionsCreateManyArgs} args - Arguments to create many Closed_questions.
     * @example
     * // Create many Closed_questions
     * const closed_questions = await prisma.closed_questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends closed_questionsCreateManyArgs>(args?: SelectSubset<T, closed_questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Closed_questions.
     * @param {closed_questionsDeleteArgs} args - Arguments to delete one Closed_questions.
     * @example
     * // Delete one Closed_questions
     * const Closed_questions = await prisma.closed_questions.delete({
     *   where: {
     *     // ... filter to delete one Closed_questions
     *   }
     * })
     * 
     */
    delete<T extends closed_questionsDeleteArgs>(args: SelectSubset<T, closed_questionsDeleteArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Closed_questions.
     * @param {closed_questionsUpdateArgs} args - Arguments to update one Closed_questions.
     * @example
     * // Update one Closed_questions
     * const closed_questions = await prisma.closed_questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends closed_questionsUpdateArgs>(args: SelectSubset<T, closed_questionsUpdateArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Closed_questions.
     * @param {closed_questionsDeleteManyArgs} args - Arguments to filter Closed_questions to delete.
     * @example
     * // Delete a few Closed_questions
     * const { count } = await prisma.closed_questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends closed_questionsDeleteManyArgs>(args?: SelectSubset<T, closed_questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Closed_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Closed_questions
     * const closed_questions = await prisma.closed_questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends closed_questionsUpdateManyArgs>(args: SelectSubset<T, closed_questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Closed_questions.
     * @param {closed_questionsUpsertArgs} args - Arguments to update or create a Closed_questions.
     * @example
     * // Update or create a Closed_questions
     * const closed_questions = await prisma.closed_questions.upsert({
     *   create: {
     *     // ... data to create a Closed_questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Closed_questions we want to update
     *   }
     * })
     */
    upsert<T extends closed_questionsUpsertArgs>(args: SelectSubset<T, closed_questionsUpsertArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Closed_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_questionsCountArgs} args - Arguments to filter Closed_questions to count.
     * @example
     * // Count the number of Closed_questions
     * const count = await prisma.closed_questions.count({
     *   where: {
     *     // ... the filter for the Closed_questions we want to count
     *   }
     * })
    **/
    count<T extends closed_questionsCountArgs>(
      args?: Subset<T, closed_questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Closed_questionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Closed_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Closed_questionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Closed_questionsAggregateArgs>(args: Subset<T, Closed_questionsAggregateArgs>): Prisma.PrismaPromise<GetClosed_questionsAggregateType<T>>

    /**
     * Group by Closed_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {closed_questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends closed_questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: closed_questionsGroupByArgs['orderBy'] }
        : { orderBy?: closed_questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, closed_questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClosed_questionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the closed_questions model
   */
  readonly fields: closed_questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for closed_questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__closed_questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt_questions<T extends closed_questions$attempt_questionsArgs<ExtArgs> = {}>(args?: Subset<T, closed_questions$attempt_questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findMany"> | Null>
    closed_answers<T extends closed_questions$closed_answersArgs<ExtArgs> = {}>(args?: Subset<T, closed_questions$closed_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examsDefaultArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student_closed_answers<T extends closed_questions$student_closed_answersArgs<ExtArgs> = {}>(args?: Subset<T, closed_questions$student_closed_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the closed_questions model
   */ 
  interface closed_questionsFieldRefs {
    readonly id: FieldRef<"closed_questions", 'Bytes'>
    readonly exam_id: FieldRef<"closed_questions", 'Bytes'>
    readonly score: FieldRef<"closed_questions", 'Int'>
    readonly is_multiple: FieldRef<"closed_questions", 'Boolean'>
    readonly description: FieldRef<"closed_questions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * closed_questions findUnique
   */
  export type closed_questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * Filter, which closed_questions to fetch.
     */
    where: closed_questionsWhereUniqueInput
  }

  /**
   * closed_questions findUniqueOrThrow
   */
  export type closed_questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * Filter, which closed_questions to fetch.
     */
    where: closed_questionsWhereUniqueInput
  }

  /**
   * closed_questions findFirst
   */
  export type closed_questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * Filter, which closed_questions to fetch.
     */
    where?: closed_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_questions to fetch.
     */
    orderBy?: closed_questionsOrderByWithRelationInput | closed_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for closed_questions.
     */
    cursor?: closed_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of closed_questions.
     */
    distinct?: Closed_questionsScalarFieldEnum | Closed_questionsScalarFieldEnum[]
  }

  /**
   * closed_questions findFirstOrThrow
   */
  export type closed_questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * Filter, which closed_questions to fetch.
     */
    where?: closed_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_questions to fetch.
     */
    orderBy?: closed_questionsOrderByWithRelationInput | closed_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for closed_questions.
     */
    cursor?: closed_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of closed_questions.
     */
    distinct?: Closed_questionsScalarFieldEnum | Closed_questionsScalarFieldEnum[]
  }

  /**
   * closed_questions findMany
   */
  export type closed_questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * Filter, which closed_questions to fetch.
     */
    where?: closed_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of closed_questions to fetch.
     */
    orderBy?: closed_questionsOrderByWithRelationInput | closed_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing closed_questions.
     */
    cursor?: closed_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` closed_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` closed_questions.
     */
    skip?: number
    distinct?: Closed_questionsScalarFieldEnum | Closed_questionsScalarFieldEnum[]
  }

  /**
   * closed_questions create
   */
  export type closed_questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a closed_questions.
     */
    data: XOR<closed_questionsCreateInput, closed_questionsUncheckedCreateInput>
  }

  /**
   * closed_questions createMany
   */
  export type closed_questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many closed_questions.
     */
    data: closed_questionsCreateManyInput | closed_questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * closed_questions update
   */
  export type closed_questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a closed_questions.
     */
    data: XOR<closed_questionsUpdateInput, closed_questionsUncheckedUpdateInput>
    /**
     * Choose, which closed_questions to update.
     */
    where: closed_questionsWhereUniqueInput
  }

  /**
   * closed_questions updateMany
   */
  export type closed_questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update closed_questions.
     */
    data: XOR<closed_questionsUpdateManyMutationInput, closed_questionsUncheckedUpdateManyInput>
    /**
     * Filter which closed_questions to update
     */
    where?: closed_questionsWhereInput
  }

  /**
   * closed_questions upsert
   */
  export type closed_questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the closed_questions to update in case it exists.
     */
    where: closed_questionsWhereUniqueInput
    /**
     * In case the closed_questions found by the `where` argument doesn't exist, create a new closed_questions with this data.
     */
    create: XOR<closed_questionsCreateInput, closed_questionsUncheckedCreateInput>
    /**
     * In case the closed_questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<closed_questionsUpdateInput, closed_questionsUncheckedUpdateInput>
  }

  /**
   * closed_questions delete
   */
  export type closed_questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
    /**
     * Filter which closed_questions to delete.
     */
    where: closed_questionsWhereUniqueInput
  }

  /**
   * closed_questions deleteMany
   */
  export type closed_questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which closed_questions to delete
     */
    where?: closed_questionsWhereInput
  }

  /**
   * closed_questions.attempt_questions
   */
  export type closed_questions$attempt_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    where?: attempt_questionsWhereInput
    orderBy?: attempt_questionsOrderByWithRelationInput | attempt_questionsOrderByWithRelationInput[]
    cursor?: attempt_questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Attempt_questionsScalarFieldEnum | Attempt_questionsScalarFieldEnum[]
  }

  /**
   * closed_questions.closed_answers
   */
  export type closed_questions$closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_answers
     */
    select?: closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_answersInclude<ExtArgs> | null
    where?: closed_answersWhereInput
    orderBy?: closed_answersOrderByWithRelationInput | closed_answersOrderByWithRelationInput[]
    cursor?: closed_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Closed_answersScalarFieldEnum | Closed_answersScalarFieldEnum[]
  }

  /**
   * closed_questions.student_closed_answers
   */
  export type closed_questions$student_closed_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    where?: student_closed_answersWhereInput
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    cursor?: student_closed_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_closed_answersScalarFieldEnum | Student_closed_answersScalarFieldEnum[]
  }

  /**
   * closed_questions without action
   */
  export type closed_questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the closed_questions
     */
    select?: closed_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: closed_questionsInclude<ExtArgs> | null
  }


  /**
   * Model files_repository
   */

  export type AggregateFiles_repository = {
    _count: Files_repositoryCountAggregateOutputType | null
    _min: Files_repositoryMinAggregateOutputType | null
    _max: Files_repositoryMaxAggregateOutputType | null
  }

  export type Files_repositoryMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    file: Uint8Array | null
    exam_id: Uint8Array | null
  }

  export type Files_repositoryMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    file: Uint8Array | null
    exam_id: Uint8Array | null
  }

  export type Files_repositoryCountAggregateOutputType = {
    id: number
    title: number
    description: number
    file: number
    exam_id: number
    _all: number
  }


  export type Files_repositoryMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    exam_id?: true
  }

  export type Files_repositoryMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    exam_id?: true
  }

  export type Files_repositoryCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file?: true
    exam_id?: true
    _all?: true
  }

  export type Files_repositoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files_repository to aggregate.
     */
    where?: files_repositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files_repositories to fetch.
     */
    orderBy?: files_repositoryOrderByWithRelationInput | files_repositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: files_repositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files_repositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files_repositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files_repositories
    **/
    _count?: true | Files_repositoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Files_repositoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Files_repositoryMaxAggregateInputType
  }

  export type GetFiles_repositoryAggregateType<T extends Files_repositoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles_repository]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles_repository[P]>
      : GetScalarType<T[P], AggregateFiles_repository[P]>
  }




  export type files_repositoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: files_repositoryWhereInput
    orderBy?: files_repositoryOrderByWithAggregationInput | files_repositoryOrderByWithAggregationInput[]
    by: Files_repositoryScalarFieldEnum[] | Files_repositoryScalarFieldEnum
    having?: files_repositoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Files_repositoryCountAggregateInputType | true
    _min?: Files_repositoryMinAggregateInputType
    _max?: Files_repositoryMaxAggregateInputType
  }

  export type Files_repositoryGroupByOutputType = {
    id: Uint8Array
    title: string
    description: string
    file: Uint8Array
    exam_id: Uint8Array
    _count: Files_repositoryCountAggregateOutputType | null
    _min: Files_repositoryMinAggregateOutputType | null
    _max: Files_repositoryMaxAggregateOutputType | null
  }

  type GetFiles_repositoryGroupByPayload<T extends files_repositoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Files_repositoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Files_repositoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Files_repositoryGroupByOutputType[P]>
            : GetScalarType<T[P], Files_repositoryGroupByOutputType[P]>
        }
      >
    >


  export type files_repositorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    file?: boolean
    exam_id?: boolean
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["files_repository"]>



  export type files_repositorySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    file?: boolean
    exam_id?: boolean
  }

  export type files_repositoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }

  export type $files_repositoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "files_repository"
    objects: {
      exams: Prisma.$examsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      title: string
      description: string
      file: Uint8Array
      exam_id: Uint8Array
    }, ExtArgs["result"]["files_repository"]>
    composites: {}
  }

  type files_repositoryGetPayload<S extends boolean | null | undefined | files_repositoryDefaultArgs> = $Result.GetResult<Prisma.$files_repositoryPayload, S>

  type files_repositoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<files_repositoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Files_repositoryCountAggregateInputType | true
    }

  export interface files_repositoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['files_repository'], meta: { name: 'files_repository' } }
    /**
     * Find zero or one Files_repository that matches the filter.
     * @param {files_repositoryFindUniqueArgs} args - Arguments to find a Files_repository
     * @example
     * // Get one Files_repository
     * const files_repository = await prisma.files_repository.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends files_repositoryFindUniqueArgs>(args: SelectSubset<T, files_repositoryFindUniqueArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Files_repository that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {files_repositoryFindUniqueOrThrowArgs} args - Arguments to find a Files_repository
     * @example
     * // Get one Files_repository
     * const files_repository = await prisma.files_repository.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends files_repositoryFindUniqueOrThrowArgs>(args: SelectSubset<T, files_repositoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Files_repository that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {files_repositoryFindFirstArgs} args - Arguments to find a Files_repository
     * @example
     * // Get one Files_repository
     * const files_repository = await prisma.files_repository.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends files_repositoryFindFirstArgs>(args?: SelectSubset<T, files_repositoryFindFirstArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Files_repository that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {files_repositoryFindFirstOrThrowArgs} args - Arguments to find a Files_repository
     * @example
     * // Get one Files_repository
     * const files_repository = await prisma.files_repository.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends files_repositoryFindFirstOrThrowArgs>(args?: SelectSubset<T, files_repositoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Files_repositories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {files_repositoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files_repositories
     * const files_repositories = await prisma.files_repository.findMany()
     * 
     * // Get first 10 Files_repositories
     * const files_repositories = await prisma.files_repository.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const files_repositoryWithIdOnly = await prisma.files_repository.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends files_repositoryFindManyArgs>(args?: SelectSubset<T, files_repositoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Files_repository.
     * @param {files_repositoryCreateArgs} args - Arguments to create a Files_repository.
     * @example
     * // Create one Files_repository
     * const Files_repository = await prisma.files_repository.create({
     *   data: {
     *     // ... data to create a Files_repository
     *   }
     * })
     * 
     */
    create<T extends files_repositoryCreateArgs>(args: SelectSubset<T, files_repositoryCreateArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Files_repositories.
     * @param {files_repositoryCreateManyArgs} args - Arguments to create many Files_repositories.
     * @example
     * // Create many Files_repositories
     * const files_repository = await prisma.files_repository.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends files_repositoryCreateManyArgs>(args?: SelectSubset<T, files_repositoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Files_repository.
     * @param {files_repositoryDeleteArgs} args - Arguments to delete one Files_repository.
     * @example
     * // Delete one Files_repository
     * const Files_repository = await prisma.files_repository.delete({
     *   where: {
     *     // ... filter to delete one Files_repository
     *   }
     * })
     * 
     */
    delete<T extends files_repositoryDeleteArgs>(args: SelectSubset<T, files_repositoryDeleteArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Files_repository.
     * @param {files_repositoryUpdateArgs} args - Arguments to update one Files_repository.
     * @example
     * // Update one Files_repository
     * const files_repository = await prisma.files_repository.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends files_repositoryUpdateArgs>(args: SelectSubset<T, files_repositoryUpdateArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Files_repositories.
     * @param {files_repositoryDeleteManyArgs} args - Arguments to filter Files_repositories to delete.
     * @example
     * // Delete a few Files_repositories
     * const { count } = await prisma.files_repository.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends files_repositoryDeleteManyArgs>(args?: SelectSubset<T, files_repositoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files_repositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {files_repositoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files_repositories
     * const files_repository = await prisma.files_repository.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends files_repositoryUpdateManyArgs>(args: SelectSubset<T, files_repositoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Files_repository.
     * @param {files_repositoryUpsertArgs} args - Arguments to update or create a Files_repository.
     * @example
     * // Update or create a Files_repository
     * const files_repository = await prisma.files_repository.upsert({
     *   create: {
     *     // ... data to create a Files_repository
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files_repository we want to update
     *   }
     * })
     */
    upsert<T extends files_repositoryUpsertArgs>(args: SelectSubset<T, files_repositoryUpsertArgs<ExtArgs>>): Prisma__files_repositoryClient<$Result.GetResult<Prisma.$files_repositoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Files_repositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {files_repositoryCountArgs} args - Arguments to filter Files_repositories to count.
     * @example
     * // Count the number of Files_repositories
     * const count = await prisma.files_repository.count({
     *   where: {
     *     // ... the filter for the Files_repositories we want to count
     *   }
     * })
    **/
    count<T extends files_repositoryCountArgs>(
      args?: Subset<T, files_repositoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Files_repositoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files_repository.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Files_repositoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Files_repositoryAggregateArgs>(args: Subset<T, Files_repositoryAggregateArgs>): Prisma.PrismaPromise<GetFiles_repositoryAggregateType<T>>

    /**
     * Group by Files_repository.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {files_repositoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends files_repositoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: files_repositoryGroupByArgs['orderBy'] }
        : { orderBy?: files_repositoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, files_repositoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiles_repositoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the files_repository model
   */
  readonly fields: files_repositoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for files_repository.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__files_repositoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exams<T extends examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examsDefaultArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the files_repository model
   */ 
  interface files_repositoryFieldRefs {
    readonly id: FieldRef<"files_repository", 'Bytes'>
    readonly title: FieldRef<"files_repository", 'String'>
    readonly description: FieldRef<"files_repository", 'String'>
    readonly file: FieldRef<"files_repository", 'Bytes'>
    readonly exam_id: FieldRef<"files_repository", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * files_repository findUnique
   */
  export type files_repositoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * Filter, which files_repository to fetch.
     */
    where: files_repositoryWhereUniqueInput
  }

  /**
   * files_repository findUniqueOrThrow
   */
  export type files_repositoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * Filter, which files_repository to fetch.
     */
    where: files_repositoryWhereUniqueInput
  }

  /**
   * files_repository findFirst
   */
  export type files_repositoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * Filter, which files_repository to fetch.
     */
    where?: files_repositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files_repositories to fetch.
     */
    orderBy?: files_repositoryOrderByWithRelationInput | files_repositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files_repositories.
     */
    cursor?: files_repositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files_repositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files_repositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files_repositories.
     */
    distinct?: Files_repositoryScalarFieldEnum | Files_repositoryScalarFieldEnum[]
  }

  /**
   * files_repository findFirstOrThrow
   */
  export type files_repositoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * Filter, which files_repository to fetch.
     */
    where?: files_repositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files_repositories to fetch.
     */
    orderBy?: files_repositoryOrderByWithRelationInput | files_repositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files_repositories.
     */
    cursor?: files_repositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files_repositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files_repositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files_repositories.
     */
    distinct?: Files_repositoryScalarFieldEnum | Files_repositoryScalarFieldEnum[]
  }

  /**
   * files_repository findMany
   */
  export type files_repositoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * Filter, which files_repositories to fetch.
     */
    where?: files_repositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files_repositories to fetch.
     */
    orderBy?: files_repositoryOrderByWithRelationInput | files_repositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files_repositories.
     */
    cursor?: files_repositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files_repositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files_repositories.
     */
    skip?: number
    distinct?: Files_repositoryScalarFieldEnum | Files_repositoryScalarFieldEnum[]
  }

  /**
   * files_repository create
   */
  export type files_repositoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * The data needed to create a files_repository.
     */
    data: XOR<files_repositoryCreateInput, files_repositoryUncheckedCreateInput>
  }

  /**
   * files_repository createMany
   */
  export type files_repositoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many files_repositories.
     */
    data: files_repositoryCreateManyInput | files_repositoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * files_repository update
   */
  export type files_repositoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * The data needed to update a files_repository.
     */
    data: XOR<files_repositoryUpdateInput, files_repositoryUncheckedUpdateInput>
    /**
     * Choose, which files_repository to update.
     */
    where: files_repositoryWhereUniqueInput
  }

  /**
   * files_repository updateMany
   */
  export type files_repositoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update files_repositories.
     */
    data: XOR<files_repositoryUpdateManyMutationInput, files_repositoryUncheckedUpdateManyInput>
    /**
     * Filter which files_repositories to update
     */
    where?: files_repositoryWhereInput
  }

  /**
   * files_repository upsert
   */
  export type files_repositoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * The filter to search for the files_repository to update in case it exists.
     */
    where: files_repositoryWhereUniqueInput
    /**
     * In case the files_repository found by the `where` argument doesn't exist, create a new files_repository with this data.
     */
    create: XOR<files_repositoryCreateInput, files_repositoryUncheckedCreateInput>
    /**
     * In case the files_repository was found with the provided `where` argument, update it with this data.
     */
    update: XOR<files_repositoryUpdateInput, files_repositoryUncheckedUpdateInput>
  }

  /**
   * files_repository delete
   */
  export type files_repositoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
    /**
     * Filter which files_repository to delete.
     */
    where: files_repositoryWhereUniqueInput
  }

  /**
   * files_repository deleteMany
   */
  export type files_repositoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files_repositories to delete
     */
    where?: files_repositoryWhereInput
  }

  /**
   * files_repository without action
   */
  export type files_repositoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files_repository
     */
    select?: files_repositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: files_repositoryInclude<ExtArgs> | null
  }


  /**
   * Model gradebook_exams
   */

  export type AggregateGradebook_exams = {
    _count: Gradebook_examsCountAggregateOutputType | null
    _min: Gradebook_examsMinAggregateOutputType | null
    _max: Gradebook_examsMaxAggregateOutputType | null
  }

  export type Gradebook_examsMinAggregateOutputType = {
    id: Uint8Array | null
    topic: string | null
    scope: string | null
    lesson_id: Uint8Array | null
  }

  export type Gradebook_examsMaxAggregateOutputType = {
    id: Uint8Array | null
    topic: string | null
    scope: string | null
    lesson_id: Uint8Array | null
  }

  export type Gradebook_examsCountAggregateOutputType = {
    id: number
    topic: number
    scope: number
    lesson_id: number
    _all: number
  }


  export type Gradebook_examsMinAggregateInputType = {
    id?: true
    topic?: true
    scope?: true
    lesson_id?: true
  }

  export type Gradebook_examsMaxAggregateInputType = {
    id?: true
    topic?: true
    scope?: true
    lesson_id?: true
  }

  export type Gradebook_examsCountAggregateInputType = {
    id?: true
    topic?: true
    scope?: true
    lesson_id?: true
    _all?: true
  }

  export type Gradebook_examsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gradebook_exams to aggregate.
     */
    where?: gradebook_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradebook_exams to fetch.
     */
    orderBy?: gradebook_examsOrderByWithRelationInput | gradebook_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gradebook_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradebook_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradebook_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gradebook_exams
    **/
    _count?: true | Gradebook_examsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gradebook_examsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gradebook_examsMaxAggregateInputType
  }

  export type GetGradebook_examsAggregateType<T extends Gradebook_examsAggregateArgs> = {
        [P in keyof T & keyof AggregateGradebook_exams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradebook_exams[P]>
      : GetScalarType<T[P], AggregateGradebook_exams[P]>
  }




  export type gradebook_examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gradebook_examsWhereInput
    orderBy?: gradebook_examsOrderByWithAggregationInput | gradebook_examsOrderByWithAggregationInput[]
    by: Gradebook_examsScalarFieldEnum[] | Gradebook_examsScalarFieldEnum
    having?: gradebook_examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gradebook_examsCountAggregateInputType | true
    _min?: Gradebook_examsMinAggregateInputType
    _max?: Gradebook_examsMaxAggregateInputType
  }

  export type Gradebook_examsGroupByOutputType = {
    id: Uint8Array
    topic: string
    scope: string
    lesson_id: Uint8Array
    _count: Gradebook_examsCountAggregateOutputType | null
    _min: Gradebook_examsMinAggregateOutputType | null
    _max: Gradebook_examsMaxAggregateOutputType | null
  }

  type GetGradebook_examsGroupByPayload<T extends gradebook_examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gradebook_examsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gradebook_examsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gradebook_examsGroupByOutputType[P]>
            : GetScalarType<T[P], Gradebook_examsGroupByOutputType[P]>
        }
      >
    >


  export type gradebook_examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    scope?: boolean
    lesson_id?: boolean
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradebook_exams"]>



  export type gradebook_examsSelectScalar = {
    id?: boolean
    topic?: boolean
    scope?: boolean
    lesson_id?: boolean
  }

  export type gradebook_examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | lessonsDefaultArgs<ExtArgs>
  }

  export type $gradebook_examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gradebook_exams"
    objects: {
      lessons: Prisma.$lessonsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      topic: string
      scope: string
      lesson_id: Uint8Array
    }, ExtArgs["result"]["gradebook_exams"]>
    composites: {}
  }

  type gradebook_examsGetPayload<S extends boolean | null | undefined | gradebook_examsDefaultArgs> = $Result.GetResult<Prisma.$gradebook_examsPayload, S>

  type gradebook_examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gradebook_examsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Gradebook_examsCountAggregateInputType | true
    }

  export interface gradebook_examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gradebook_exams'], meta: { name: 'gradebook_exams' } }
    /**
     * Find zero or one Gradebook_exams that matches the filter.
     * @param {gradebook_examsFindUniqueArgs} args - Arguments to find a Gradebook_exams
     * @example
     * // Get one Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gradebook_examsFindUniqueArgs>(args: SelectSubset<T, gradebook_examsFindUniqueArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gradebook_exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gradebook_examsFindUniqueOrThrowArgs} args - Arguments to find a Gradebook_exams
     * @example
     * // Get one Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gradebook_examsFindUniqueOrThrowArgs>(args: SelectSubset<T, gradebook_examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gradebook_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradebook_examsFindFirstArgs} args - Arguments to find a Gradebook_exams
     * @example
     * // Get one Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gradebook_examsFindFirstArgs>(args?: SelectSubset<T, gradebook_examsFindFirstArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gradebook_exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradebook_examsFindFirstOrThrowArgs} args - Arguments to find a Gradebook_exams
     * @example
     * // Get one Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gradebook_examsFindFirstOrThrowArgs>(args?: SelectSubset<T, gradebook_examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gradebook_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradebook_examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.findMany()
     * 
     * // Get first 10 Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradebook_examsWithIdOnly = await prisma.gradebook_exams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gradebook_examsFindManyArgs>(args?: SelectSubset<T, gradebook_examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gradebook_exams.
     * @param {gradebook_examsCreateArgs} args - Arguments to create a Gradebook_exams.
     * @example
     * // Create one Gradebook_exams
     * const Gradebook_exams = await prisma.gradebook_exams.create({
     *   data: {
     *     // ... data to create a Gradebook_exams
     *   }
     * })
     * 
     */
    create<T extends gradebook_examsCreateArgs>(args: SelectSubset<T, gradebook_examsCreateArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gradebook_exams.
     * @param {gradebook_examsCreateManyArgs} args - Arguments to create many Gradebook_exams.
     * @example
     * // Create many Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gradebook_examsCreateManyArgs>(args?: SelectSubset<T, gradebook_examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gradebook_exams.
     * @param {gradebook_examsDeleteArgs} args - Arguments to delete one Gradebook_exams.
     * @example
     * // Delete one Gradebook_exams
     * const Gradebook_exams = await prisma.gradebook_exams.delete({
     *   where: {
     *     // ... filter to delete one Gradebook_exams
     *   }
     * })
     * 
     */
    delete<T extends gradebook_examsDeleteArgs>(args: SelectSubset<T, gradebook_examsDeleteArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gradebook_exams.
     * @param {gradebook_examsUpdateArgs} args - Arguments to update one Gradebook_exams.
     * @example
     * // Update one Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gradebook_examsUpdateArgs>(args: SelectSubset<T, gradebook_examsUpdateArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gradebook_exams.
     * @param {gradebook_examsDeleteManyArgs} args - Arguments to filter Gradebook_exams to delete.
     * @example
     * // Delete a few Gradebook_exams
     * const { count } = await prisma.gradebook_exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gradebook_examsDeleteManyArgs>(args?: SelectSubset<T, gradebook_examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gradebook_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradebook_examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gradebook_examsUpdateManyArgs>(args: SelectSubset<T, gradebook_examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gradebook_exams.
     * @param {gradebook_examsUpsertArgs} args - Arguments to update or create a Gradebook_exams.
     * @example
     * // Update or create a Gradebook_exams
     * const gradebook_exams = await prisma.gradebook_exams.upsert({
     *   create: {
     *     // ... data to create a Gradebook_exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gradebook_exams we want to update
     *   }
     * })
     */
    upsert<T extends gradebook_examsUpsertArgs>(args: SelectSubset<T, gradebook_examsUpsertArgs<ExtArgs>>): Prisma__gradebook_examsClient<$Result.GetResult<Prisma.$gradebook_examsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gradebook_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradebook_examsCountArgs} args - Arguments to filter Gradebook_exams to count.
     * @example
     * // Count the number of Gradebook_exams
     * const count = await prisma.gradebook_exams.count({
     *   where: {
     *     // ... the filter for the Gradebook_exams we want to count
     *   }
     * })
    **/
    count<T extends gradebook_examsCountArgs>(
      args?: Subset<T, gradebook_examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gradebook_examsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gradebook_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gradebook_examsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gradebook_examsAggregateArgs>(args: Subset<T, Gradebook_examsAggregateArgs>): Prisma.PrismaPromise<GetGradebook_examsAggregateType<T>>

    /**
     * Group by Gradebook_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gradebook_examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gradebook_examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gradebook_examsGroupByArgs['orderBy'] }
        : { orderBy?: gradebook_examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gradebook_examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradebook_examsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gradebook_exams model
   */
  readonly fields: gradebook_examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gradebook_exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gradebook_examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends lessonsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, lessonsDefaultArgs<ExtArgs>>): Prisma__lessonsClient<$Result.GetResult<Prisma.$lessonsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gradebook_exams model
   */ 
  interface gradebook_examsFieldRefs {
    readonly id: FieldRef<"gradebook_exams", 'Bytes'>
    readonly topic: FieldRef<"gradebook_exams", 'String'>
    readonly scope: FieldRef<"gradebook_exams", 'String'>
    readonly lesson_id: FieldRef<"gradebook_exams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * gradebook_exams findUnique
   */
  export type gradebook_examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * Filter, which gradebook_exams to fetch.
     */
    where: gradebook_examsWhereUniqueInput
  }

  /**
   * gradebook_exams findUniqueOrThrow
   */
  export type gradebook_examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * Filter, which gradebook_exams to fetch.
     */
    where: gradebook_examsWhereUniqueInput
  }

  /**
   * gradebook_exams findFirst
   */
  export type gradebook_examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * Filter, which gradebook_exams to fetch.
     */
    where?: gradebook_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradebook_exams to fetch.
     */
    orderBy?: gradebook_examsOrderByWithRelationInput | gradebook_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gradebook_exams.
     */
    cursor?: gradebook_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradebook_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradebook_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gradebook_exams.
     */
    distinct?: Gradebook_examsScalarFieldEnum | Gradebook_examsScalarFieldEnum[]
  }

  /**
   * gradebook_exams findFirstOrThrow
   */
  export type gradebook_examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * Filter, which gradebook_exams to fetch.
     */
    where?: gradebook_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradebook_exams to fetch.
     */
    orderBy?: gradebook_examsOrderByWithRelationInput | gradebook_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gradebook_exams.
     */
    cursor?: gradebook_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradebook_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradebook_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gradebook_exams.
     */
    distinct?: Gradebook_examsScalarFieldEnum | Gradebook_examsScalarFieldEnum[]
  }

  /**
   * gradebook_exams findMany
   */
  export type gradebook_examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * Filter, which gradebook_exams to fetch.
     */
    where?: gradebook_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gradebook_exams to fetch.
     */
    orderBy?: gradebook_examsOrderByWithRelationInput | gradebook_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gradebook_exams.
     */
    cursor?: gradebook_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gradebook_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gradebook_exams.
     */
    skip?: number
    distinct?: Gradebook_examsScalarFieldEnum | Gradebook_examsScalarFieldEnum[]
  }

  /**
   * gradebook_exams create
   */
  export type gradebook_examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * The data needed to create a gradebook_exams.
     */
    data: XOR<gradebook_examsCreateInput, gradebook_examsUncheckedCreateInput>
  }

  /**
   * gradebook_exams createMany
   */
  export type gradebook_examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gradebook_exams.
     */
    data: gradebook_examsCreateManyInput | gradebook_examsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gradebook_exams update
   */
  export type gradebook_examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * The data needed to update a gradebook_exams.
     */
    data: XOR<gradebook_examsUpdateInput, gradebook_examsUncheckedUpdateInput>
    /**
     * Choose, which gradebook_exams to update.
     */
    where: gradebook_examsWhereUniqueInput
  }

  /**
   * gradebook_exams updateMany
   */
  export type gradebook_examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gradebook_exams.
     */
    data: XOR<gradebook_examsUpdateManyMutationInput, gradebook_examsUncheckedUpdateManyInput>
    /**
     * Filter which gradebook_exams to update
     */
    where?: gradebook_examsWhereInput
  }

  /**
   * gradebook_exams upsert
   */
  export type gradebook_examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * The filter to search for the gradebook_exams to update in case it exists.
     */
    where: gradebook_examsWhereUniqueInput
    /**
     * In case the gradebook_exams found by the `where` argument doesn't exist, create a new gradebook_exams with this data.
     */
    create: XOR<gradebook_examsCreateInput, gradebook_examsUncheckedCreateInput>
    /**
     * In case the gradebook_exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gradebook_examsUpdateInput, gradebook_examsUncheckedUpdateInput>
  }

  /**
   * gradebook_exams delete
   */
  export type gradebook_examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
    /**
     * Filter which gradebook_exams to delete.
     */
    where: gradebook_examsWhereUniqueInput
  }

  /**
   * gradebook_exams deleteMany
   */
  export type gradebook_examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gradebook_exams to delete
     */
    where?: gradebook_examsWhereInput
  }

  /**
   * gradebook_exams without action
   */
  export type gradebook_examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gradebook_exams
     */
    select?: gradebook_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gradebook_examsInclude<ExtArgs> | null
  }


  /**
   * Model grades_exams
   */

  export type AggregateGrades_exams = {
    _count: Grades_examsCountAggregateOutputType | null
    _min: Grades_examsMinAggregateOutputType | null
    _max: Grades_examsMaxAggregateOutputType | null
  }

  export type Grades_examsMinAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    attempt_id: Uint8Array | null
    exam_id: Uint8Array | null
    description: string | null
    grade: string | null
    date_given: Date | null
  }

  export type Grades_examsMaxAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    attempt_id: Uint8Array | null
    exam_id: Uint8Array | null
    description: string | null
    grade: string | null
    date_given: Date | null
  }

  export type Grades_examsCountAggregateOutputType = {
    id: number
    student_id: number
    attempt_id: number
    exam_id: number
    description: number
    grade: number
    date_given: number
    _all: number
  }


  export type Grades_examsMinAggregateInputType = {
    id?: true
    student_id?: true
    attempt_id?: true
    exam_id?: true
    description?: true
    grade?: true
    date_given?: true
  }

  export type Grades_examsMaxAggregateInputType = {
    id?: true
    student_id?: true
    attempt_id?: true
    exam_id?: true
    description?: true
    grade?: true
    date_given?: true
  }

  export type Grades_examsCountAggregateInputType = {
    id?: true
    student_id?: true
    attempt_id?: true
    exam_id?: true
    description?: true
    grade?: true
    date_given?: true
    _all?: true
  }

  export type Grades_examsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grades_exams to aggregate.
     */
    where?: grades_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_exams to fetch.
     */
    orderBy?: grades_examsOrderByWithRelationInput | grades_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grades_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grades_exams
    **/
    _count?: true | Grades_examsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Grades_examsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Grades_examsMaxAggregateInputType
  }

  export type GetGrades_examsAggregateType<T extends Grades_examsAggregateArgs> = {
        [P in keyof T & keyof AggregateGrades_exams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrades_exams[P]>
      : GetScalarType<T[P], AggregateGrades_exams[P]>
  }




  export type grades_examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grades_examsWhereInput
    orderBy?: grades_examsOrderByWithAggregationInput | grades_examsOrderByWithAggregationInput[]
    by: Grades_examsScalarFieldEnum[] | Grades_examsScalarFieldEnum
    having?: grades_examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Grades_examsCountAggregateInputType | true
    _min?: Grades_examsMinAggregateInputType
    _max?: Grades_examsMaxAggregateInputType
  }

  export type Grades_examsGroupByOutputType = {
    id: Uint8Array
    student_id: Uint8Array
    attempt_id: Uint8Array
    exam_id: Uint8Array
    description: string
    grade: string
    date_given: Date
    _count: Grades_examsCountAggregateOutputType | null
    _min: Grades_examsMinAggregateOutputType | null
    _max: Grades_examsMaxAggregateOutputType | null
  }

  type GetGrades_examsGroupByPayload<T extends grades_examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Grades_examsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Grades_examsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Grades_examsGroupByOutputType[P]>
            : GetScalarType<T[P], Grades_examsGroupByOutputType[P]>
        }
      >
    >


  export type grades_examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    attempt_id?: boolean
    exam_id?: boolean
    description?: boolean
    grade?: boolean
    date_given?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades_exams"]>



  export type grades_examsSelectScalar = {
    id?: boolean
    student_id?: boolean
    attempt_id?: boolean
    exam_id?: boolean
    description?: boolean
    grade?: boolean
    date_given?: boolean
  }

  export type grades_examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }

  export type $grades_examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grades_exams"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      exams: Prisma.$examsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      student_id: Uint8Array
      attempt_id: Uint8Array
      exam_id: Uint8Array
      description: string
      grade: string
      date_given: Date
    }, ExtArgs["result"]["grades_exams"]>
    composites: {}
  }

  type grades_examsGetPayload<S extends boolean | null | undefined | grades_examsDefaultArgs> = $Result.GetResult<Prisma.$grades_examsPayload, S>

  type grades_examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<grades_examsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Grades_examsCountAggregateInputType | true
    }

  export interface grades_examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grades_exams'], meta: { name: 'grades_exams' } }
    /**
     * Find zero or one Grades_exams that matches the filter.
     * @param {grades_examsFindUniqueArgs} args - Arguments to find a Grades_exams
     * @example
     * // Get one Grades_exams
     * const grades_exams = await prisma.grades_exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grades_examsFindUniqueArgs>(args: SelectSubset<T, grades_examsFindUniqueArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grades_exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {grades_examsFindUniqueOrThrowArgs} args - Arguments to find a Grades_exams
     * @example
     * // Get one Grades_exams
     * const grades_exams = await prisma.grades_exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grades_examsFindUniqueOrThrowArgs>(args: SelectSubset<T, grades_examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grades_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_examsFindFirstArgs} args - Arguments to find a Grades_exams
     * @example
     * // Get one Grades_exams
     * const grades_exams = await prisma.grades_exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grades_examsFindFirstArgs>(args?: SelectSubset<T, grades_examsFindFirstArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grades_exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_examsFindFirstOrThrowArgs} args - Arguments to find a Grades_exams
     * @example
     * // Get one Grades_exams
     * const grades_exams = await prisma.grades_exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grades_examsFindFirstOrThrowArgs>(args?: SelectSubset<T, grades_examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grades_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades_exams
     * const grades_exams = await prisma.grades_exams.findMany()
     * 
     * // Get first 10 Grades_exams
     * const grades_exams = await prisma.grades_exams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grades_examsWithIdOnly = await prisma.grades_exams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grades_examsFindManyArgs>(args?: SelectSubset<T, grades_examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grades_exams.
     * @param {grades_examsCreateArgs} args - Arguments to create a Grades_exams.
     * @example
     * // Create one Grades_exams
     * const Grades_exams = await prisma.grades_exams.create({
     *   data: {
     *     // ... data to create a Grades_exams
     *   }
     * })
     * 
     */
    create<T extends grades_examsCreateArgs>(args: SelectSubset<T, grades_examsCreateArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grades_exams.
     * @param {grades_examsCreateManyArgs} args - Arguments to create many Grades_exams.
     * @example
     * // Create many Grades_exams
     * const grades_exams = await prisma.grades_exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grades_examsCreateManyArgs>(args?: SelectSubset<T, grades_examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Grades_exams.
     * @param {grades_examsDeleteArgs} args - Arguments to delete one Grades_exams.
     * @example
     * // Delete one Grades_exams
     * const Grades_exams = await prisma.grades_exams.delete({
     *   where: {
     *     // ... filter to delete one Grades_exams
     *   }
     * })
     * 
     */
    delete<T extends grades_examsDeleteArgs>(args: SelectSubset<T, grades_examsDeleteArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grades_exams.
     * @param {grades_examsUpdateArgs} args - Arguments to update one Grades_exams.
     * @example
     * // Update one Grades_exams
     * const grades_exams = await prisma.grades_exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grades_examsUpdateArgs>(args: SelectSubset<T, grades_examsUpdateArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grades_exams.
     * @param {grades_examsDeleteManyArgs} args - Arguments to filter Grades_exams to delete.
     * @example
     * // Delete a few Grades_exams
     * const { count } = await prisma.grades_exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grades_examsDeleteManyArgs>(args?: SelectSubset<T, grades_examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades_exams
     * const grades_exams = await prisma.grades_exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grades_examsUpdateManyArgs>(args: SelectSubset<T, grades_examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grades_exams.
     * @param {grades_examsUpsertArgs} args - Arguments to update or create a Grades_exams.
     * @example
     * // Update or create a Grades_exams
     * const grades_exams = await prisma.grades_exams.upsert({
     *   create: {
     *     // ... data to create a Grades_exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grades_exams we want to update
     *   }
     * })
     */
    upsert<T extends grades_examsUpsertArgs>(args: SelectSubset<T, grades_examsUpsertArgs<ExtArgs>>): Prisma__grades_examsClient<$Result.GetResult<Prisma.$grades_examsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grades_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_examsCountArgs} args - Arguments to filter Grades_exams to count.
     * @example
     * // Count the number of Grades_exams
     * const count = await prisma.grades_exams.count({
     *   where: {
     *     // ... the filter for the Grades_exams we want to count
     *   }
     * })
    **/
    count<T extends grades_examsCountArgs>(
      args?: Subset<T, grades_examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Grades_examsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grades_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Grades_examsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Grades_examsAggregateArgs>(args: Subset<T, Grades_examsAggregateArgs>): Prisma.PrismaPromise<GetGrades_examsAggregateType<T>>

    /**
     * Group by Grades_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grades_examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grades_examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grades_examsGroupByArgs['orderBy'] }
        : { orderBy?: grades_examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grades_examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrades_examsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grades_exams model
   */
  readonly fields: grades_examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grades_exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grades_examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exams<T extends examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examsDefaultArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grades_exams model
   */ 
  interface grades_examsFieldRefs {
    readonly id: FieldRef<"grades_exams", 'Bytes'>
    readonly student_id: FieldRef<"grades_exams", 'Bytes'>
    readonly attempt_id: FieldRef<"grades_exams", 'Bytes'>
    readonly exam_id: FieldRef<"grades_exams", 'Bytes'>
    readonly description: FieldRef<"grades_exams", 'String'>
    readonly grade: FieldRef<"grades_exams", 'String'>
    readonly date_given: FieldRef<"grades_exams", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * grades_exams findUnique
   */
  export type grades_examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * Filter, which grades_exams to fetch.
     */
    where: grades_examsWhereUniqueInput
  }

  /**
   * grades_exams findUniqueOrThrow
   */
  export type grades_examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * Filter, which grades_exams to fetch.
     */
    where: grades_examsWhereUniqueInput
  }

  /**
   * grades_exams findFirst
   */
  export type grades_examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * Filter, which grades_exams to fetch.
     */
    where?: grades_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_exams to fetch.
     */
    orderBy?: grades_examsOrderByWithRelationInput | grades_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grades_exams.
     */
    cursor?: grades_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grades_exams.
     */
    distinct?: Grades_examsScalarFieldEnum | Grades_examsScalarFieldEnum[]
  }

  /**
   * grades_exams findFirstOrThrow
   */
  export type grades_examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * Filter, which grades_exams to fetch.
     */
    where?: grades_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_exams to fetch.
     */
    orderBy?: grades_examsOrderByWithRelationInput | grades_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grades_exams.
     */
    cursor?: grades_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grades_exams.
     */
    distinct?: Grades_examsScalarFieldEnum | Grades_examsScalarFieldEnum[]
  }

  /**
   * grades_exams findMany
   */
  export type grades_examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * Filter, which grades_exams to fetch.
     */
    where?: grades_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grades_exams to fetch.
     */
    orderBy?: grades_examsOrderByWithRelationInput | grades_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grades_exams.
     */
    cursor?: grades_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grades_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grades_exams.
     */
    skip?: number
    distinct?: Grades_examsScalarFieldEnum | Grades_examsScalarFieldEnum[]
  }

  /**
   * grades_exams create
   */
  export type grades_examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * The data needed to create a grades_exams.
     */
    data: XOR<grades_examsCreateInput, grades_examsUncheckedCreateInput>
  }

  /**
   * grades_exams createMany
   */
  export type grades_examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grades_exams.
     */
    data: grades_examsCreateManyInput | grades_examsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grades_exams update
   */
  export type grades_examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * The data needed to update a grades_exams.
     */
    data: XOR<grades_examsUpdateInput, grades_examsUncheckedUpdateInput>
    /**
     * Choose, which grades_exams to update.
     */
    where: grades_examsWhereUniqueInput
  }

  /**
   * grades_exams updateMany
   */
  export type grades_examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grades_exams.
     */
    data: XOR<grades_examsUpdateManyMutationInput, grades_examsUncheckedUpdateManyInput>
    /**
     * Filter which grades_exams to update
     */
    where?: grades_examsWhereInput
  }

  /**
   * grades_exams upsert
   */
  export type grades_examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * The filter to search for the grades_exams to update in case it exists.
     */
    where: grades_examsWhereUniqueInput
    /**
     * In case the grades_exams found by the `where` argument doesn't exist, create a new grades_exams with this data.
     */
    create: XOR<grades_examsCreateInput, grades_examsUncheckedCreateInput>
    /**
     * In case the grades_exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grades_examsUpdateInput, grades_examsUncheckedUpdateInput>
  }

  /**
   * grades_exams delete
   */
  export type grades_examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
    /**
     * Filter which grades_exams to delete.
     */
    where: grades_examsWhereUniqueInput
  }

  /**
   * grades_exams deleteMany
   */
  export type grades_examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grades_exams to delete
     */
    where?: grades_examsWhereInput
  }

  /**
   * grades_exams without action
   */
  export type grades_examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grades_exams
     */
    select?: grades_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grades_examsInclude<ExtArgs> | null
  }


  /**
   * Model grading_scale
   */

  export type AggregateGrading_scale = {
    _count: Grading_scaleCountAggregateOutputType | null
    _avg: Grading_scaleAvgAggregateOutputType | null
    _sum: Grading_scaleSumAggregateOutputType | null
    _min: Grading_scaleMinAggregateOutputType | null
    _max: Grading_scaleMaxAggregateOutputType | null
  }

  export type Grading_scaleAvgAggregateOutputType = {
    min_score: number | null
    max_score: number | null
  }

  export type Grading_scaleSumAggregateOutputType = {
    min_score: number | null
    max_score: number | null
  }

  export type Grading_scaleMinAggregateOutputType = {
    id: Uint8Array | null
    min_score: number | null
    max_score: number | null
    grades: string | null
  }

  export type Grading_scaleMaxAggregateOutputType = {
    id: Uint8Array | null
    min_score: number | null
    max_score: number | null
    grades: string | null
  }

  export type Grading_scaleCountAggregateOutputType = {
    id: number
    min_score: number
    max_score: number
    grades: number
    _all: number
  }


  export type Grading_scaleAvgAggregateInputType = {
    min_score?: true
    max_score?: true
  }

  export type Grading_scaleSumAggregateInputType = {
    min_score?: true
    max_score?: true
  }

  export type Grading_scaleMinAggregateInputType = {
    id?: true
    min_score?: true
    max_score?: true
    grades?: true
  }

  export type Grading_scaleMaxAggregateInputType = {
    id?: true
    min_score?: true
    max_score?: true
    grades?: true
  }

  export type Grading_scaleCountAggregateInputType = {
    id?: true
    min_score?: true
    max_score?: true
    grades?: true
    _all?: true
  }

  export type Grading_scaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grading_scale to aggregate.
     */
    where?: grading_scaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grading_scales to fetch.
     */
    orderBy?: grading_scaleOrderByWithRelationInput | grading_scaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grading_scaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grading_scales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grading_scales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grading_scales
    **/
    _count?: true | Grading_scaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Grading_scaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Grading_scaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Grading_scaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Grading_scaleMaxAggregateInputType
  }

  export type GetGrading_scaleAggregateType<T extends Grading_scaleAggregateArgs> = {
        [P in keyof T & keyof AggregateGrading_scale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrading_scale[P]>
      : GetScalarType<T[P], AggregateGrading_scale[P]>
  }




  export type grading_scaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grading_scaleWhereInput
    orderBy?: grading_scaleOrderByWithAggregationInput | grading_scaleOrderByWithAggregationInput[]
    by: Grading_scaleScalarFieldEnum[] | Grading_scaleScalarFieldEnum
    having?: grading_scaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Grading_scaleCountAggregateInputType | true
    _avg?: Grading_scaleAvgAggregateInputType
    _sum?: Grading_scaleSumAggregateInputType
    _min?: Grading_scaleMinAggregateInputType
    _max?: Grading_scaleMaxAggregateInputType
  }

  export type Grading_scaleGroupByOutputType = {
    id: Uint8Array
    min_score: number
    max_score: number
    grades: string
    _count: Grading_scaleCountAggregateOutputType | null
    _avg: Grading_scaleAvgAggregateOutputType | null
    _sum: Grading_scaleSumAggregateOutputType | null
    _min: Grading_scaleMinAggregateOutputType | null
    _max: Grading_scaleMaxAggregateOutputType | null
  }

  type GetGrading_scaleGroupByPayload<T extends grading_scaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Grading_scaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Grading_scaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Grading_scaleGroupByOutputType[P]>
            : GetScalarType<T[P], Grading_scaleGroupByOutputType[P]>
        }
      >
    >


  export type grading_scaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    min_score?: boolean
    max_score?: boolean
    grades?: boolean
  }, ExtArgs["result"]["grading_scale"]>



  export type grading_scaleSelectScalar = {
    id?: boolean
    min_score?: boolean
    max_score?: boolean
    grades?: boolean
  }


  export type $grading_scalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grading_scale"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      min_score: number
      max_score: number
      grades: string
    }, ExtArgs["result"]["grading_scale"]>
    composites: {}
  }

  type grading_scaleGetPayload<S extends boolean | null | undefined | grading_scaleDefaultArgs> = $Result.GetResult<Prisma.$grading_scalePayload, S>

  type grading_scaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<grading_scaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Grading_scaleCountAggregateInputType | true
    }

  export interface grading_scaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grading_scale'], meta: { name: 'grading_scale' } }
    /**
     * Find zero or one Grading_scale that matches the filter.
     * @param {grading_scaleFindUniqueArgs} args - Arguments to find a Grading_scale
     * @example
     * // Get one Grading_scale
     * const grading_scale = await prisma.grading_scale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grading_scaleFindUniqueArgs>(args: SelectSubset<T, grading_scaleFindUniqueArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grading_scale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {grading_scaleFindUniqueOrThrowArgs} args - Arguments to find a Grading_scale
     * @example
     * // Get one Grading_scale
     * const grading_scale = await prisma.grading_scale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grading_scaleFindUniqueOrThrowArgs>(args: SelectSubset<T, grading_scaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grading_scale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grading_scaleFindFirstArgs} args - Arguments to find a Grading_scale
     * @example
     * // Get one Grading_scale
     * const grading_scale = await prisma.grading_scale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grading_scaleFindFirstArgs>(args?: SelectSubset<T, grading_scaleFindFirstArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grading_scale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grading_scaleFindFirstOrThrowArgs} args - Arguments to find a Grading_scale
     * @example
     * // Get one Grading_scale
     * const grading_scale = await prisma.grading_scale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grading_scaleFindFirstOrThrowArgs>(args?: SelectSubset<T, grading_scaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grading_scales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grading_scaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grading_scales
     * const grading_scales = await prisma.grading_scale.findMany()
     * 
     * // Get first 10 Grading_scales
     * const grading_scales = await prisma.grading_scale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grading_scaleWithIdOnly = await prisma.grading_scale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grading_scaleFindManyArgs>(args?: SelectSubset<T, grading_scaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grading_scale.
     * @param {grading_scaleCreateArgs} args - Arguments to create a Grading_scale.
     * @example
     * // Create one Grading_scale
     * const Grading_scale = await prisma.grading_scale.create({
     *   data: {
     *     // ... data to create a Grading_scale
     *   }
     * })
     * 
     */
    create<T extends grading_scaleCreateArgs>(args: SelectSubset<T, grading_scaleCreateArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grading_scales.
     * @param {grading_scaleCreateManyArgs} args - Arguments to create many Grading_scales.
     * @example
     * // Create many Grading_scales
     * const grading_scale = await prisma.grading_scale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grading_scaleCreateManyArgs>(args?: SelectSubset<T, grading_scaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Grading_scale.
     * @param {grading_scaleDeleteArgs} args - Arguments to delete one Grading_scale.
     * @example
     * // Delete one Grading_scale
     * const Grading_scale = await prisma.grading_scale.delete({
     *   where: {
     *     // ... filter to delete one Grading_scale
     *   }
     * })
     * 
     */
    delete<T extends grading_scaleDeleteArgs>(args: SelectSubset<T, grading_scaleDeleteArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grading_scale.
     * @param {grading_scaleUpdateArgs} args - Arguments to update one Grading_scale.
     * @example
     * // Update one Grading_scale
     * const grading_scale = await prisma.grading_scale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grading_scaleUpdateArgs>(args: SelectSubset<T, grading_scaleUpdateArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grading_scales.
     * @param {grading_scaleDeleteManyArgs} args - Arguments to filter Grading_scales to delete.
     * @example
     * // Delete a few Grading_scales
     * const { count } = await prisma.grading_scale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grading_scaleDeleteManyArgs>(args?: SelectSubset<T, grading_scaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grading_scales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grading_scaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grading_scales
     * const grading_scale = await prisma.grading_scale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grading_scaleUpdateManyArgs>(args: SelectSubset<T, grading_scaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grading_scale.
     * @param {grading_scaleUpsertArgs} args - Arguments to update or create a Grading_scale.
     * @example
     * // Update or create a Grading_scale
     * const grading_scale = await prisma.grading_scale.upsert({
     *   create: {
     *     // ... data to create a Grading_scale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grading_scale we want to update
     *   }
     * })
     */
    upsert<T extends grading_scaleUpsertArgs>(args: SelectSubset<T, grading_scaleUpsertArgs<ExtArgs>>): Prisma__grading_scaleClient<$Result.GetResult<Prisma.$grading_scalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grading_scales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grading_scaleCountArgs} args - Arguments to filter Grading_scales to count.
     * @example
     * // Count the number of Grading_scales
     * const count = await prisma.grading_scale.count({
     *   where: {
     *     // ... the filter for the Grading_scales we want to count
     *   }
     * })
    **/
    count<T extends grading_scaleCountArgs>(
      args?: Subset<T, grading_scaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Grading_scaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grading_scale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Grading_scaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Grading_scaleAggregateArgs>(args: Subset<T, Grading_scaleAggregateArgs>): Prisma.PrismaPromise<GetGrading_scaleAggregateType<T>>

    /**
     * Group by Grading_scale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grading_scaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grading_scaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grading_scaleGroupByArgs['orderBy'] }
        : { orderBy?: grading_scaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grading_scaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrading_scaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grading_scale model
   */
  readonly fields: grading_scaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grading_scale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grading_scaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grading_scale model
   */ 
  interface grading_scaleFieldRefs {
    readonly id: FieldRef<"grading_scale", 'Bytes'>
    readonly min_score: FieldRef<"grading_scale", 'Int'>
    readonly max_score: FieldRef<"grading_scale", 'Int'>
    readonly grades: FieldRef<"grading_scale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * grading_scale findUnique
   */
  export type grading_scaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * Filter, which grading_scale to fetch.
     */
    where: grading_scaleWhereUniqueInput
  }

  /**
   * grading_scale findUniqueOrThrow
   */
  export type grading_scaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * Filter, which grading_scale to fetch.
     */
    where: grading_scaleWhereUniqueInput
  }

  /**
   * grading_scale findFirst
   */
  export type grading_scaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * Filter, which grading_scale to fetch.
     */
    where?: grading_scaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grading_scales to fetch.
     */
    orderBy?: grading_scaleOrderByWithRelationInput | grading_scaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grading_scales.
     */
    cursor?: grading_scaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grading_scales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grading_scales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grading_scales.
     */
    distinct?: Grading_scaleScalarFieldEnum | Grading_scaleScalarFieldEnum[]
  }

  /**
   * grading_scale findFirstOrThrow
   */
  export type grading_scaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * Filter, which grading_scale to fetch.
     */
    where?: grading_scaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grading_scales to fetch.
     */
    orderBy?: grading_scaleOrderByWithRelationInput | grading_scaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grading_scales.
     */
    cursor?: grading_scaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grading_scales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grading_scales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grading_scales.
     */
    distinct?: Grading_scaleScalarFieldEnum | Grading_scaleScalarFieldEnum[]
  }

  /**
   * grading_scale findMany
   */
  export type grading_scaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * Filter, which grading_scales to fetch.
     */
    where?: grading_scaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grading_scales to fetch.
     */
    orderBy?: grading_scaleOrderByWithRelationInput | grading_scaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grading_scales.
     */
    cursor?: grading_scaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grading_scales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grading_scales.
     */
    skip?: number
    distinct?: Grading_scaleScalarFieldEnum | Grading_scaleScalarFieldEnum[]
  }

  /**
   * grading_scale create
   */
  export type grading_scaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * The data needed to create a grading_scale.
     */
    data: XOR<grading_scaleCreateInput, grading_scaleUncheckedCreateInput>
  }

  /**
   * grading_scale createMany
   */
  export type grading_scaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grading_scales.
     */
    data: grading_scaleCreateManyInput | grading_scaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grading_scale update
   */
  export type grading_scaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * The data needed to update a grading_scale.
     */
    data: XOR<grading_scaleUpdateInput, grading_scaleUncheckedUpdateInput>
    /**
     * Choose, which grading_scale to update.
     */
    where: grading_scaleWhereUniqueInput
  }

  /**
   * grading_scale updateMany
   */
  export type grading_scaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grading_scales.
     */
    data: XOR<grading_scaleUpdateManyMutationInput, grading_scaleUncheckedUpdateManyInput>
    /**
     * Filter which grading_scales to update
     */
    where?: grading_scaleWhereInput
  }

  /**
   * grading_scale upsert
   */
  export type grading_scaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * The filter to search for the grading_scale to update in case it exists.
     */
    where: grading_scaleWhereUniqueInput
    /**
     * In case the grading_scale found by the `where` argument doesn't exist, create a new grading_scale with this data.
     */
    create: XOR<grading_scaleCreateInput, grading_scaleUncheckedCreateInput>
    /**
     * In case the grading_scale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grading_scaleUpdateInput, grading_scaleUncheckedUpdateInput>
  }

  /**
   * grading_scale delete
   */
  export type grading_scaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
    /**
     * Filter which grading_scale to delete.
     */
    where: grading_scaleWhereUniqueInput
  }

  /**
   * grading_scale deleteMany
   */
  export type grading_scaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grading_scales to delete
     */
    where?: grading_scaleWhereInput
  }

  /**
   * grading_scale without action
   */
  export type grading_scaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grading_scale
     */
    select?: grading_scaleSelect<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    description: string | null
    notification_date: Date | null
    is_read: boolean | null
    exam_id: Uint8Array | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    description: string | null
    notification_date: Date | null
    is_read: boolean | null
    exam_id: Uint8Array | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    student_id: number
    description: number
    notification_date: number
    is_read: number
    exam_id: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    student_id?: true
    description?: true
    notification_date?: true
    is_read?: true
    exam_id?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    student_id?: true
    description?: true
    notification_date?: true
    is_read?: true
    exam_id?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    student_id?: true
    description?: true
    notification_date?: true
    is_read?: true
    exam_id?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: Uint8Array
    student_id: Uint8Array
    description: string
    notification_date: Date
    is_read: boolean
    exam_id: Uint8Array | null
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    description?: boolean
    notification_date?: boolean
    is_read?: boolean
    exam_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | notifications$examsArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>



  export type notificationsSelectScalar = {
    id?: boolean
    student_id?: boolean
    description?: boolean
    notification_date?: boolean
    is_read?: boolean
    exam_id?: boolean
  }

  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | notifications$examsArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      exams: Prisma.$examsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      student_id: Uint8Array
      description: string
      notification_date: Date
      is_read: boolean
      exam_id: Uint8Array | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exams<T extends notifications$examsArgs<ExtArgs> = {}>(args?: Subset<T, notifications$examsArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */ 
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'Bytes'>
    readonly student_id: FieldRef<"notifications", 'Bytes'>
    readonly description: FieldRef<"notifications", 'String'>
    readonly notification_date: FieldRef<"notifications", 'DateTime'>
    readonly is_read: FieldRef<"notifications", 'Boolean'>
    readonly exam_id: FieldRef<"notifications", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications.exams
   */
  export type notifications$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    where?: examsWhereInput
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model open_answers
   */

  export type AggregateOpen_answers = {
    _count: Open_answersCountAggregateOutputType | null
    _min: Open_answersMinAggregateOutputType | null
    _max: Open_answersMaxAggregateOutputType | null
  }

  export type Open_answersMinAggregateOutputType = {
    id: Uint8Array | null
    open_question_id: Uint8Array | null
    description: string | null
  }

  export type Open_answersMaxAggregateOutputType = {
    id: Uint8Array | null
    open_question_id: Uint8Array | null
    description: string | null
  }

  export type Open_answersCountAggregateOutputType = {
    id: number
    open_question_id: number
    description: number
    _all: number
  }


  export type Open_answersMinAggregateInputType = {
    id?: true
    open_question_id?: true
    description?: true
  }

  export type Open_answersMaxAggregateInputType = {
    id?: true
    open_question_id?: true
    description?: true
  }

  export type Open_answersCountAggregateInputType = {
    id?: true
    open_question_id?: true
    description?: true
    _all?: true
  }

  export type Open_answersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which open_answers to aggregate.
     */
    where?: open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_answers to fetch.
     */
    orderBy?: open_answersOrderByWithRelationInput | open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned open_answers
    **/
    _count?: true | Open_answersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Open_answersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Open_answersMaxAggregateInputType
  }

  export type GetOpen_answersAggregateType<T extends Open_answersAggregateArgs> = {
        [P in keyof T & keyof AggregateOpen_answers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpen_answers[P]>
      : GetScalarType<T[P], AggregateOpen_answers[P]>
  }




  export type open_answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: open_answersWhereInput
    orderBy?: open_answersOrderByWithAggregationInput | open_answersOrderByWithAggregationInput[]
    by: Open_answersScalarFieldEnum[] | Open_answersScalarFieldEnum
    having?: open_answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Open_answersCountAggregateInputType | true
    _min?: Open_answersMinAggregateInputType
    _max?: Open_answersMaxAggregateInputType
  }

  export type Open_answersGroupByOutputType = {
    id: Uint8Array
    open_question_id: Uint8Array
    description: string
    _count: Open_answersCountAggregateOutputType | null
    _min: Open_answersMinAggregateOutputType | null
    _max: Open_answersMaxAggregateOutputType | null
  }

  type GetOpen_answersGroupByPayload<T extends open_answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Open_answersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Open_answersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Open_answersGroupByOutputType[P]>
            : GetScalarType<T[P], Open_answersGroupByOutputType[P]>
        }
      >
    >


  export type open_answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    open_question_id?: boolean
    description?: boolean
    open_questions?: boolean | open_questionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["open_answers"]>



  export type open_answersSelectScalar = {
    id?: boolean
    open_question_id?: boolean
    description?: boolean
  }

  export type open_answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    open_questions?: boolean | open_questionsDefaultArgs<ExtArgs>
  }

  export type $open_answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "open_answers"
    objects: {
      open_questions: Prisma.$open_questionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      open_question_id: Uint8Array
      description: string
    }, ExtArgs["result"]["open_answers"]>
    composites: {}
  }

  type open_answersGetPayload<S extends boolean | null | undefined | open_answersDefaultArgs> = $Result.GetResult<Prisma.$open_answersPayload, S>

  type open_answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<open_answersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Open_answersCountAggregateInputType | true
    }

  export interface open_answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['open_answers'], meta: { name: 'open_answers' } }
    /**
     * Find zero or one Open_answers that matches the filter.
     * @param {open_answersFindUniqueArgs} args - Arguments to find a Open_answers
     * @example
     * // Get one Open_answers
     * const open_answers = await prisma.open_answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends open_answersFindUniqueArgs>(args: SelectSubset<T, open_answersFindUniqueArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Open_answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {open_answersFindUniqueOrThrowArgs} args - Arguments to find a Open_answers
     * @example
     * // Get one Open_answers
     * const open_answers = await prisma.open_answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends open_answersFindUniqueOrThrowArgs>(args: SelectSubset<T, open_answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Open_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_answersFindFirstArgs} args - Arguments to find a Open_answers
     * @example
     * // Get one Open_answers
     * const open_answers = await prisma.open_answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends open_answersFindFirstArgs>(args?: SelectSubset<T, open_answersFindFirstArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Open_answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_answersFindFirstOrThrowArgs} args - Arguments to find a Open_answers
     * @example
     * // Get one Open_answers
     * const open_answers = await prisma.open_answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends open_answersFindFirstOrThrowArgs>(args?: SelectSubset<T, open_answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Open_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Open_answers
     * const open_answers = await prisma.open_answers.findMany()
     * 
     * // Get first 10 Open_answers
     * const open_answers = await prisma.open_answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const open_answersWithIdOnly = await prisma.open_answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends open_answersFindManyArgs>(args?: SelectSubset<T, open_answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Open_answers.
     * @param {open_answersCreateArgs} args - Arguments to create a Open_answers.
     * @example
     * // Create one Open_answers
     * const Open_answers = await prisma.open_answers.create({
     *   data: {
     *     // ... data to create a Open_answers
     *   }
     * })
     * 
     */
    create<T extends open_answersCreateArgs>(args: SelectSubset<T, open_answersCreateArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Open_answers.
     * @param {open_answersCreateManyArgs} args - Arguments to create many Open_answers.
     * @example
     * // Create many Open_answers
     * const open_answers = await prisma.open_answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends open_answersCreateManyArgs>(args?: SelectSubset<T, open_answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Open_answers.
     * @param {open_answersDeleteArgs} args - Arguments to delete one Open_answers.
     * @example
     * // Delete one Open_answers
     * const Open_answers = await prisma.open_answers.delete({
     *   where: {
     *     // ... filter to delete one Open_answers
     *   }
     * })
     * 
     */
    delete<T extends open_answersDeleteArgs>(args: SelectSubset<T, open_answersDeleteArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Open_answers.
     * @param {open_answersUpdateArgs} args - Arguments to update one Open_answers.
     * @example
     * // Update one Open_answers
     * const open_answers = await prisma.open_answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends open_answersUpdateArgs>(args: SelectSubset<T, open_answersUpdateArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Open_answers.
     * @param {open_answersDeleteManyArgs} args - Arguments to filter Open_answers to delete.
     * @example
     * // Delete a few Open_answers
     * const { count } = await prisma.open_answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends open_answersDeleteManyArgs>(args?: SelectSubset<T, open_answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Open_answers
     * const open_answers = await prisma.open_answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends open_answersUpdateManyArgs>(args: SelectSubset<T, open_answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Open_answers.
     * @param {open_answersUpsertArgs} args - Arguments to update or create a Open_answers.
     * @example
     * // Update or create a Open_answers
     * const open_answers = await prisma.open_answers.upsert({
     *   create: {
     *     // ... data to create a Open_answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Open_answers we want to update
     *   }
     * })
     */
    upsert<T extends open_answersUpsertArgs>(args: SelectSubset<T, open_answersUpsertArgs<ExtArgs>>): Prisma__open_answersClient<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_answersCountArgs} args - Arguments to filter Open_answers to count.
     * @example
     * // Count the number of Open_answers
     * const count = await prisma.open_answers.count({
     *   where: {
     *     // ... the filter for the Open_answers we want to count
     *   }
     * })
    **/
    count<T extends open_answersCountArgs>(
      args?: Subset<T, open_answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Open_answersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Open_answersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Open_answersAggregateArgs>(args: Subset<T, Open_answersAggregateArgs>): Prisma.PrismaPromise<GetOpen_answersAggregateType<T>>

    /**
     * Group by Open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends open_answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: open_answersGroupByArgs['orderBy'] }
        : { orderBy?: open_answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, open_answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpen_answersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the open_answers model
   */
  readonly fields: open_answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for open_answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__open_answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    open_questions<T extends open_questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, open_questionsDefaultArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the open_answers model
   */ 
  interface open_answersFieldRefs {
    readonly id: FieldRef<"open_answers", 'Bytes'>
    readonly open_question_id: FieldRef<"open_answers", 'Bytes'>
    readonly description: FieldRef<"open_answers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * open_answers findUnique
   */
  export type open_answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * Filter, which open_answers to fetch.
     */
    where: open_answersWhereUniqueInput
  }

  /**
   * open_answers findUniqueOrThrow
   */
  export type open_answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * Filter, which open_answers to fetch.
     */
    where: open_answersWhereUniqueInput
  }

  /**
   * open_answers findFirst
   */
  export type open_answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * Filter, which open_answers to fetch.
     */
    where?: open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_answers to fetch.
     */
    orderBy?: open_answersOrderByWithRelationInput | open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for open_answers.
     */
    cursor?: open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of open_answers.
     */
    distinct?: Open_answersScalarFieldEnum | Open_answersScalarFieldEnum[]
  }

  /**
   * open_answers findFirstOrThrow
   */
  export type open_answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * Filter, which open_answers to fetch.
     */
    where?: open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_answers to fetch.
     */
    orderBy?: open_answersOrderByWithRelationInput | open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for open_answers.
     */
    cursor?: open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of open_answers.
     */
    distinct?: Open_answersScalarFieldEnum | Open_answersScalarFieldEnum[]
  }

  /**
   * open_answers findMany
   */
  export type open_answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * Filter, which open_answers to fetch.
     */
    where?: open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_answers to fetch.
     */
    orderBy?: open_answersOrderByWithRelationInput | open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing open_answers.
     */
    cursor?: open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_answers.
     */
    skip?: number
    distinct?: Open_answersScalarFieldEnum | Open_answersScalarFieldEnum[]
  }

  /**
   * open_answers create
   */
  export type open_answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * The data needed to create a open_answers.
     */
    data: XOR<open_answersCreateInput, open_answersUncheckedCreateInput>
  }

  /**
   * open_answers createMany
   */
  export type open_answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many open_answers.
     */
    data: open_answersCreateManyInput | open_answersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * open_answers update
   */
  export type open_answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * The data needed to update a open_answers.
     */
    data: XOR<open_answersUpdateInput, open_answersUncheckedUpdateInput>
    /**
     * Choose, which open_answers to update.
     */
    where: open_answersWhereUniqueInput
  }

  /**
   * open_answers updateMany
   */
  export type open_answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update open_answers.
     */
    data: XOR<open_answersUpdateManyMutationInput, open_answersUncheckedUpdateManyInput>
    /**
     * Filter which open_answers to update
     */
    where?: open_answersWhereInput
  }

  /**
   * open_answers upsert
   */
  export type open_answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * The filter to search for the open_answers to update in case it exists.
     */
    where: open_answersWhereUniqueInput
    /**
     * In case the open_answers found by the `where` argument doesn't exist, create a new open_answers with this data.
     */
    create: XOR<open_answersCreateInput, open_answersUncheckedCreateInput>
    /**
     * In case the open_answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<open_answersUpdateInput, open_answersUncheckedUpdateInput>
  }

  /**
   * open_answers delete
   */
  export type open_answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    /**
     * Filter which open_answers to delete.
     */
    where: open_answersWhereUniqueInput
  }

  /**
   * open_answers deleteMany
   */
  export type open_answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which open_answers to delete
     */
    where?: open_answersWhereInput
  }

  /**
   * open_answers without action
   */
  export type open_answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
  }


  /**
   * Model open_questions
   */

  export type AggregateOpen_questions = {
    _count: Open_questionsCountAggregateOutputType | null
    _avg: Open_questionsAvgAggregateOutputType | null
    _sum: Open_questionsSumAggregateOutputType | null
    _min: Open_questionsMinAggregateOutputType | null
    _max: Open_questionsMaxAggregateOutputType | null
  }

  export type Open_questionsAvgAggregateOutputType = {
    score: number | null
  }

  export type Open_questionsSumAggregateOutputType = {
    score: number | null
  }

  export type Open_questionsMinAggregateOutputType = {
    id: Uint8Array | null
    exam_id: Uint8Array | null
    auto_check: boolean | null
    description: string | null
    score: number | null
  }

  export type Open_questionsMaxAggregateOutputType = {
    id: Uint8Array | null
    exam_id: Uint8Array | null
    auto_check: boolean | null
    description: string | null
    score: number | null
  }

  export type Open_questionsCountAggregateOutputType = {
    id: number
    exam_id: number
    auto_check: number
    description: number
    score: number
    _all: number
  }


  export type Open_questionsAvgAggregateInputType = {
    score?: true
  }

  export type Open_questionsSumAggregateInputType = {
    score?: true
  }

  export type Open_questionsMinAggregateInputType = {
    id?: true
    exam_id?: true
    auto_check?: true
    description?: true
    score?: true
  }

  export type Open_questionsMaxAggregateInputType = {
    id?: true
    exam_id?: true
    auto_check?: true
    description?: true
    score?: true
  }

  export type Open_questionsCountAggregateInputType = {
    id?: true
    exam_id?: true
    auto_check?: true
    description?: true
    score?: true
    _all?: true
  }

  export type Open_questionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which open_questions to aggregate.
     */
    where?: open_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_questions to fetch.
     */
    orderBy?: open_questionsOrderByWithRelationInput | open_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: open_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned open_questions
    **/
    _count?: true | Open_questionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Open_questionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Open_questionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Open_questionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Open_questionsMaxAggregateInputType
  }

  export type GetOpen_questionsAggregateType<T extends Open_questionsAggregateArgs> = {
        [P in keyof T & keyof AggregateOpen_questions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpen_questions[P]>
      : GetScalarType<T[P], AggregateOpen_questions[P]>
  }




  export type open_questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: open_questionsWhereInput
    orderBy?: open_questionsOrderByWithAggregationInput | open_questionsOrderByWithAggregationInput[]
    by: Open_questionsScalarFieldEnum[] | Open_questionsScalarFieldEnum
    having?: open_questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Open_questionsCountAggregateInputType | true
    _avg?: Open_questionsAvgAggregateInputType
    _sum?: Open_questionsSumAggregateInputType
    _min?: Open_questionsMinAggregateInputType
    _max?: Open_questionsMaxAggregateInputType
  }

  export type Open_questionsGroupByOutputType = {
    id: Uint8Array
    exam_id: Uint8Array
    auto_check: boolean
    description: string | null
    score: number
    _count: Open_questionsCountAggregateOutputType | null
    _avg: Open_questionsAvgAggregateOutputType | null
    _sum: Open_questionsSumAggregateOutputType | null
    _min: Open_questionsMinAggregateOutputType | null
    _max: Open_questionsMaxAggregateOutputType | null
  }

  type GetOpen_questionsGroupByPayload<T extends open_questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Open_questionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Open_questionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Open_questionsGroupByOutputType[P]>
            : GetScalarType<T[P], Open_questionsGroupByOutputType[P]>
        }
      >
    >


  export type open_questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exam_id?: boolean
    auto_check?: boolean
    description?: boolean
    score?: boolean
    attempt_questions?: boolean | open_questions$attempt_questionsArgs<ExtArgs>
    open_answers?: boolean | open_questions$open_answersArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
    student_open_answers?: boolean | open_questions$student_open_answersArgs<ExtArgs>
    _count?: boolean | Open_questionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["open_questions"]>



  export type open_questionsSelectScalar = {
    id?: boolean
    exam_id?: boolean
    auto_check?: boolean
    description?: boolean
    score?: boolean
  }

  export type open_questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt_questions?: boolean | open_questions$attempt_questionsArgs<ExtArgs>
    open_answers?: boolean | open_questions$open_answersArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
    student_open_answers?: boolean | open_questions$student_open_answersArgs<ExtArgs>
    _count?: boolean | Open_questionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $open_questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "open_questions"
    objects: {
      attempt_questions: Prisma.$attempt_questionsPayload<ExtArgs>[]
      open_answers: Prisma.$open_answersPayload<ExtArgs>[]
      exams: Prisma.$examsPayload<ExtArgs>
      student_open_answers: Prisma.$student_open_answersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      exam_id: Uint8Array
      auto_check: boolean
      description: string | null
      score: number
    }, ExtArgs["result"]["open_questions"]>
    composites: {}
  }

  type open_questionsGetPayload<S extends boolean | null | undefined | open_questionsDefaultArgs> = $Result.GetResult<Prisma.$open_questionsPayload, S>

  type open_questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<open_questionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Open_questionsCountAggregateInputType | true
    }

  export interface open_questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['open_questions'], meta: { name: 'open_questions' } }
    /**
     * Find zero or one Open_questions that matches the filter.
     * @param {open_questionsFindUniqueArgs} args - Arguments to find a Open_questions
     * @example
     * // Get one Open_questions
     * const open_questions = await prisma.open_questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends open_questionsFindUniqueArgs>(args: SelectSubset<T, open_questionsFindUniqueArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Open_questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {open_questionsFindUniqueOrThrowArgs} args - Arguments to find a Open_questions
     * @example
     * // Get one Open_questions
     * const open_questions = await prisma.open_questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends open_questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, open_questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Open_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_questionsFindFirstArgs} args - Arguments to find a Open_questions
     * @example
     * // Get one Open_questions
     * const open_questions = await prisma.open_questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends open_questionsFindFirstArgs>(args?: SelectSubset<T, open_questionsFindFirstArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Open_questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_questionsFindFirstOrThrowArgs} args - Arguments to find a Open_questions
     * @example
     * // Get one Open_questions
     * const open_questions = await prisma.open_questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends open_questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, open_questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Open_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Open_questions
     * const open_questions = await prisma.open_questions.findMany()
     * 
     * // Get first 10 Open_questions
     * const open_questions = await prisma.open_questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const open_questionsWithIdOnly = await prisma.open_questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends open_questionsFindManyArgs>(args?: SelectSubset<T, open_questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Open_questions.
     * @param {open_questionsCreateArgs} args - Arguments to create a Open_questions.
     * @example
     * // Create one Open_questions
     * const Open_questions = await prisma.open_questions.create({
     *   data: {
     *     // ... data to create a Open_questions
     *   }
     * })
     * 
     */
    create<T extends open_questionsCreateArgs>(args: SelectSubset<T, open_questionsCreateArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Open_questions.
     * @param {open_questionsCreateManyArgs} args - Arguments to create many Open_questions.
     * @example
     * // Create many Open_questions
     * const open_questions = await prisma.open_questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends open_questionsCreateManyArgs>(args?: SelectSubset<T, open_questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Open_questions.
     * @param {open_questionsDeleteArgs} args - Arguments to delete one Open_questions.
     * @example
     * // Delete one Open_questions
     * const Open_questions = await prisma.open_questions.delete({
     *   where: {
     *     // ... filter to delete one Open_questions
     *   }
     * })
     * 
     */
    delete<T extends open_questionsDeleteArgs>(args: SelectSubset<T, open_questionsDeleteArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Open_questions.
     * @param {open_questionsUpdateArgs} args - Arguments to update one Open_questions.
     * @example
     * // Update one Open_questions
     * const open_questions = await prisma.open_questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends open_questionsUpdateArgs>(args: SelectSubset<T, open_questionsUpdateArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Open_questions.
     * @param {open_questionsDeleteManyArgs} args - Arguments to filter Open_questions to delete.
     * @example
     * // Delete a few Open_questions
     * const { count } = await prisma.open_questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends open_questionsDeleteManyArgs>(args?: SelectSubset<T, open_questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Open_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Open_questions
     * const open_questions = await prisma.open_questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends open_questionsUpdateManyArgs>(args: SelectSubset<T, open_questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Open_questions.
     * @param {open_questionsUpsertArgs} args - Arguments to update or create a Open_questions.
     * @example
     * // Update or create a Open_questions
     * const open_questions = await prisma.open_questions.upsert({
     *   create: {
     *     // ... data to create a Open_questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Open_questions we want to update
     *   }
     * })
     */
    upsert<T extends open_questionsUpsertArgs>(args: SelectSubset<T, open_questionsUpsertArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Open_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_questionsCountArgs} args - Arguments to filter Open_questions to count.
     * @example
     * // Count the number of Open_questions
     * const count = await prisma.open_questions.count({
     *   where: {
     *     // ... the filter for the Open_questions we want to count
     *   }
     * })
    **/
    count<T extends open_questionsCountArgs>(
      args?: Subset<T, open_questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Open_questionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Open_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Open_questionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Open_questionsAggregateArgs>(args: Subset<T, Open_questionsAggregateArgs>): Prisma.PrismaPromise<GetOpen_questionsAggregateType<T>>

    /**
     * Group by Open_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {open_questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends open_questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: open_questionsGroupByArgs['orderBy'] }
        : { orderBy?: open_questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, open_questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpen_questionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the open_questions model
   */
  readonly fields: open_questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for open_questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__open_questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt_questions<T extends open_questions$attempt_questionsArgs<ExtArgs> = {}>(args?: Subset<T, open_questions$attempt_questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attempt_questionsPayload<ExtArgs>, T, "findMany"> | Null>
    open_answers<T extends open_questions$open_answersArgs<ExtArgs> = {}>(args?: Subset<T, open_questions$open_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$open_answersPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examsDefaultArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student_open_answers<T extends open_questions$student_open_answersArgs<ExtArgs> = {}>(args?: Subset<T, open_questions$student_open_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the open_questions model
   */ 
  interface open_questionsFieldRefs {
    readonly id: FieldRef<"open_questions", 'Bytes'>
    readonly exam_id: FieldRef<"open_questions", 'Bytes'>
    readonly auto_check: FieldRef<"open_questions", 'Boolean'>
    readonly description: FieldRef<"open_questions", 'String'>
    readonly score: FieldRef<"open_questions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * open_questions findUnique
   */
  export type open_questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * Filter, which open_questions to fetch.
     */
    where: open_questionsWhereUniqueInput
  }

  /**
   * open_questions findUniqueOrThrow
   */
  export type open_questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * Filter, which open_questions to fetch.
     */
    where: open_questionsWhereUniqueInput
  }

  /**
   * open_questions findFirst
   */
  export type open_questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * Filter, which open_questions to fetch.
     */
    where?: open_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_questions to fetch.
     */
    orderBy?: open_questionsOrderByWithRelationInput | open_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for open_questions.
     */
    cursor?: open_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of open_questions.
     */
    distinct?: Open_questionsScalarFieldEnum | Open_questionsScalarFieldEnum[]
  }

  /**
   * open_questions findFirstOrThrow
   */
  export type open_questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * Filter, which open_questions to fetch.
     */
    where?: open_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_questions to fetch.
     */
    orderBy?: open_questionsOrderByWithRelationInput | open_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for open_questions.
     */
    cursor?: open_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of open_questions.
     */
    distinct?: Open_questionsScalarFieldEnum | Open_questionsScalarFieldEnum[]
  }

  /**
   * open_questions findMany
   */
  export type open_questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * Filter, which open_questions to fetch.
     */
    where?: open_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of open_questions to fetch.
     */
    orderBy?: open_questionsOrderByWithRelationInput | open_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing open_questions.
     */
    cursor?: open_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` open_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` open_questions.
     */
    skip?: number
    distinct?: Open_questionsScalarFieldEnum | Open_questionsScalarFieldEnum[]
  }

  /**
   * open_questions create
   */
  export type open_questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a open_questions.
     */
    data: XOR<open_questionsCreateInput, open_questionsUncheckedCreateInput>
  }

  /**
   * open_questions createMany
   */
  export type open_questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many open_questions.
     */
    data: open_questionsCreateManyInput | open_questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * open_questions update
   */
  export type open_questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a open_questions.
     */
    data: XOR<open_questionsUpdateInput, open_questionsUncheckedUpdateInput>
    /**
     * Choose, which open_questions to update.
     */
    where: open_questionsWhereUniqueInput
  }

  /**
   * open_questions updateMany
   */
  export type open_questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update open_questions.
     */
    data: XOR<open_questionsUpdateManyMutationInput, open_questionsUncheckedUpdateManyInput>
    /**
     * Filter which open_questions to update
     */
    where?: open_questionsWhereInput
  }

  /**
   * open_questions upsert
   */
  export type open_questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the open_questions to update in case it exists.
     */
    where: open_questionsWhereUniqueInput
    /**
     * In case the open_questions found by the `where` argument doesn't exist, create a new open_questions with this data.
     */
    create: XOR<open_questionsCreateInput, open_questionsUncheckedCreateInput>
    /**
     * In case the open_questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<open_questionsUpdateInput, open_questionsUncheckedUpdateInput>
  }

  /**
   * open_questions delete
   */
  export type open_questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
    /**
     * Filter which open_questions to delete.
     */
    where: open_questionsWhereUniqueInput
  }

  /**
   * open_questions deleteMany
   */
  export type open_questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which open_questions to delete
     */
    where?: open_questionsWhereInput
  }

  /**
   * open_questions.attempt_questions
   */
  export type open_questions$attempt_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attempt_questions
     */
    select?: attempt_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attempt_questionsInclude<ExtArgs> | null
    where?: attempt_questionsWhereInput
    orderBy?: attempt_questionsOrderByWithRelationInput | attempt_questionsOrderByWithRelationInput[]
    cursor?: attempt_questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Attempt_questionsScalarFieldEnum | Attempt_questionsScalarFieldEnum[]
  }

  /**
   * open_questions.open_answers
   */
  export type open_questions$open_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_answers
     */
    select?: open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_answersInclude<ExtArgs> | null
    where?: open_answersWhereInput
    orderBy?: open_answersOrderByWithRelationInput | open_answersOrderByWithRelationInput[]
    cursor?: open_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Open_answersScalarFieldEnum | Open_answersScalarFieldEnum[]
  }

  /**
   * open_questions.student_open_answers
   */
  export type open_questions$student_open_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    where?: student_open_answersWhereInput
    orderBy?: student_open_answersOrderByWithRelationInput | student_open_answersOrderByWithRelationInput[]
    cursor?: student_open_answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_open_answersScalarFieldEnum | Student_open_answersScalarFieldEnum[]
  }

  /**
   * open_questions without action
   */
  export type open_questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the open_questions
     */
    select?: open_questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: open_questionsInclude<ExtArgs> | null
  }


  /**
   * Model student_closed_answers
   */

  export type AggregateStudent_closed_answers = {
    _count: Student_closed_answersCountAggregateOutputType | null
    _min: Student_closed_answersMinAggregateOutputType | null
    _max: Student_closed_answersMaxAggregateOutputType | null
  }

  export type Student_closed_answersMinAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    closed_question_id: Uint8Array | null
    closed_answer_id: Uint8Array | null
    attempt_id: Uint8Array | null
    correctness: boolean | null
    date_time: Date | null
  }

  export type Student_closed_answersMaxAggregateOutputType = {
    id: Uint8Array | null
    student_id: Uint8Array | null
    closed_question_id: Uint8Array | null
    closed_answer_id: Uint8Array | null
    attempt_id: Uint8Array | null
    correctness: boolean | null
    date_time: Date | null
  }

  export type Student_closed_answersCountAggregateOutputType = {
    id: number
    student_id: number
    closed_question_id: number
    closed_answer_id: number
    attempt_id: number
    correctness: number
    date_time: number
    _all: number
  }


  export type Student_closed_answersMinAggregateInputType = {
    id?: true
    student_id?: true
    closed_question_id?: true
    closed_answer_id?: true
    attempt_id?: true
    correctness?: true
    date_time?: true
  }

  export type Student_closed_answersMaxAggregateInputType = {
    id?: true
    student_id?: true
    closed_question_id?: true
    closed_answer_id?: true
    attempt_id?: true
    correctness?: true
    date_time?: true
  }

  export type Student_closed_answersCountAggregateInputType = {
    id?: true
    student_id?: true
    closed_question_id?: true
    closed_answer_id?: true
    attempt_id?: true
    correctness?: true
    date_time?: true
    _all?: true
  }

  export type Student_closed_answersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_closed_answers to aggregate.
     */
    where?: student_closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_closed_answers to fetch.
     */
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_closed_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_closed_answers
    **/
    _count?: true | Student_closed_answersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_closed_answersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_closed_answersMaxAggregateInputType
  }

  export type GetStudent_closed_answersAggregateType<T extends Student_closed_answersAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_closed_answers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_closed_answers[P]>
      : GetScalarType<T[P], AggregateStudent_closed_answers[P]>
  }




  export type student_closed_answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_closed_answersWhereInput
    orderBy?: student_closed_answersOrderByWithAggregationInput | student_closed_answersOrderByWithAggregationInput[]
    by: Student_closed_answersScalarFieldEnum[] | Student_closed_answersScalarFieldEnum
    having?: student_closed_answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_closed_answersCountAggregateInputType | true
    _min?: Student_closed_answersMinAggregateInputType
    _max?: Student_closed_answersMaxAggregateInputType
  }

  export type Student_closed_answersGroupByOutputType = {
    id: Uint8Array
    student_id: Uint8Array
    closed_question_id: Uint8Array
    closed_answer_id: Uint8Array
    attempt_id: Uint8Array
    correctness: boolean | null
    date_time: Date | null
    _count: Student_closed_answersCountAggregateOutputType | null
    _min: Student_closed_answersMinAggregateOutputType | null
    _max: Student_closed_answersMaxAggregateOutputType | null
  }

  type GetStudent_closed_answersGroupByPayload<T extends student_closed_answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_closed_answersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_closed_answersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_closed_answersGroupByOutputType[P]>
            : GetScalarType<T[P], Student_closed_answersGroupByOutputType[P]>
        }
      >
    >


  export type student_closed_answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    closed_question_id?: boolean
    closed_answer_id?: boolean
    attempt_id?: boolean
    correctness?: boolean
    date_time?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    closed_questions?: boolean | closed_questionsDefaultArgs<ExtArgs>
    closed_answers?: boolean | closed_answersDefaultArgs<ExtArgs>
    attempts?: boolean | attemptsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_closed_answers"]>



  export type student_closed_answersSelectScalar = {
    id?: boolean
    student_id?: boolean
    closed_question_id?: boolean
    closed_answer_id?: boolean
    attempt_id?: boolean
    correctness?: boolean
    date_time?: boolean
  }

  export type student_closed_answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    closed_questions?: boolean | closed_questionsDefaultArgs<ExtArgs>
    closed_answers?: boolean | closed_answersDefaultArgs<ExtArgs>
    attempts?: boolean | attemptsDefaultArgs<ExtArgs>
  }

  export type $student_closed_answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_closed_answers"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      closed_questions: Prisma.$closed_questionsPayload<ExtArgs>
      closed_answers: Prisma.$closed_answersPayload<ExtArgs>
      attempts: Prisma.$attemptsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      student_id: Uint8Array
      closed_question_id: Uint8Array
      closed_answer_id: Uint8Array
      attempt_id: Uint8Array
      correctness: boolean | null
      date_time: Date | null
    }, ExtArgs["result"]["student_closed_answers"]>
    composites: {}
  }

  type student_closed_answersGetPayload<S extends boolean | null | undefined | student_closed_answersDefaultArgs> = $Result.GetResult<Prisma.$student_closed_answersPayload, S>

  type student_closed_answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_closed_answersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_closed_answersCountAggregateInputType | true
    }

  export interface student_closed_answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_closed_answers'], meta: { name: 'student_closed_answers' } }
    /**
     * Find zero or one Student_closed_answers that matches the filter.
     * @param {student_closed_answersFindUniqueArgs} args - Arguments to find a Student_closed_answers
     * @example
     * // Get one Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_closed_answersFindUniqueArgs>(args: SelectSubset<T, student_closed_answersFindUniqueArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_closed_answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_closed_answersFindUniqueOrThrowArgs} args - Arguments to find a Student_closed_answers
     * @example
     * // Get one Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_closed_answersFindUniqueOrThrowArgs>(args: SelectSubset<T, student_closed_answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_closed_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_closed_answersFindFirstArgs} args - Arguments to find a Student_closed_answers
     * @example
     * // Get one Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_closed_answersFindFirstArgs>(args?: SelectSubset<T, student_closed_answersFindFirstArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_closed_answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_closed_answersFindFirstOrThrowArgs} args - Arguments to find a Student_closed_answers
     * @example
     * // Get one Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_closed_answersFindFirstOrThrowArgs>(args?: SelectSubset<T, student_closed_answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_closed_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_closed_answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.findMany()
     * 
     * // Get first 10 Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const student_closed_answersWithIdOnly = await prisma.student_closed_answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends student_closed_answersFindManyArgs>(args?: SelectSubset<T, student_closed_answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_closed_answers.
     * @param {student_closed_answersCreateArgs} args - Arguments to create a Student_closed_answers.
     * @example
     * // Create one Student_closed_answers
     * const Student_closed_answers = await prisma.student_closed_answers.create({
     *   data: {
     *     // ... data to create a Student_closed_answers
     *   }
     * })
     * 
     */
    create<T extends student_closed_answersCreateArgs>(args: SelectSubset<T, student_closed_answersCreateArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_closed_answers.
     * @param {student_closed_answersCreateManyArgs} args - Arguments to create many Student_closed_answers.
     * @example
     * // Create many Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_closed_answersCreateManyArgs>(args?: SelectSubset<T, student_closed_answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student_closed_answers.
     * @param {student_closed_answersDeleteArgs} args - Arguments to delete one Student_closed_answers.
     * @example
     * // Delete one Student_closed_answers
     * const Student_closed_answers = await prisma.student_closed_answers.delete({
     *   where: {
     *     // ... filter to delete one Student_closed_answers
     *   }
     * })
     * 
     */
    delete<T extends student_closed_answersDeleteArgs>(args: SelectSubset<T, student_closed_answersDeleteArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_closed_answers.
     * @param {student_closed_answersUpdateArgs} args - Arguments to update one Student_closed_answers.
     * @example
     * // Update one Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_closed_answersUpdateArgs>(args: SelectSubset<T, student_closed_answersUpdateArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_closed_answers.
     * @param {student_closed_answersDeleteManyArgs} args - Arguments to filter Student_closed_answers to delete.
     * @example
     * // Delete a few Student_closed_answers
     * const { count } = await prisma.student_closed_answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_closed_answersDeleteManyArgs>(args?: SelectSubset<T, student_closed_answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_closed_answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_closed_answersUpdateManyArgs>(args: SelectSubset<T, student_closed_answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_closed_answers.
     * @param {student_closed_answersUpsertArgs} args - Arguments to update or create a Student_closed_answers.
     * @example
     * // Update or create a Student_closed_answers
     * const student_closed_answers = await prisma.student_closed_answers.upsert({
     *   create: {
     *     // ... data to create a Student_closed_answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_closed_answers we want to update
     *   }
     * })
     */
    upsert<T extends student_closed_answersUpsertArgs>(args: SelectSubset<T, student_closed_answersUpsertArgs<ExtArgs>>): Prisma__student_closed_answersClient<$Result.GetResult<Prisma.$student_closed_answersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_closed_answersCountArgs} args - Arguments to filter Student_closed_answers to count.
     * @example
     * // Count the number of Student_closed_answers
     * const count = await prisma.student_closed_answers.count({
     *   where: {
     *     // ... the filter for the Student_closed_answers we want to count
     *   }
     * })
    **/
    count<T extends student_closed_answersCountArgs>(
      args?: Subset<T, student_closed_answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_closed_answersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_closed_answersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_closed_answersAggregateArgs>(args: Subset<T, Student_closed_answersAggregateArgs>): Prisma.PrismaPromise<GetStudent_closed_answersAggregateType<T>>

    /**
     * Group by Student_closed_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_closed_answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_closed_answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_closed_answersGroupByArgs['orderBy'] }
        : { orderBy?: student_closed_answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_closed_answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_closed_answersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_closed_answers model
   */
  readonly fields: student_closed_answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_closed_answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_closed_answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    closed_questions<T extends closed_questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, closed_questionsDefaultArgs<ExtArgs>>): Prisma__closed_questionsClient<$Result.GetResult<Prisma.$closed_questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    closed_answers<T extends closed_answersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, closed_answersDefaultArgs<ExtArgs>>): Prisma__closed_answersClient<$Result.GetResult<Prisma.$closed_answersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attempts<T extends attemptsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, attemptsDefaultArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_closed_answers model
   */ 
  interface student_closed_answersFieldRefs {
    readonly id: FieldRef<"student_closed_answers", 'Bytes'>
    readonly student_id: FieldRef<"student_closed_answers", 'Bytes'>
    readonly closed_question_id: FieldRef<"student_closed_answers", 'Bytes'>
    readonly closed_answer_id: FieldRef<"student_closed_answers", 'Bytes'>
    readonly attempt_id: FieldRef<"student_closed_answers", 'Bytes'>
    readonly correctness: FieldRef<"student_closed_answers", 'Boolean'>
    readonly date_time: FieldRef<"student_closed_answers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student_closed_answers findUnique
   */
  export type student_closed_answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_closed_answers to fetch.
     */
    where: student_closed_answersWhereUniqueInput
  }

  /**
   * student_closed_answers findUniqueOrThrow
   */
  export type student_closed_answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_closed_answers to fetch.
     */
    where: student_closed_answersWhereUniqueInput
  }

  /**
   * student_closed_answers findFirst
   */
  export type student_closed_answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_closed_answers to fetch.
     */
    where?: student_closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_closed_answers to fetch.
     */
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_closed_answers.
     */
    cursor?: student_closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_closed_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_closed_answers.
     */
    distinct?: Student_closed_answersScalarFieldEnum | Student_closed_answersScalarFieldEnum[]
  }

  /**
   * student_closed_answers findFirstOrThrow
   */
  export type student_closed_answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_closed_answers to fetch.
     */
    where?: student_closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_closed_answers to fetch.
     */
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_closed_answers.
     */
    cursor?: student_closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_closed_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_closed_answers.
     */
    distinct?: Student_closed_answersScalarFieldEnum | Student_closed_answersScalarFieldEnum[]
  }

  /**
   * student_closed_answers findMany
   */
  export type student_closed_answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_closed_answers to fetch.
     */
    where?: student_closed_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_closed_answers to fetch.
     */
    orderBy?: student_closed_answersOrderByWithRelationInput | student_closed_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_closed_answers.
     */
    cursor?: student_closed_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_closed_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_closed_answers.
     */
    skip?: number
    distinct?: Student_closed_answersScalarFieldEnum | Student_closed_answersScalarFieldEnum[]
  }

  /**
   * student_closed_answers create
   */
  export type student_closed_answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * The data needed to create a student_closed_answers.
     */
    data: XOR<student_closed_answersCreateInput, student_closed_answersUncheckedCreateInput>
  }

  /**
   * student_closed_answers createMany
   */
  export type student_closed_answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_closed_answers.
     */
    data: student_closed_answersCreateManyInput | student_closed_answersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_closed_answers update
   */
  export type student_closed_answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * The data needed to update a student_closed_answers.
     */
    data: XOR<student_closed_answersUpdateInput, student_closed_answersUncheckedUpdateInput>
    /**
     * Choose, which student_closed_answers to update.
     */
    where: student_closed_answersWhereUniqueInput
  }

  /**
   * student_closed_answers updateMany
   */
  export type student_closed_answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_closed_answers.
     */
    data: XOR<student_closed_answersUpdateManyMutationInput, student_closed_answersUncheckedUpdateManyInput>
    /**
     * Filter which student_closed_answers to update
     */
    where?: student_closed_answersWhereInput
  }

  /**
   * student_closed_answers upsert
   */
  export type student_closed_answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * The filter to search for the student_closed_answers to update in case it exists.
     */
    where: student_closed_answersWhereUniqueInput
    /**
     * In case the student_closed_answers found by the `where` argument doesn't exist, create a new student_closed_answers with this data.
     */
    create: XOR<student_closed_answersCreateInput, student_closed_answersUncheckedCreateInput>
    /**
     * In case the student_closed_answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_closed_answersUpdateInput, student_closed_answersUncheckedUpdateInput>
  }

  /**
   * student_closed_answers delete
   */
  export type student_closed_answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
    /**
     * Filter which student_closed_answers to delete.
     */
    where: student_closed_answersWhereUniqueInput
  }

  /**
   * student_closed_answers deleteMany
   */
  export type student_closed_answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_closed_answers to delete
     */
    where?: student_closed_answersWhereInput
  }

  /**
   * student_closed_answers without action
   */
  export type student_closed_answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_closed_answers
     */
    select?: student_closed_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_closed_answersInclude<ExtArgs> | null
  }


  /**
   * Model student_open_answers
   */

  export type AggregateStudent_open_answers = {
    _count: Student_open_answersCountAggregateOutputType | null
    _avg: Student_open_answersAvgAggregateOutputType | null
    _sum: Student_open_answersSumAggregateOutputType | null
    _min: Student_open_answersMinAggregateOutputType | null
    _max: Student_open_answersMaxAggregateOutputType | null
  }

  export type Student_open_answersAvgAggregateOutputType = {
    score: number | null
  }

  export type Student_open_answersSumAggregateOutputType = {
    score: number | null
  }

  export type Student_open_answersMinAggregateOutputType = {
    id: Uint8Array | null
    open_question_id: Uint8Array | null
    score: number | null
    student_id: Uint8Array | null
    attempt_id: Uint8Array | null
    date_time: Date | null
    description: string | null
  }

  export type Student_open_answersMaxAggregateOutputType = {
    id: Uint8Array | null
    open_question_id: Uint8Array | null
    score: number | null
    student_id: Uint8Array | null
    attempt_id: Uint8Array | null
    date_time: Date | null
    description: string | null
  }

  export type Student_open_answersCountAggregateOutputType = {
    id: number
    open_question_id: number
    score: number
    student_id: number
    attempt_id: number
    date_time: number
    description: number
    _all: number
  }


  export type Student_open_answersAvgAggregateInputType = {
    score?: true
  }

  export type Student_open_answersSumAggregateInputType = {
    score?: true
  }

  export type Student_open_answersMinAggregateInputType = {
    id?: true
    open_question_id?: true
    score?: true
    student_id?: true
    attempt_id?: true
    date_time?: true
    description?: true
  }

  export type Student_open_answersMaxAggregateInputType = {
    id?: true
    open_question_id?: true
    score?: true
    student_id?: true
    attempt_id?: true
    date_time?: true
    description?: true
  }

  export type Student_open_answersCountAggregateInputType = {
    id?: true
    open_question_id?: true
    score?: true
    student_id?: true
    attempt_id?: true
    date_time?: true
    description?: true
    _all?: true
  }

  export type Student_open_answersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_open_answers to aggregate.
     */
    where?: student_open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_open_answers to fetch.
     */
    orderBy?: student_open_answersOrderByWithRelationInput | student_open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_open_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_open_answers
    **/
    _count?: true | Student_open_answersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_open_answersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_open_answersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_open_answersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_open_answersMaxAggregateInputType
  }

  export type GetStudent_open_answersAggregateType<T extends Student_open_answersAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_open_answers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_open_answers[P]>
      : GetScalarType<T[P], AggregateStudent_open_answers[P]>
  }




  export type student_open_answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_open_answersWhereInput
    orderBy?: student_open_answersOrderByWithAggregationInput | student_open_answersOrderByWithAggregationInput[]
    by: Student_open_answersScalarFieldEnum[] | Student_open_answersScalarFieldEnum
    having?: student_open_answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_open_answersCountAggregateInputType | true
    _avg?: Student_open_answersAvgAggregateInputType
    _sum?: Student_open_answersSumAggregateInputType
    _min?: Student_open_answersMinAggregateInputType
    _max?: Student_open_answersMaxAggregateInputType
  }

  export type Student_open_answersGroupByOutputType = {
    id: Uint8Array
    open_question_id: Uint8Array
    score: number | null
    student_id: Uint8Array
    attempt_id: Uint8Array
    date_time: Date | null
    description: string | null
    _count: Student_open_answersCountAggregateOutputType | null
    _avg: Student_open_answersAvgAggregateOutputType | null
    _sum: Student_open_answersSumAggregateOutputType | null
    _min: Student_open_answersMinAggregateOutputType | null
    _max: Student_open_answersMaxAggregateOutputType | null
  }

  type GetStudent_open_answersGroupByPayload<T extends student_open_answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_open_answersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_open_answersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_open_answersGroupByOutputType[P]>
            : GetScalarType<T[P], Student_open_answersGroupByOutputType[P]>
        }
      >
    >


  export type student_open_answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    open_question_id?: boolean
    score?: boolean
    student_id?: boolean
    attempt_id?: boolean
    date_time?: boolean
    description?: boolean
    open_questions?: boolean | open_questionsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    attempts?: boolean | attemptsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_open_answers"]>



  export type student_open_answersSelectScalar = {
    id?: boolean
    open_question_id?: boolean
    score?: boolean
    student_id?: boolean
    attempt_id?: boolean
    date_time?: boolean
    description?: boolean
  }

  export type student_open_answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    open_questions?: boolean | open_questionsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    attempts?: boolean | attemptsDefaultArgs<ExtArgs>
  }

  export type $student_open_answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_open_answers"
    objects: {
      open_questions: Prisma.$open_questionsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
      attempts: Prisma.$attemptsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      open_question_id: Uint8Array
      score: number | null
      student_id: Uint8Array
      attempt_id: Uint8Array
      date_time: Date | null
      description: string | null
    }, ExtArgs["result"]["student_open_answers"]>
    composites: {}
  }

  type student_open_answersGetPayload<S extends boolean | null | undefined | student_open_answersDefaultArgs> = $Result.GetResult<Prisma.$student_open_answersPayload, S>

  type student_open_answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_open_answersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_open_answersCountAggregateInputType | true
    }

  export interface student_open_answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_open_answers'], meta: { name: 'student_open_answers' } }
    /**
     * Find zero or one Student_open_answers that matches the filter.
     * @param {student_open_answersFindUniqueArgs} args - Arguments to find a Student_open_answers
     * @example
     * // Get one Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_open_answersFindUniqueArgs>(args: SelectSubset<T, student_open_answersFindUniqueArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_open_answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_open_answersFindUniqueOrThrowArgs} args - Arguments to find a Student_open_answers
     * @example
     * // Get one Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_open_answersFindUniqueOrThrowArgs>(args: SelectSubset<T, student_open_answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_open_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_open_answersFindFirstArgs} args - Arguments to find a Student_open_answers
     * @example
     * // Get one Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_open_answersFindFirstArgs>(args?: SelectSubset<T, student_open_answersFindFirstArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_open_answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_open_answersFindFirstOrThrowArgs} args - Arguments to find a Student_open_answers
     * @example
     * // Get one Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_open_answersFindFirstOrThrowArgs>(args?: SelectSubset<T, student_open_answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_open_answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_open_answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.findMany()
     * 
     * // Get first 10 Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const student_open_answersWithIdOnly = await prisma.student_open_answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends student_open_answersFindManyArgs>(args?: SelectSubset<T, student_open_answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_open_answers.
     * @param {student_open_answersCreateArgs} args - Arguments to create a Student_open_answers.
     * @example
     * // Create one Student_open_answers
     * const Student_open_answers = await prisma.student_open_answers.create({
     *   data: {
     *     // ... data to create a Student_open_answers
     *   }
     * })
     * 
     */
    create<T extends student_open_answersCreateArgs>(args: SelectSubset<T, student_open_answersCreateArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_open_answers.
     * @param {student_open_answersCreateManyArgs} args - Arguments to create many Student_open_answers.
     * @example
     * // Create many Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_open_answersCreateManyArgs>(args?: SelectSubset<T, student_open_answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student_open_answers.
     * @param {student_open_answersDeleteArgs} args - Arguments to delete one Student_open_answers.
     * @example
     * // Delete one Student_open_answers
     * const Student_open_answers = await prisma.student_open_answers.delete({
     *   where: {
     *     // ... filter to delete one Student_open_answers
     *   }
     * })
     * 
     */
    delete<T extends student_open_answersDeleteArgs>(args: SelectSubset<T, student_open_answersDeleteArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_open_answers.
     * @param {student_open_answersUpdateArgs} args - Arguments to update one Student_open_answers.
     * @example
     * // Update one Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_open_answersUpdateArgs>(args: SelectSubset<T, student_open_answersUpdateArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_open_answers.
     * @param {student_open_answersDeleteManyArgs} args - Arguments to filter Student_open_answers to delete.
     * @example
     * // Delete a few Student_open_answers
     * const { count } = await prisma.student_open_answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_open_answersDeleteManyArgs>(args?: SelectSubset<T, student_open_answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_open_answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_open_answersUpdateManyArgs>(args: SelectSubset<T, student_open_answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_open_answers.
     * @param {student_open_answersUpsertArgs} args - Arguments to update or create a Student_open_answers.
     * @example
     * // Update or create a Student_open_answers
     * const student_open_answers = await prisma.student_open_answers.upsert({
     *   create: {
     *     // ... data to create a Student_open_answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_open_answers we want to update
     *   }
     * })
     */
    upsert<T extends student_open_answersUpsertArgs>(args: SelectSubset<T, student_open_answersUpsertArgs<ExtArgs>>): Prisma__student_open_answersClient<$Result.GetResult<Prisma.$student_open_answersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_open_answersCountArgs} args - Arguments to filter Student_open_answers to count.
     * @example
     * // Count the number of Student_open_answers
     * const count = await prisma.student_open_answers.count({
     *   where: {
     *     // ... the filter for the Student_open_answers we want to count
     *   }
     * })
    **/
    count<T extends student_open_answersCountArgs>(
      args?: Subset<T, student_open_answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_open_answersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_open_answersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_open_answersAggregateArgs>(args: Subset<T, Student_open_answersAggregateArgs>): Prisma.PrismaPromise<GetStudent_open_answersAggregateType<T>>

    /**
     * Group by Student_open_answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_open_answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_open_answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_open_answersGroupByArgs['orderBy'] }
        : { orderBy?: student_open_answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_open_answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_open_answersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_open_answers model
   */
  readonly fields: student_open_answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_open_answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_open_answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    open_questions<T extends open_questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, open_questionsDefaultArgs<ExtArgs>>): Prisma__open_questionsClient<$Result.GetResult<Prisma.$open_questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attempts<T extends attemptsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, attemptsDefaultArgs<ExtArgs>>): Prisma__attemptsClient<$Result.GetResult<Prisma.$attemptsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_open_answers model
   */ 
  interface student_open_answersFieldRefs {
    readonly id: FieldRef<"student_open_answers", 'Bytes'>
    readonly open_question_id: FieldRef<"student_open_answers", 'Bytes'>
    readonly score: FieldRef<"student_open_answers", 'Int'>
    readonly student_id: FieldRef<"student_open_answers", 'Bytes'>
    readonly attempt_id: FieldRef<"student_open_answers", 'Bytes'>
    readonly date_time: FieldRef<"student_open_answers", 'DateTime'>
    readonly description: FieldRef<"student_open_answers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * student_open_answers findUnique
   */
  export type student_open_answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_open_answers to fetch.
     */
    where: student_open_answersWhereUniqueInput
  }

  /**
   * student_open_answers findUniqueOrThrow
   */
  export type student_open_answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_open_answers to fetch.
     */
    where: student_open_answersWhereUniqueInput
  }

  /**
   * student_open_answers findFirst
   */
  export type student_open_answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_open_answers to fetch.
     */
    where?: student_open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_open_answers to fetch.
     */
    orderBy?: student_open_answersOrderByWithRelationInput | student_open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_open_answers.
     */
    cursor?: student_open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_open_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_open_answers.
     */
    distinct?: Student_open_answersScalarFieldEnum | Student_open_answersScalarFieldEnum[]
  }

  /**
   * student_open_answers findFirstOrThrow
   */
  export type student_open_answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_open_answers to fetch.
     */
    where?: student_open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_open_answers to fetch.
     */
    orderBy?: student_open_answersOrderByWithRelationInput | student_open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_open_answers.
     */
    cursor?: student_open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_open_answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_open_answers.
     */
    distinct?: Student_open_answersScalarFieldEnum | Student_open_answersScalarFieldEnum[]
  }

  /**
   * student_open_answers findMany
   */
  export type student_open_answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * Filter, which student_open_answers to fetch.
     */
    where?: student_open_answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_open_answers to fetch.
     */
    orderBy?: student_open_answersOrderByWithRelationInput | student_open_answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_open_answers.
     */
    cursor?: student_open_answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_open_answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_open_answers.
     */
    skip?: number
    distinct?: Student_open_answersScalarFieldEnum | Student_open_answersScalarFieldEnum[]
  }

  /**
   * student_open_answers create
   */
  export type student_open_answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * The data needed to create a student_open_answers.
     */
    data: XOR<student_open_answersCreateInput, student_open_answersUncheckedCreateInput>
  }

  /**
   * student_open_answers createMany
   */
  export type student_open_answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_open_answers.
     */
    data: student_open_answersCreateManyInput | student_open_answersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_open_answers update
   */
  export type student_open_answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * The data needed to update a student_open_answers.
     */
    data: XOR<student_open_answersUpdateInput, student_open_answersUncheckedUpdateInput>
    /**
     * Choose, which student_open_answers to update.
     */
    where: student_open_answersWhereUniqueInput
  }

  /**
   * student_open_answers updateMany
   */
  export type student_open_answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_open_answers.
     */
    data: XOR<student_open_answersUpdateManyMutationInput, student_open_answersUncheckedUpdateManyInput>
    /**
     * Filter which student_open_answers to update
     */
    where?: student_open_answersWhereInput
  }

  /**
   * student_open_answers upsert
   */
  export type student_open_answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * The filter to search for the student_open_answers to update in case it exists.
     */
    where: student_open_answersWhereUniqueInput
    /**
     * In case the student_open_answers found by the `where` argument doesn't exist, create a new student_open_answers with this data.
     */
    create: XOR<student_open_answersCreateInput, student_open_answersUncheckedCreateInput>
    /**
     * In case the student_open_answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_open_answersUpdateInput, student_open_answersUncheckedUpdateInput>
  }

  /**
   * student_open_answers delete
   */
  export type student_open_answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
    /**
     * Filter which student_open_answers to delete.
     */
    where: student_open_answersWhereUniqueInput
  }

  /**
   * student_open_answers deleteMany
   */
  export type student_open_answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_open_answers to delete
     */
    where?: student_open_answersWhereInput
  }

  /**
   * student_open_answers without action
   */
  export type student_open_answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_open_answers
     */
    select?: student_open_answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_open_answersInclude<ExtArgs> | null
  }


  /**
   * Model students_exams
   */

  export type AggregateStudents_exams = {
    _count: Students_examsCountAggregateOutputType | null
    _min: Students_examsMinAggregateOutputType | null
    _max: Students_examsMaxAggregateOutputType | null
  }

  export type Students_examsMinAggregateOutputType = {
    students_id: Uint8Array | null
    exam_id: Uint8Array | null
  }

  export type Students_examsMaxAggregateOutputType = {
    students_id: Uint8Array | null
    exam_id: Uint8Array | null
  }

  export type Students_examsCountAggregateOutputType = {
    students_id: number
    exam_id: number
    _all: number
  }


  export type Students_examsMinAggregateInputType = {
    students_id?: true
    exam_id?: true
  }

  export type Students_examsMaxAggregateInputType = {
    students_id?: true
    exam_id?: true
  }

  export type Students_examsCountAggregateInputType = {
    students_id?: true
    exam_id?: true
    _all?: true
  }

  export type Students_examsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students_exams to aggregate.
     */
    where?: students_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_exams to fetch.
     */
    orderBy?: students_examsOrderByWithRelationInput | students_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: students_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students_exams
    **/
    _count?: true | Students_examsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Students_examsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Students_examsMaxAggregateInputType
  }

  export type GetStudents_examsAggregateType<T extends Students_examsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents_exams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents_exams[P]>
      : GetScalarType<T[P], AggregateStudents_exams[P]>
  }




  export type students_examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: students_examsWhereInput
    orderBy?: students_examsOrderByWithAggregationInput | students_examsOrderByWithAggregationInput[]
    by: Students_examsScalarFieldEnum[] | Students_examsScalarFieldEnum
    having?: students_examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Students_examsCountAggregateInputType | true
    _min?: Students_examsMinAggregateInputType
    _max?: Students_examsMaxAggregateInputType
  }

  export type Students_examsGroupByOutputType = {
    students_id: Uint8Array
    exam_id: Uint8Array
    _count: Students_examsCountAggregateOutputType | null
    _min: Students_examsMinAggregateOutputType | null
    _max: Students_examsMaxAggregateOutputType | null
  }

  type GetStudents_examsGroupByPayload<T extends students_examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Students_examsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Students_examsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Students_examsGroupByOutputType[P]>
            : GetScalarType<T[P], Students_examsGroupByOutputType[P]>
        }
      >
    >


  export type students_examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    students_id?: boolean
    exam_id?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students_exams"]>



  export type students_examsSelectScalar = {
    students_id?: boolean
    exam_id?: boolean
  }

  export type students_examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    exams?: boolean | examsDefaultArgs<ExtArgs>
  }

  export type $students_examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students_exams"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      exams: Prisma.$examsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      students_id: Uint8Array
      exam_id: Uint8Array
    }, ExtArgs["result"]["students_exams"]>
    composites: {}
  }

  type students_examsGetPayload<S extends boolean | null | undefined | students_examsDefaultArgs> = $Result.GetResult<Prisma.$students_examsPayload, S>

  type students_examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<students_examsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Students_examsCountAggregateInputType | true
    }

  export interface students_examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students_exams'], meta: { name: 'students_exams' } }
    /**
     * Find zero or one Students_exams that matches the filter.
     * @param {students_examsFindUniqueArgs} args - Arguments to find a Students_exams
     * @example
     * // Get one Students_exams
     * const students_exams = await prisma.students_exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends students_examsFindUniqueArgs>(args: SelectSubset<T, students_examsFindUniqueArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Students_exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {students_examsFindUniqueOrThrowArgs} args - Arguments to find a Students_exams
     * @example
     * // Get one Students_exams
     * const students_exams = await prisma.students_exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends students_examsFindUniqueOrThrowArgs>(args: SelectSubset<T, students_examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Students_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_examsFindFirstArgs} args - Arguments to find a Students_exams
     * @example
     * // Get one Students_exams
     * const students_exams = await prisma.students_exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends students_examsFindFirstArgs>(args?: SelectSubset<T, students_examsFindFirstArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Students_exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_examsFindFirstOrThrowArgs} args - Arguments to find a Students_exams
     * @example
     * // Get one Students_exams
     * const students_exams = await prisma.students_exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends students_examsFindFirstOrThrowArgs>(args?: SelectSubset<T, students_examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students_exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students_exams
     * const students_exams = await prisma.students_exams.findMany()
     * 
     * // Get first 10 Students_exams
     * const students_exams = await prisma.students_exams.findMany({ take: 10 })
     * 
     * // Only select the `students_id`
     * const students_examsWithStudents_idOnly = await prisma.students_exams.findMany({ select: { students_id: true } })
     * 
     */
    findMany<T extends students_examsFindManyArgs>(args?: SelectSubset<T, students_examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Students_exams.
     * @param {students_examsCreateArgs} args - Arguments to create a Students_exams.
     * @example
     * // Create one Students_exams
     * const Students_exams = await prisma.students_exams.create({
     *   data: {
     *     // ... data to create a Students_exams
     *   }
     * })
     * 
     */
    create<T extends students_examsCreateArgs>(args: SelectSubset<T, students_examsCreateArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students_exams.
     * @param {students_examsCreateManyArgs} args - Arguments to create many Students_exams.
     * @example
     * // Create many Students_exams
     * const students_exams = await prisma.students_exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends students_examsCreateManyArgs>(args?: SelectSubset<T, students_examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Students_exams.
     * @param {students_examsDeleteArgs} args - Arguments to delete one Students_exams.
     * @example
     * // Delete one Students_exams
     * const Students_exams = await prisma.students_exams.delete({
     *   where: {
     *     // ... filter to delete one Students_exams
     *   }
     * })
     * 
     */
    delete<T extends students_examsDeleteArgs>(args: SelectSubset<T, students_examsDeleteArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Students_exams.
     * @param {students_examsUpdateArgs} args - Arguments to update one Students_exams.
     * @example
     * // Update one Students_exams
     * const students_exams = await prisma.students_exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends students_examsUpdateArgs>(args: SelectSubset<T, students_examsUpdateArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students_exams.
     * @param {students_examsDeleteManyArgs} args - Arguments to filter Students_exams to delete.
     * @example
     * // Delete a few Students_exams
     * const { count } = await prisma.students_exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends students_examsDeleteManyArgs>(args?: SelectSubset<T, students_examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students_exams
     * const students_exams = await prisma.students_exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends students_examsUpdateManyArgs>(args: SelectSubset<T, students_examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Students_exams.
     * @param {students_examsUpsertArgs} args - Arguments to update or create a Students_exams.
     * @example
     * // Update or create a Students_exams
     * const students_exams = await prisma.students_exams.upsert({
     *   create: {
     *     // ... data to create a Students_exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students_exams we want to update
     *   }
     * })
     */
    upsert<T extends students_examsUpsertArgs>(args: SelectSubset<T, students_examsUpsertArgs<ExtArgs>>): Prisma__students_examsClient<$Result.GetResult<Prisma.$students_examsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_examsCountArgs} args - Arguments to filter Students_exams to count.
     * @example
     * // Count the number of Students_exams
     * const count = await prisma.students_exams.count({
     *   where: {
     *     // ... the filter for the Students_exams we want to count
     *   }
     * })
    **/
    count<T extends students_examsCountArgs>(
      args?: Subset<T, students_examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Students_examsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Students_examsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Students_examsAggregateArgs>(args: Subset<T, Students_examsAggregateArgs>): Prisma.PrismaPromise<GetStudents_examsAggregateType<T>>

    /**
     * Group by Students_exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {students_examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends students_examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: students_examsGroupByArgs['orderBy'] }
        : { orderBy?: students_examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, students_examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudents_examsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students_exams model
   */
  readonly fields: students_examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students_exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__students_examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exams<T extends examsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examsDefaultArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students_exams model
   */ 
  interface students_examsFieldRefs {
    readonly students_id: FieldRef<"students_exams", 'Bytes'>
    readonly exam_id: FieldRef<"students_exams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * students_exams findUnique
   */
  export type students_examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * Filter, which students_exams to fetch.
     */
    where: students_examsWhereUniqueInput
  }

  /**
   * students_exams findUniqueOrThrow
   */
  export type students_examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * Filter, which students_exams to fetch.
     */
    where: students_examsWhereUniqueInput
  }

  /**
   * students_exams findFirst
   */
  export type students_examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * Filter, which students_exams to fetch.
     */
    where?: students_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_exams to fetch.
     */
    orderBy?: students_examsOrderByWithRelationInput | students_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students_exams.
     */
    cursor?: students_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students_exams.
     */
    distinct?: Students_examsScalarFieldEnum | Students_examsScalarFieldEnum[]
  }

  /**
   * students_exams findFirstOrThrow
   */
  export type students_examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * Filter, which students_exams to fetch.
     */
    where?: students_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_exams to fetch.
     */
    orderBy?: students_examsOrderByWithRelationInput | students_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students_exams.
     */
    cursor?: students_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students_exams.
     */
    distinct?: Students_examsScalarFieldEnum | Students_examsScalarFieldEnum[]
  }

  /**
   * students_exams findMany
   */
  export type students_examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * Filter, which students_exams to fetch.
     */
    where?: students_examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students_exams to fetch.
     */
    orderBy?: students_examsOrderByWithRelationInput | students_examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students_exams.
     */
    cursor?: students_examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students_exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students_exams.
     */
    skip?: number
    distinct?: Students_examsScalarFieldEnum | Students_examsScalarFieldEnum[]
  }

  /**
   * students_exams create
   */
  export type students_examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * The data needed to create a students_exams.
     */
    data: XOR<students_examsCreateInput, students_examsUncheckedCreateInput>
  }

  /**
   * students_exams createMany
   */
  export type students_examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students_exams.
     */
    data: students_examsCreateManyInput | students_examsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students_exams update
   */
  export type students_examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * The data needed to update a students_exams.
     */
    data: XOR<students_examsUpdateInput, students_examsUncheckedUpdateInput>
    /**
     * Choose, which students_exams to update.
     */
    where: students_examsWhereUniqueInput
  }

  /**
   * students_exams updateMany
   */
  export type students_examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students_exams.
     */
    data: XOR<students_examsUpdateManyMutationInput, students_examsUncheckedUpdateManyInput>
    /**
     * Filter which students_exams to update
     */
    where?: students_examsWhereInput
  }

  /**
   * students_exams upsert
   */
  export type students_examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * The filter to search for the students_exams to update in case it exists.
     */
    where: students_examsWhereUniqueInput
    /**
     * In case the students_exams found by the `where` argument doesn't exist, create a new students_exams with this data.
     */
    create: XOR<students_examsCreateInput, students_examsUncheckedCreateInput>
    /**
     * In case the students_exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<students_examsUpdateInput, students_examsUncheckedUpdateInput>
  }

  /**
   * students_exams delete
   */
  export type students_examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
    /**
     * Filter which students_exams to delete.
     */
    where: students_examsWhereUniqueInput
  }

  /**
   * students_exams deleteMany
   */
  export type students_examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students_exams to delete
     */
    where?: students_examsWhereInput
  }

  /**
   * students_exams without action
   */
  export type students_examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students_exams
     */
    select?: students_examsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: students_examsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AttendancesScalarFieldEnum: {
    id: 'id',
    date_time: 'date_time',
    was_present: 'was_present',
    was_late: 'was_late',
    was_excused: 'was_excused',
    student_id: 'student_id',
    lesson_id: 'lesson_id'
  };

  export type AttendancesScalarFieldEnum = (typeof AttendancesScalarFieldEnum)[keyof typeof AttendancesScalarFieldEnum]


  export const BadgesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category_id: 'category_id'
  };

  export type BadgesScalarFieldEnum = (typeof BadgesScalarFieldEnum)[keyof typeof BadgesScalarFieldEnum]


  export const Badges_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Badges_categoriesScalarFieldEnum = (typeof Badges_categoriesScalarFieldEnum)[keyof typeof Badges_categoriesScalarFieldEnum]


  export const Badges_historyScalarFieldEnum: {
    id: 'id',
    date_awarded: 'date_awarded',
    student_id: 'student_id',
    badge_id: 'badge_id'
  };

  export type Badges_historyScalarFieldEnum = (typeof Badges_historyScalarFieldEnum)[keyof typeof Badges_historyScalarFieldEnum]


  export const ClassesScalarFieldEnum: {
    id: 'id',
    class_name_id: 'class_name_id',
    school_year_id: 'school_year_id',
    teacher_id: 'teacher_id'
  };

  export type ClassesScalarFieldEnum = (typeof ClassesScalarFieldEnum)[keyof typeof ClassesScalarFieldEnum]


  export const Event_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Event_typesScalarFieldEnum = (typeof Event_typesScalarFieldEnum)[keyof typeof Event_typesScalarFieldEnum]


  export const Grades_gradebookScalarFieldEnum: {
    id: 'id',
    description: 'description',
    grade: 'grade',
    weight: 'weight',
    date_given: 'date_given',
    student_id: 'student_id',
    subject_id: 'subject_id',
    teacher_id: 'teacher_id'
  };

  export type Grades_gradebookScalarFieldEnum = (typeof Grades_gradebookScalarFieldEnum)[keyof typeof Grades_gradebookScalarFieldEnum]


  export const HomeworksScalarFieldEnum: {
    id: 'id',
    description: 'description',
    deadline: 'deadline',
    lesson_id: 'lesson_id'
  };

  export type HomeworksScalarFieldEnum = (typeof HomeworksScalarFieldEnum)[keyof typeof HomeworksScalarFieldEnum]


  export const LessonsScalarFieldEnum: {
    id: 'id',
    description: 'description',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    teacher_id: 'teacher_id',
    class_id: 'class_id',
    subject_id: 'subject_id'
  };

  export type LessonsScalarFieldEnum = (typeof LessonsScalarFieldEnum)[keyof typeof LessonsScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    content: 'content',
    date_time: 'date_time',
    was_read: 'was_read',
    sender_id: 'sender_id',
    sender_type_id: 'sender_type_id',
    receiver_id: 'receiver_id',
    receiver_type_id: 'receiver_type_id'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const ParentsScalarFieldEnum: {
    id: 'id',
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token',
    reset_password_expires: 'reset_password_expires'
  };

  export type ParentsScalarFieldEnum = (typeof ParentsScalarFieldEnum)[keyof typeof ParentsScalarFieldEnum]


  export const Problem_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Problem_typesScalarFieldEnum = (typeof Problem_typesScalarFieldEnum)[keyof typeof Problem_typesScalarFieldEnum]


  export const Problems_gradebookScalarFieldEnum: {
    id: 'id',
    description: 'description',
    reported_time: 'reported_time',
    problem_type_id: 'problem_type_id',
    reporter_id: 'reporter_id',
    user_type_id: 'user_type_id',
    status_id: 'status_id'
  };

  export type Problems_gradebookScalarFieldEnum = (typeof Problems_gradebookScalarFieldEnum)[keyof typeof Problems_gradebookScalarFieldEnum]


  export const School_eventsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    description: 'description',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    event_type_id: 'event_type_id'
  };

  export type School_eventsScalarFieldEnum = (typeof School_eventsScalarFieldEnum)[keyof typeof School_eventsScalarFieldEnum]


  export const StatusesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type StatusesScalarFieldEnum = (typeof StatusesScalarFieldEnum)[keyof typeof StatusesScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token',
    reset_password_expires: 'reset_password_expires',
    class_id: 'class_id'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const Students_parentsScalarFieldEnum: {
    student_id: 'student_id',
    parent_id: 'parent_id'
  };

  export type Students_parentsScalarFieldEnum = (typeof Students_parentsScalarFieldEnum)[keyof typeof Students_parentsScalarFieldEnum]


  export const SubjectsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SubjectsScalarFieldEnum = (typeof SubjectsScalarFieldEnum)[keyof typeof SubjectsScalarFieldEnum]


  export const SurveysScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type SurveysScalarFieldEnum = (typeof SurveysScalarFieldEnum)[keyof typeof SurveysScalarFieldEnum]


  export const TeachersScalarFieldEnum: {
    id: 'id',
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token',
    reset_password_expires: 'reset_password_expires'
  };

  export type TeachersScalarFieldEnum = (typeof TeachersScalarFieldEnum)[keyof typeof TeachersScalarFieldEnum]


  export const Teachers_subjectsScalarFieldEnum: {
    teacher_id: 'teacher_id',
    subject_id: 'subject_id'
  };

  export type Teachers_subjectsScalarFieldEnum = (typeof Teachers_subjectsScalarFieldEnum)[keyof typeof Teachers_subjectsScalarFieldEnum]


  export const UpdatesScalarFieldEnum: {
    id: 'id',
    description: 'description',
    version: 'version',
    release_time: 'release_time'
  };

  export type UpdatesScalarFieldEnum = (typeof UpdatesScalarFieldEnum)[keyof typeof UpdatesScalarFieldEnum]


  export const AdministratorsScalarFieldEnum: {
    id: 'id',
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token',
    reset_password_expires: 'reset_password_expires'
  };

  export type AdministratorsScalarFieldEnum = (typeof AdministratorsScalarFieldEnum)[keyof typeof AdministratorsScalarFieldEnum]


  export const User_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type User_typesScalarFieldEnum = (typeof User_typesScalarFieldEnum)[keyof typeof User_typesScalarFieldEnum]


  export const School_yearsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    start_date: 'start_date',
    end_date: 'end_date'
  };

  export type School_yearsScalarFieldEnum = (typeof School_yearsScalarFieldEnum)[keyof typeof School_yearsScalarFieldEnum]


  export const SemestersScalarFieldEnum: {
    id: 'id',
    semester: 'semester',
    start_date: 'start_date',
    end_date: 'end_date',
    school_year_id: 'school_year_id'
  };

  export type SemestersScalarFieldEnum = (typeof SemestersScalarFieldEnum)[keyof typeof SemestersScalarFieldEnum]


  export const Class_namesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Class_namesScalarFieldEnum = (typeof Class_namesScalarFieldEnum)[keyof typeof Class_namesScalarFieldEnum]


  export const ExamsScalarFieldEnum: {
    id: 'id',
    lesson_id: 'lesson_id',
    title: 'title',
    topic: 'topic',
    scope: 'scope',
    start_date_time: 'start_date_time',
    end_date_time: 'end_date_time',
    visibility: 'visibility',
    number_of_questions: 'number_of_questions',
    duration: 'duration',
    teacher_id: 'teacher_id',
    description: 'description',
    number_of_tries: 'number_of_tries',
    multiple_tries: 'multiple_tries',
    time_limit_for_each_question: 'time_limit_for_each_question',
    randomise_questions: 'randomise_questions',
    end_test_after_leaving_window: 'end_test_after_leaving_window',
    block_copying_pasting: 'block_copying_pasting',
    randomise_answers: 'randomise_answers',
    latest_attempt_counts: 'latest_attempt_counts',
    best_attempt_counts: 'best_attempt_counts',
    hide_results: 'hide_results',
    display_points_per_question: 'display_points_per_question',
    show_correct_answers: 'show_correct_answers',
    allow_navigation: 'allow_navigation',
    allow_review: 'allow_review'
  };

  export type ExamsScalarFieldEnum = (typeof ExamsScalarFieldEnum)[keyof typeof ExamsScalarFieldEnum]


  export const Final_gradesScalarFieldEnum: {
    id: 'id',
    grade: 'grade',
    student_id: 'student_id',
    subject_id: 'subject_id',
    teacher_id: 'teacher_id',
    semester_id: 'semester_id'
  };

  export type Final_gradesScalarFieldEnum = (typeof Final_gradesScalarFieldEnum)[keyof typeof Final_gradesScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    survey_id: 'survey_id',
    question_type_id: 'question_type_id'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const Questions_possible_responsesScalarFieldEnum: {
    id: 'id',
    content: 'content',
    question_id: 'question_id'
  };

  export type Questions_possible_responsesScalarFieldEnum = (typeof Questions_possible_responsesScalarFieldEnum)[keyof typeof Questions_possible_responsesScalarFieldEnum]


  export const Questions_responsesScalarFieldEnum: {
    id: 'id',
    content: 'content',
    student_id: 'student_id',
    question_id: 'question_id'
  };

  export type Questions_responsesScalarFieldEnum = (typeof Questions_responsesScalarFieldEnum)[keyof typeof Questions_responsesScalarFieldEnum]


  export const Questions_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Questions_typesScalarFieldEnum = (typeof Questions_typesScalarFieldEnum)[keyof typeof Questions_typesScalarFieldEnum]


  export const Attempt_questionsScalarFieldEnum: {
    id: 'id',
    attempt_id: 'attempt_id',
    open_question_id: 'open_question_id',
    closed_question_id: 'closed_question_id',
    question_type: 'question_type',
    created_at: 'created_at'
  };

  export type Attempt_questionsScalarFieldEnum = (typeof Attempt_questionsScalarFieldEnum)[keyof typeof Attempt_questionsScalarFieldEnum]


  export const AttemptsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    exam_id: 'exam_id',
    attempt_number: 'attempt_number',
    total_score: 'total_score',
    max_score: 'max_score',
    graded: 'graded',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type AttemptsScalarFieldEnum = (typeof AttemptsScalarFieldEnum)[keyof typeof AttemptsScalarFieldEnum]


  export const Classes_examsScalarFieldEnum: {
    class_id: 'class_id',
    exam_id: 'exam_id'
  };

  export type Classes_examsScalarFieldEnum = (typeof Classes_examsScalarFieldEnum)[keyof typeof Classes_examsScalarFieldEnum]


  export const Closed_answersScalarFieldEnum: {
    id: 'id',
    closed_question_id: 'closed_question_id',
    is_correct: 'is_correct',
    description: 'description'
  };

  export type Closed_answersScalarFieldEnum = (typeof Closed_answersScalarFieldEnum)[keyof typeof Closed_answersScalarFieldEnum]


  export const Closed_questionsScalarFieldEnum: {
    id: 'id',
    exam_id: 'exam_id',
    score: 'score',
    is_multiple: 'is_multiple',
    description: 'description'
  };

  export type Closed_questionsScalarFieldEnum = (typeof Closed_questionsScalarFieldEnum)[keyof typeof Closed_questionsScalarFieldEnum]


  export const Files_repositoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    file: 'file',
    exam_id: 'exam_id'
  };

  export type Files_repositoryScalarFieldEnum = (typeof Files_repositoryScalarFieldEnum)[keyof typeof Files_repositoryScalarFieldEnum]


  export const Gradebook_examsScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    scope: 'scope',
    lesson_id: 'lesson_id'
  };

  export type Gradebook_examsScalarFieldEnum = (typeof Gradebook_examsScalarFieldEnum)[keyof typeof Gradebook_examsScalarFieldEnum]


  export const Grades_examsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    attempt_id: 'attempt_id',
    exam_id: 'exam_id',
    description: 'description',
    grade: 'grade',
    date_given: 'date_given'
  };

  export type Grades_examsScalarFieldEnum = (typeof Grades_examsScalarFieldEnum)[keyof typeof Grades_examsScalarFieldEnum]


  export const Grading_scaleScalarFieldEnum: {
    id: 'id',
    min_score: 'min_score',
    max_score: 'max_score',
    grades: 'grades'
  };

  export type Grading_scaleScalarFieldEnum = (typeof Grading_scaleScalarFieldEnum)[keyof typeof Grading_scaleScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    description: 'description',
    notification_date: 'notification_date',
    is_read: 'is_read',
    exam_id: 'exam_id'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const Open_answersScalarFieldEnum: {
    id: 'id',
    open_question_id: 'open_question_id',
    description: 'description'
  };

  export type Open_answersScalarFieldEnum = (typeof Open_answersScalarFieldEnum)[keyof typeof Open_answersScalarFieldEnum]


  export const Open_questionsScalarFieldEnum: {
    id: 'id',
    exam_id: 'exam_id',
    auto_check: 'auto_check',
    description: 'description',
    score: 'score'
  };

  export type Open_questionsScalarFieldEnum = (typeof Open_questionsScalarFieldEnum)[keyof typeof Open_questionsScalarFieldEnum]


  export const Student_closed_answersScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    closed_question_id: 'closed_question_id',
    closed_answer_id: 'closed_answer_id',
    attempt_id: 'attempt_id',
    correctness: 'correctness',
    date_time: 'date_time'
  };

  export type Student_closed_answersScalarFieldEnum = (typeof Student_closed_answersScalarFieldEnum)[keyof typeof Student_closed_answersScalarFieldEnum]


  export const Student_open_answersScalarFieldEnum: {
    id: 'id',
    open_question_id: 'open_question_id',
    score: 'score',
    student_id: 'student_id',
    attempt_id: 'attempt_id',
    date_time: 'date_time',
    description: 'description'
  };

  export type Student_open_answersScalarFieldEnum = (typeof Student_open_answersScalarFieldEnum)[keyof typeof Student_open_answersScalarFieldEnum]


  export const Students_examsScalarFieldEnum: {
    students_id: 'students_id',
    exam_id: 'exam_id'
  };

  export type Students_examsScalarFieldEnum = (typeof Students_examsScalarFieldEnum)[keyof typeof Students_examsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const badgesOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type badgesOrderByRelevanceFieldEnum = (typeof badgesOrderByRelevanceFieldEnum)[keyof typeof badgesOrderByRelevanceFieldEnum]


  export const badges_categoriesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type badges_categoriesOrderByRelevanceFieldEnum = (typeof badges_categoriesOrderByRelevanceFieldEnum)[keyof typeof badges_categoriesOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const event_typesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type event_typesOrderByRelevanceFieldEnum = (typeof event_typesOrderByRelevanceFieldEnum)[keyof typeof event_typesOrderByRelevanceFieldEnum]


  export const grades_gradebookOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type grades_gradebookOrderByRelevanceFieldEnum = (typeof grades_gradebookOrderByRelevanceFieldEnum)[keyof typeof grades_gradebookOrderByRelevanceFieldEnum]


  export const homeworksOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type homeworksOrderByRelevanceFieldEnum = (typeof homeworksOrderByRelevanceFieldEnum)[keyof typeof homeworksOrderByRelevanceFieldEnum]


  export const lessonsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type lessonsOrderByRelevanceFieldEnum = (typeof lessonsOrderByRelevanceFieldEnum)[keyof typeof lessonsOrderByRelevanceFieldEnum]


  export const messagesOrderByRelevanceFieldEnum: {
    subject: 'subject',
    content: 'content'
  };

  export type messagesOrderByRelevanceFieldEnum = (typeof messagesOrderByRelevanceFieldEnum)[keyof typeof messagesOrderByRelevanceFieldEnum]


  export const parentsOrderByRelevanceFieldEnum: {
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token'
  };

  export type parentsOrderByRelevanceFieldEnum = (typeof parentsOrderByRelevanceFieldEnum)[keyof typeof parentsOrderByRelevanceFieldEnum]


  export const problem_typesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type problem_typesOrderByRelevanceFieldEnum = (typeof problem_typesOrderByRelevanceFieldEnum)[keyof typeof problem_typesOrderByRelevanceFieldEnum]


  export const problems_gradebookOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type problems_gradebookOrderByRelevanceFieldEnum = (typeof problems_gradebookOrderByRelevanceFieldEnum)[keyof typeof problems_gradebookOrderByRelevanceFieldEnum]


  export const school_eventsOrderByRelevanceFieldEnum: {
    name: 'name',
    location: 'location',
    description: 'description'
  };

  export type school_eventsOrderByRelevanceFieldEnum = (typeof school_eventsOrderByRelevanceFieldEnum)[keyof typeof school_eventsOrderByRelevanceFieldEnum]


  export const statusesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type statusesOrderByRelevanceFieldEnum = (typeof statusesOrderByRelevanceFieldEnum)[keyof typeof statusesOrderByRelevanceFieldEnum]


  export const studentsOrderByRelevanceFieldEnum: {
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token'
  };

  export type studentsOrderByRelevanceFieldEnum = (typeof studentsOrderByRelevanceFieldEnum)[keyof typeof studentsOrderByRelevanceFieldEnum]


  export const subjectsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type subjectsOrderByRelevanceFieldEnum = (typeof subjectsOrderByRelevanceFieldEnum)[keyof typeof subjectsOrderByRelevanceFieldEnum]


  export const surveysOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type surveysOrderByRelevanceFieldEnum = (typeof surveysOrderByRelevanceFieldEnum)[keyof typeof surveysOrderByRelevanceFieldEnum]


  export const teachersOrderByRelevanceFieldEnum: {
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token'
  };

  export type teachersOrderByRelevanceFieldEnum = (typeof teachersOrderByRelevanceFieldEnum)[keyof typeof teachersOrderByRelevanceFieldEnum]


  export const updatesOrderByRelevanceFieldEnum: {
    description: 'description',
    version: 'version'
  };

  export type updatesOrderByRelevanceFieldEnum = (typeof updatesOrderByRelevanceFieldEnum)[keyof typeof updatesOrderByRelevanceFieldEnum]


  export const administratorsOrderByRelevanceFieldEnum: {
    pesel: 'pesel',
    email: 'email',
    phone_number: 'phone_number',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    reset_password_token: 'reset_password_token'
  };

  export type administratorsOrderByRelevanceFieldEnum = (typeof administratorsOrderByRelevanceFieldEnum)[keyof typeof administratorsOrderByRelevanceFieldEnum]


  export const user_typesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type user_typesOrderByRelevanceFieldEnum = (typeof user_typesOrderByRelevanceFieldEnum)[keyof typeof user_typesOrderByRelevanceFieldEnum]


  export const school_yearsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type school_yearsOrderByRelevanceFieldEnum = (typeof school_yearsOrderByRelevanceFieldEnum)[keyof typeof school_yearsOrderByRelevanceFieldEnum]


  export const class_namesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type class_namesOrderByRelevanceFieldEnum = (typeof class_namesOrderByRelevanceFieldEnum)[keyof typeof class_namesOrderByRelevanceFieldEnum]


  export const examsOrderByRelevanceFieldEnum: {
    title: 'title',
    topic: 'topic',
    scope: 'scope',
    description: 'description'
  };

  export type examsOrderByRelevanceFieldEnum = (typeof examsOrderByRelevanceFieldEnum)[keyof typeof examsOrderByRelevanceFieldEnum]


  export const questionsOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type questionsOrderByRelevanceFieldEnum = (typeof questionsOrderByRelevanceFieldEnum)[keyof typeof questionsOrderByRelevanceFieldEnum]


  export const questions_possible_responsesOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type questions_possible_responsesOrderByRelevanceFieldEnum = (typeof questions_possible_responsesOrderByRelevanceFieldEnum)[keyof typeof questions_possible_responsesOrderByRelevanceFieldEnum]


  export const questions_responsesOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type questions_responsesOrderByRelevanceFieldEnum = (typeof questions_responsesOrderByRelevanceFieldEnum)[keyof typeof questions_responsesOrderByRelevanceFieldEnum]


  export const questions_typesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type questions_typesOrderByRelevanceFieldEnum = (typeof questions_typesOrderByRelevanceFieldEnum)[keyof typeof questions_typesOrderByRelevanceFieldEnum]


  export const closed_answersOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type closed_answersOrderByRelevanceFieldEnum = (typeof closed_answersOrderByRelevanceFieldEnum)[keyof typeof closed_answersOrderByRelevanceFieldEnum]


  export const closed_questionsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type closed_questionsOrderByRelevanceFieldEnum = (typeof closed_questionsOrderByRelevanceFieldEnum)[keyof typeof closed_questionsOrderByRelevanceFieldEnum]


  export const files_repositoryOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description'
  };

  export type files_repositoryOrderByRelevanceFieldEnum = (typeof files_repositoryOrderByRelevanceFieldEnum)[keyof typeof files_repositoryOrderByRelevanceFieldEnum]


  export const gradebook_examsOrderByRelevanceFieldEnum: {
    topic: 'topic',
    scope: 'scope'
  };

  export type gradebook_examsOrderByRelevanceFieldEnum = (typeof gradebook_examsOrderByRelevanceFieldEnum)[keyof typeof gradebook_examsOrderByRelevanceFieldEnum]


  export const grades_examsOrderByRelevanceFieldEnum: {
    description: 'description',
    grade: 'grade'
  };

  export type grades_examsOrderByRelevanceFieldEnum = (typeof grades_examsOrderByRelevanceFieldEnum)[keyof typeof grades_examsOrderByRelevanceFieldEnum]


  export const grading_scaleOrderByRelevanceFieldEnum: {
    grades: 'grades'
  };

  export type grading_scaleOrderByRelevanceFieldEnum = (typeof grading_scaleOrderByRelevanceFieldEnum)[keyof typeof grading_scaleOrderByRelevanceFieldEnum]


  export const notificationsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type notificationsOrderByRelevanceFieldEnum = (typeof notificationsOrderByRelevanceFieldEnum)[keyof typeof notificationsOrderByRelevanceFieldEnum]


  export const open_answersOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type open_answersOrderByRelevanceFieldEnum = (typeof open_answersOrderByRelevanceFieldEnum)[keyof typeof open_answersOrderByRelevanceFieldEnum]


  export const open_questionsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type open_questionsOrderByRelevanceFieldEnum = (typeof open_questionsOrderByRelevanceFieldEnum)[keyof typeof open_questionsOrderByRelevanceFieldEnum]


  export const student_open_answersOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type student_open_answersOrderByRelevanceFieldEnum = (typeof student_open_answersOrderByRelevanceFieldEnum)[keyof typeof student_open_answersOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'attempt_questions_question_type'
   */
  export type Enumattempt_questions_question_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'attempt_questions_question_type'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type attendancesWhereInput = {
    AND?: attendancesWhereInput | attendancesWhereInput[]
    OR?: attendancesWhereInput[]
    NOT?: attendancesWhereInput | attendancesWhereInput[]
    id?: BytesFilter<"attendances"> | Uint8Array
    date_time?: DateTimeFilter<"attendances"> | Date | string
    was_present?: BoolFilter<"attendances"> | boolean
    was_late?: BoolFilter<"attendances"> | boolean
    was_excused?: BoolFilter<"attendances"> | boolean
    student_id?: BytesFilter<"attendances"> | Uint8Array
    lesson_id?: BytesFilter<"attendances"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
  }

  export type attendancesOrderByWithRelationInput = {
    id?: SortOrder
    date_time?: SortOrder
    was_present?: SortOrder
    was_late?: SortOrder
    was_excused?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    students?: studentsOrderByWithRelationInput
    lessons?: lessonsOrderByWithRelationInput
  }

  export type attendancesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    student_id_lesson_id?: attendancesStudent_idLesson_idCompoundUniqueInput
    AND?: attendancesWhereInput | attendancesWhereInput[]
    OR?: attendancesWhereInput[]
    NOT?: attendancesWhereInput | attendancesWhereInput[]
    date_time?: DateTimeFilter<"attendances"> | Date | string
    was_present?: BoolFilter<"attendances"> | boolean
    was_late?: BoolFilter<"attendances"> | boolean
    was_excused?: BoolFilter<"attendances"> | boolean
    student_id?: BytesFilter<"attendances"> | Uint8Array
    lesson_id?: BytesFilter<"attendances"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
  }, "id" | "student_id_lesson_id">

  export type attendancesOrderByWithAggregationInput = {
    id?: SortOrder
    date_time?: SortOrder
    was_present?: SortOrder
    was_late?: SortOrder
    was_excused?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
    _count?: attendancesCountOrderByAggregateInput
    _max?: attendancesMaxOrderByAggregateInput
    _min?: attendancesMinOrderByAggregateInput
  }

  export type attendancesScalarWhereWithAggregatesInput = {
    AND?: attendancesScalarWhereWithAggregatesInput | attendancesScalarWhereWithAggregatesInput[]
    OR?: attendancesScalarWhereWithAggregatesInput[]
    NOT?: attendancesScalarWhereWithAggregatesInput | attendancesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"attendances"> | Uint8Array
    date_time?: DateTimeWithAggregatesFilter<"attendances"> | Date | string
    was_present?: BoolWithAggregatesFilter<"attendances"> | boolean
    was_late?: BoolWithAggregatesFilter<"attendances"> | boolean
    was_excused?: BoolWithAggregatesFilter<"attendances"> | boolean
    student_id?: BytesWithAggregatesFilter<"attendances"> | Uint8Array
    lesson_id?: BytesWithAggregatesFilter<"attendances"> | Uint8Array
  }

  export type badgesWhereInput = {
    AND?: badgesWhereInput | badgesWhereInput[]
    OR?: badgesWhereInput[]
    NOT?: badgesWhereInput | badgesWhereInput[]
    id?: BytesFilter<"badges"> | Uint8Array
    name?: StringFilter<"badges"> | string
    description?: StringFilter<"badges"> | string
    category_id?: BytesFilter<"badges"> | Uint8Array
    badges_categories?: XOR<Badges_categoriesScalarRelationFilter, badges_categoriesWhereInput>
    badges_history?: Badges_historyListRelationFilter
  }

  export type badgesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    badges_categories?: badges_categoriesOrderByWithRelationInput
    badges_history?: badges_historyOrderByRelationAggregateInput
    _relevance?: badgesOrderByRelevanceInput
  }

  export type badgesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: badgesWhereInput | badgesWhereInput[]
    OR?: badgesWhereInput[]
    NOT?: badgesWhereInput | badgesWhereInput[]
    name?: StringFilter<"badges"> | string
    description?: StringFilter<"badges"> | string
    category_id?: BytesFilter<"badges"> | Uint8Array
    badges_categories?: XOR<Badges_categoriesScalarRelationFilter, badges_categoriesWhereInput>
    badges_history?: Badges_historyListRelationFilter
  }, "id">

  export type badgesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
    _count?: badgesCountOrderByAggregateInput
    _max?: badgesMaxOrderByAggregateInput
    _min?: badgesMinOrderByAggregateInput
  }

  export type badgesScalarWhereWithAggregatesInput = {
    AND?: badgesScalarWhereWithAggregatesInput | badgesScalarWhereWithAggregatesInput[]
    OR?: badgesScalarWhereWithAggregatesInput[]
    NOT?: badgesScalarWhereWithAggregatesInput | badgesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"badges"> | Uint8Array
    name?: StringWithAggregatesFilter<"badges"> | string
    description?: StringWithAggregatesFilter<"badges"> | string
    category_id?: BytesWithAggregatesFilter<"badges"> | Uint8Array
  }

  export type badges_categoriesWhereInput = {
    AND?: badges_categoriesWhereInput | badges_categoriesWhereInput[]
    OR?: badges_categoriesWhereInput[]
    NOT?: badges_categoriesWhereInput | badges_categoriesWhereInput[]
    id?: BytesFilter<"badges_categories"> | Uint8Array
    name?: StringFilter<"badges_categories"> | string
    badges?: BadgesListRelationFilter
  }

  export type badges_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    badges?: badgesOrderByRelationAggregateInput
    _relevance?: badges_categoriesOrderByRelevanceInput
  }

  export type badges_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: badges_categoriesWhereInput | badges_categoriesWhereInput[]
    OR?: badges_categoriesWhereInput[]
    NOT?: badges_categoriesWhereInput | badges_categoriesWhereInput[]
    name?: StringFilter<"badges_categories"> | string
    badges?: BadgesListRelationFilter
  }, "id">

  export type badges_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: badges_categoriesCountOrderByAggregateInput
    _max?: badges_categoriesMaxOrderByAggregateInput
    _min?: badges_categoriesMinOrderByAggregateInput
  }

  export type badges_categoriesScalarWhereWithAggregatesInput = {
    AND?: badges_categoriesScalarWhereWithAggregatesInput | badges_categoriesScalarWhereWithAggregatesInput[]
    OR?: badges_categoriesScalarWhereWithAggregatesInput[]
    NOT?: badges_categoriesScalarWhereWithAggregatesInput | badges_categoriesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"badges_categories"> | Uint8Array
    name?: StringWithAggregatesFilter<"badges_categories"> | string
  }

  export type badges_historyWhereInput = {
    AND?: badges_historyWhereInput | badges_historyWhereInput[]
    OR?: badges_historyWhereInput[]
    NOT?: badges_historyWhereInput | badges_historyWhereInput[]
    id?: BytesFilter<"badges_history"> | Uint8Array
    date_awarded?: DateTimeFilter<"badges_history"> | Date | string
    student_id?: BytesFilter<"badges_history"> | Uint8Array
    badge_id?: BytesFilter<"badges_history"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    badges?: XOR<BadgesScalarRelationFilter, badgesWhereInput>
  }

  export type badges_historyOrderByWithRelationInput = {
    id?: SortOrder
    date_awarded?: SortOrder
    student_id?: SortOrder
    badge_id?: SortOrder
    students?: studentsOrderByWithRelationInput
    badges?: badgesOrderByWithRelationInput
  }

  export type badges_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: badges_historyWhereInput | badges_historyWhereInput[]
    OR?: badges_historyWhereInput[]
    NOT?: badges_historyWhereInput | badges_historyWhereInput[]
    date_awarded?: DateTimeFilter<"badges_history"> | Date | string
    student_id?: BytesFilter<"badges_history"> | Uint8Array
    badge_id?: BytesFilter<"badges_history"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    badges?: XOR<BadgesScalarRelationFilter, badgesWhereInput>
  }, "id">

  export type badges_historyOrderByWithAggregationInput = {
    id?: SortOrder
    date_awarded?: SortOrder
    student_id?: SortOrder
    badge_id?: SortOrder
    _count?: badges_historyCountOrderByAggregateInput
    _max?: badges_historyMaxOrderByAggregateInput
    _min?: badges_historyMinOrderByAggregateInput
  }

  export type badges_historyScalarWhereWithAggregatesInput = {
    AND?: badges_historyScalarWhereWithAggregatesInput | badges_historyScalarWhereWithAggregatesInput[]
    OR?: badges_historyScalarWhereWithAggregatesInput[]
    NOT?: badges_historyScalarWhereWithAggregatesInput | badges_historyScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"badges_history"> | Uint8Array
    date_awarded?: DateTimeWithAggregatesFilter<"badges_history"> | Date | string
    student_id?: BytesWithAggregatesFilter<"badges_history"> | Uint8Array
    badge_id?: BytesWithAggregatesFilter<"badges_history"> | Uint8Array
  }

  export type classesWhereInput = {
    AND?: classesWhereInput | classesWhereInput[]
    OR?: classesWhereInput[]
    NOT?: classesWhereInput | classesWhereInput[]
    id?: BytesFilter<"classes"> | Uint8Array
    class_name_id?: BytesFilter<"classes"> | Uint8Array
    school_year_id?: BytesFilter<"classes"> | Uint8Array
    teacher_id?: BytesNullableFilter<"classes"> | Uint8Array | null
    class_names?: XOR<Class_namesScalarRelationFilter, class_namesWhereInput>
    school_years?: XOR<School_yearsScalarRelationFilter, school_yearsWhereInput>
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
    classes_exams?: Classes_examsListRelationFilter
    lessons?: LessonsListRelationFilter
    students?: StudentsListRelationFilter
  }

  export type classesOrderByWithRelationInput = {
    id?: SortOrder
    class_name_id?: SortOrder
    school_year_id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    class_names?: class_namesOrderByWithRelationInput
    school_years?: school_yearsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    classes_exams?: classes_examsOrderByRelationAggregateInput
    lessons?: lessonsOrderByRelationAggregateInput
    students?: studentsOrderByRelationAggregateInput
  }

  export type classesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    class_name_id_school_year_id?: classesClass_name_idSchool_year_idCompoundUniqueInput
    AND?: classesWhereInput | classesWhereInput[]
    OR?: classesWhereInput[]
    NOT?: classesWhereInput | classesWhereInput[]
    class_name_id?: BytesFilter<"classes"> | Uint8Array
    school_year_id?: BytesFilter<"classes"> | Uint8Array
    teacher_id?: BytesNullableFilter<"classes"> | Uint8Array | null
    class_names?: XOR<Class_namesScalarRelationFilter, class_namesWhereInput>
    school_years?: XOR<School_yearsScalarRelationFilter, school_yearsWhereInput>
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
    classes_exams?: Classes_examsListRelationFilter
    lessons?: LessonsListRelationFilter
    students?: StudentsListRelationFilter
  }, "id" | "class_name_id_school_year_id">

  export type classesOrderByWithAggregationInput = {
    id?: SortOrder
    class_name_id?: SortOrder
    school_year_id?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    _count?: classesCountOrderByAggregateInput
    _max?: classesMaxOrderByAggregateInput
    _min?: classesMinOrderByAggregateInput
  }

  export type classesScalarWhereWithAggregatesInput = {
    AND?: classesScalarWhereWithAggregatesInput | classesScalarWhereWithAggregatesInput[]
    OR?: classesScalarWhereWithAggregatesInput[]
    NOT?: classesScalarWhereWithAggregatesInput | classesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"classes"> | Uint8Array
    class_name_id?: BytesWithAggregatesFilter<"classes"> | Uint8Array
    school_year_id?: BytesWithAggregatesFilter<"classes"> | Uint8Array
    teacher_id?: BytesNullableWithAggregatesFilter<"classes"> | Uint8Array | null
  }

  export type event_typesWhereInput = {
    AND?: event_typesWhereInput | event_typesWhereInput[]
    OR?: event_typesWhereInput[]
    NOT?: event_typesWhereInput | event_typesWhereInput[]
    id?: BytesFilter<"event_types"> | Uint8Array
    name?: StringFilter<"event_types"> | string
    school_events?: School_eventsListRelationFilter
  }

  export type event_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    school_events?: school_eventsOrderByRelationAggregateInput
    _relevance?: event_typesOrderByRelevanceInput
  }

  export type event_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: event_typesWhereInput | event_typesWhereInput[]
    OR?: event_typesWhereInput[]
    NOT?: event_typesWhereInput | event_typesWhereInput[]
    school_events?: School_eventsListRelationFilter
  }, "id" | "name">

  export type event_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: event_typesCountOrderByAggregateInput
    _max?: event_typesMaxOrderByAggregateInput
    _min?: event_typesMinOrderByAggregateInput
  }

  export type event_typesScalarWhereWithAggregatesInput = {
    AND?: event_typesScalarWhereWithAggregatesInput | event_typesScalarWhereWithAggregatesInput[]
    OR?: event_typesScalarWhereWithAggregatesInput[]
    NOT?: event_typesScalarWhereWithAggregatesInput | event_typesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"event_types"> | Uint8Array
    name?: StringWithAggregatesFilter<"event_types"> | string
  }

  export type grades_gradebookWhereInput = {
    AND?: grades_gradebookWhereInput | grades_gradebookWhereInput[]
    OR?: grades_gradebookWhereInput[]
    NOT?: grades_gradebookWhereInput | grades_gradebookWhereInput[]
    id?: BytesFilter<"grades_gradebook"> | Uint8Array
    description?: StringFilter<"grades_gradebook"> | string
    grade?: IntFilter<"grades_gradebook"> | number
    weight?: IntFilter<"grades_gradebook"> | number
    date_given?: DateTimeFilter<"grades_gradebook"> | Date | string
    student_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    subject_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    teacher_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }

  export type grades_gradebookOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    weight?: SortOrder
    date_given?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
    students?: studentsOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    _relevance?: grades_gradebookOrderByRelevanceInput
  }

  export type grades_gradebookWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: grades_gradebookWhereInput | grades_gradebookWhereInput[]
    OR?: grades_gradebookWhereInput[]
    NOT?: grades_gradebookWhereInput | grades_gradebookWhereInput[]
    description?: StringFilter<"grades_gradebook"> | string
    grade?: IntFilter<"grades_gradebook"> | number
    weight?: IntFilter<"grades_gradebook"> | number
    date_given?: DateTimeFilter<"grades_gradebook"> | Date | string
    student_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    subject_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    teacher_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }, "id">

  export type grades_gradebookOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    weight?: SortOrder
    date_given?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
    _count?: grades_gradebookCountOrderByAggregateInput
    _avg?: grades_gradebookAvgOrderByAggregateInput
    _max?: grades_gradebookMaxOrderByAggregateInput
    _min?: grades_gradebookMinOrderByAggregateInput
    _sum?: grades_gradebookSumOrderByAggregateInput
  }

  export type grades_gradebookScalarWhereWithAggregatesInput = {
    AND?: grades_gradebookScalarWhereWithAggregatesInput | grades_gradebookScalarWhereWithAggregatesInput[]
    OR?: grades_gradebookScalarWhereWithAggregatesInput[]
    NOT?: grades_gradebookScalarWhereWithAggregatesInput | grades_gradebookScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"grades_gradebook"> | Uint8Array
    description?: StringWithAggregatesFilter<"grades_gradebook"> | string
    grade?: IntWithAggregatesFilter<"grades_gradebook"> | number
    weight?: IntWithAggregatesFilter<"grades_gradebook"> | number
    date_given?: DateTimeWithAggregatesFilter<"grades_gradebook"> | Date | string
    student_id?: BytesWithAggregatesFilter<"grades_gradebook"> | Uint8Array
    subject_id?: BytesWithAggregatesFilter<"grades_gradebook"> | Uint8Array
    teacher_id?: BytesWithAggregatesFilter<"grades_gradebook"> | Uint8Array
  }

  export type homeworksWhereInput = {
    AND?: homeworksWhereInput | homeworksWhereInput[]
    OR?: homeworksWhereInput[]
    NOT?: homeworksWhereInput | homeworksWhereInput[]
    id?: BytesFilter<"homeworks"> | Uint8Array
    description?: StringFilter<"homeworks"> | string
    deadline?: DateTimeFilter<"homeworks"> | Date | string
    lesson_id?: BytesFilter<"homeworks"> | Uint8Array
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
  }

  export type homeworksOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    lesson_id?: SortOrder
    lessons?: lessonsOrderByWithRelationInput
    _relevance?: homeworksOrderByRelevanceInput
  }

  export type homeworksWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    lesson_id?: Uint8Array
    AND?: homeworksWhereInput | homeworksWhereInput[]
    OR?: homeworksWhereInput[]
    NOT?: homeworksWhereInput | homeworksWhereInput[]
    description?: StringFilter<"homeworks"> | string
    deadline?: DateTimeFilter<"homeworks"> | Date | string
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
  }, "id" | "lesson_id">

  export type homeworksOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    lesson_id?: SortOrder
    _count?: homeworksCountOrderByAggregateInput
    _max?: homeworksMaxOrderByAggregateInput
    _min?: homeworksMinOrderByAggregateInput
  }

  export type homeworksScalarWhereWithAggregatesInput = {
    AND?: homeworksScalarWhereWithAggregatesInput | homeworksScalarWhereWithAggregatesInput[]
    OR?: homeworksScalarWhereWithAggregatesInput[]
    NOT?: homeworksScalarWhereWithAggregatesInput | homeworksScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"homeworks"> | Uint8Array
    description?: StringWithAggregatesFilter<"homeworks"> | string
    deadline?: DateTimeWithAggregatesFilter<"homeworks"> | Date | string
    lesson_id?: BytesWithAggregatesFilter<"homeworks"> | Uint8Array
  }

  export type lessonsWhereInput = {
    AND?: lessonsWhereInput | lessonsWhereInput[]
    OR?: lessonsWhereInput[]
    NOT?: lessonsWhereInput | lessonsWhereInput[]
    id?: BytesFilter<"lessons"> | Uint8Array
    description?: StringNullableFilter<"lessons"> | string | null
    date?: DateTimeFilter<"lessons"> | Date | string
    start_time?: DateTimeFilter<"lessons"> | Date | string
    end_time?: DateTimeFilter<"lessons"> | Date | string
    teacher_id?: BytesFilter<"lessons"> | Uint8Array
    class_id?: BytesFilter<"lessons"> | Uint8Array
    subject_id?: BytesFilter<"lessons"> | Uint8Array
    attendances?: AttendancesListRelationFilter
    exams?: ExamsListRelationFilter
    gradebook_exams?: Gradebook_examsListRelationFilter
    homeworks?: XOR<HomeworksNullableScalarRelationFilter, homeworksWhereInput> | null
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }

  export type lessonsOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    attendances?: attendancesOrderByRelationAggregateInput
    exams?: examsOrderByRelationAggregateInput
    gradebook_exams?: gradebook_examsOrderByRelationAggregateInput
    homeworks?: homeworksOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    classes?: classesOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    _relevance?: lessonsOrderByRelevanceInput
  }

  export type lessonsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: lessonsWhereInput | lessonsWhereInput[]
    OR?: lessonsWhereInput[]
    NOT?: lessonsWhereInput | lessonsWhereInput[]
    description?: StringNullableFilter<"lessons"> | string | null
    date?: DateTimeFilter<"lessons"> | Date | string
    start_time?: DateTimeFilter<"lessons"> | Date | string
    end_time?: DateTimeFilter<"lessons"> | Date | string
    teacher_id?: BytesFilter<"lessons"> | Uint8Array
    class_id?: BytesFilter<"lessons"> | Uint8Array
    subject_id?: BytesFilter<"lessons"> | Uint8Array
    attendances?: AttendancesListRelationFilter
    exams?: ExamsListRelationFilter
    gradebook_exams?: Gradebook_examsListRelationFilter
    homeworks?: XOR<HomeworksNullableScalarRelationFilter, homeworksWhereInput> | null
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }, "id">

  export type lessonsOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
    _count?: lessonsCountOrderByAggregateInput
    _max?: lessonsMaxOrderByAggregateInput
    _min?: lessonsMinOrderByAggregateInput
  }

  export type lessonsScalarWhereWithAggregatesInput = {
    AND?: lessonsScalarWhereWithAggregatesInput | lessonsScalarWhereWithAggregatesInput[]
    OR?: lessonsScalarWhereWithAggregatesInput[]
    NOT?: lessonsScalarWhereWithAggregatesInput | lessonsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"lessons"> | Uint8Array
    description?: StringNullableWithAggregatesFilter<"lessons"> | string | null
    date?: DateTimeWithAggregatesFilter<"lessons"> | Date | string
    start_time?: DateTimeWithAggregatesFilter<"lessons"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"lessons"> | Date | string
    teacher_id?: BytesWithAggregatesFilter<"lessons"> | Uint8Array
    class_id?: BytesWithAggregatesFilter<"lessons"> | Uint8Array
    subject_id?: BytesWithAggregatesFilter<"lessons"> | Uint8Array
  }

  export type messagesWhereInput = {
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    id?: BytesFilter<"messages"> | Uint8Array
    subject?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    date_time?: DateTimeFilter<"messages"> | Date | string
    was_read?: BoolFilter<"messages"> | boolean
    sender_id?: BytesFilter<"messages"> | Uint8Array
    sender_type_id?: BytesFilter<"messages"> | Uint8Array
    receiver_id?: BytesFilter<"messages"> | Uint8Array
    receiver_type_id?: BytesFilter<"messages"> | Uint8Array
    user_types_messages_sender_type_idTouser_types?: XOR<User_typesScalarRelationFilter, user_typesWhereInput>
    user_types_messages_receiver_type_idTouser_types?: XOR<User_typesScalarRelationFilter, user_typesWhereInput>
  }

  export type messagesOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    date_time?: SortOrder
    was_read?: SortOrder
    sender_id?: SortOrder
    sender_type_id?: SortOrder
    receiver_id?: SortOrder
    receiver_type_id?: SortOrder
    user_types_messages_sender_type_idTouser_types?: user_typesOrderByWithRelationInput
    user_types_messages_receiver_type_idTouser_types?: user_typesOrderByWithRelationInput
    _relevance?: messagesOrderByRelevanceInput
  }

  export type messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    subject?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    date_time?: DateTimeFilter<"messages"> | Date | string
    was_read?: BoolFilter<"messages"> | boolean
    sender_id?: BytesFilter<"messages"> | Uint8Array
    sender_type_id?: BytesFilter<"messages"> | Uint8Array
    receiver_id?: BytesFilter<"messages"> | Uint8Array
    receiver_type_id?: BytesFilter<"messages"> | Uint8Array
    user_types_messages_sender_type_idTouser_types?: XOR<User_typesScalarRelationFilter, user_typesWhereInput>
    user_types_messages_receiver_type_idTouser_types?: XOR<User_typesScalarRelationFilter, user_typesWhereInput>
  }, "id">

  export type messagesOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    date_time?: SortOrder
    was_read?: SortOrder
    sender_id?: SortOrder
    sender_type_id?: SortOrder
    receiver_id?: SortOrder
    receiver_type_id?: SortOrder
    _count?: messagesCountOrderByAggregateInput
    _max?: messagesMaxOrderByAggregateInput
    _min?: messagesMinOrderByAggregateInput
  }

  export type messagesScalarWhereWithAggregatesInput = {
    AND?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    OR?: messagesScalarWhereWithAggregatesInput[]
    NOT?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"messages"> | Uint8Array
    subject?: StringWithAggregatesFilter<"messages"> | string
    content?: StringWithAggregatesFilter<"messages"> | string
    date_time?: DateTimeWithAggregatesFilter<"messages"> | Date | string
    was_read?: BoolWithAggregatesFilter<"messages"> | boolean
    sender_id?: BytesWithAggregatesFilter<"messages"> | Uint8Array
    sender_type_id?: BytesWithAggregatesFilter<"messages"> | Uint8Array
    receiver_id?: BytesWithAggregatesFilter<"messages"> | Uint8Array
    receiver_type_id?: BytesWithAggregatesFilter<"messages"> | Uint8Array
  }

  export type parentsWhereInput = {
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    id?: BytesFilter<"parents"> | Uint8Array
    pesel?: StringFilter<"parents"> | string
    email?: StringFilter<"parents"> | string
    phone_number?: StringFilter<"parents"> | string
    password?: StringFilter<"parents"> | string
    first_name?: StringFilter<"parents"> | string
    last_name?: StringFilter<"parents"> | string
    reset_password_token?: StringNullableFilter<"parents"> | string | null
    reset_password_expires?: DateTimeNullableFilter<"parents"> | Date | string | null
    students_parents?: Students_parentsListRelationFilter
  }

  export type parentsOrderByWithRelationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    students_parents?: students_parentsOrderByRelationAggregateInput
    _relevance?: parentsOrderByRelevanceInput
  }

  export type parentsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    pesel?: string
    email?: string
    phone_number?: string
    reset_password_token?: string
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    password?: StringFilter<"parents"> | string
    first_name?: StringFilter<"parents"> | string
    last_name?: StringFilter<"parents"> | string
    reset_password_expires?: DateTimeNullableFilter<"parents"> | Date | string | null
    students_parents?: Students_parentsListRelationFilter
  }, "id" | "pesel" | "email" | "phone_number" | "reset_password_token">

  export type parentsOrderByWithAggregationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    _count?: parentsCountOrderByAggregateInput
    _max?: parentsMaxOrderByAggregateInput
    _min?: parentsMinOrderByAggregateInput
  }

  export type parentsScalarWhereWithAggregatesInput = {
    AND?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    OR?: parentsScalarWhereWithAggregatesInput[]
    NOT?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"parents"> | Uint8Array
    pesel?: StringWithAggregatesFilter<"parents"> | string
    email?: StringWithAggregatesFilter<"parents"> | string
    phone_number?: StringWithAggregatesFilter<"parents"> | string
    password?: StringWithAggregatesFilter<"parents"> | string
    first_name?: StringWithAggregatesFilter<"parents"> | string
    last_name?: StringWithAggregatesFilter<"parents"> | string
    reset_password_token?: StringNullableWithAggregatesFilter<"parents"> | string | null
    reset_password_expires?: DateTimeNullableWithAggregatesFilter<"parents"> | Date | string | null
  }

  export type problem_typesWhereInput = {
    AND?: problem_typesWhereInput | problem_typesWhereInput[]
    OR?: problem_typesWhereInput[]
    NOT?: problem_typesWhereInput | problem_typesWhereInput[]
    id?: BytesFilter<"problem_types"> | Uint8Array
    name?: StringFilter<"problem_types"> | string
    problems_gradebook?: Problems_gradebookListRelationFilter
  }

  export type problem_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    problems_gradebook?: problems_gradebookOrderByRelationAggregateInput
    _relevance?: problem_typesOrderByRelevanceInput
  }

  export type problem_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: problem_typesWhereInput | problem_typesWhereInput[]
    OR?: problem_typesWhereInput[]
    NOT?: problem_typesWhereInput | problem_typesWhereInput[]
    problems_gradebook?: Problems_gradebookListRelationFilter
  }, "id" | "name">

  export type problem_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: problem_typesCountOrderByAggregateInput
    _max?: problem_typesMaxOrderByAggregateInput
    _min?: problem_typesMinOrderByAggregateInput
  }

  export type problem_typesScalarWhereWithAggregatesInput = {
    AND?: problem_typesScalarWhereWithAggregatesInput | problem_typesScalarWhereWithAggregatesInput[]
    OR?: problem_typesScalarWhereWithAggregatesInput[]
    NOT?: problem_typesScalarWhereWithAggregatesInput | problem_typesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"problem_types"> | Uint8Array
    name?: StringWithAggregatesFilter<"problem_types"> | string
  }

  export type problems_gradebookWhereInput = {
    AND?: problems_gradebookWhereInput | problems_gradebookWhereInput[]
    OR?: problems_gradebookWhereInput[]
    NOT?: problems_gradebookWhereInput | problems_gradebookWhereInput[]
    id?: BytesFilter<"problems_gradebook"> | Uint8Array
    description?: StringFilter<"problems_gradebook"> | string
    reported_time?: DateTimeFilter<"problems_gradebook"> | Date | string
    problem_type_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    reporter_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    user_type_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    status_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    problem_types?: XOR<Problem_typesScalarRelationFilter, problem_typesWhereInput>
    user_types?: XOR<User_typesScalarRelationFilter, user_typesWhereInput>
    statuses?: XOR<StatusesScalarRelationFilter, statusesWhereInput>
  }

  export type problems_gradebookOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    reported_time?: SortOrder
    problem_type_id?: SortOrder
    reporter_id?: SortOrder
    user_type_id?: SortOrder
    status_id?: SortOrder
    problem_types?: problem_typesOrderByWithRelationInput
    user_types?: user_typesOrderByWithRelationInput
    statuses?: statusesOrderByWithRelationInput
    _relevance?: problems_gradebookOrderByRelevanceInput
  }

  export type problems_gradebookWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: problems_gradebookWhereInput | problems_gradebookWhereInput[]
    OR?: problems_gradebookWhereInput[]
    NOT?: problems_gradebookWhereInput | problems_gradebookWhereInput[]
    description?: StringFilter<"problems_gradebook"> | string
    reported_time?: DateTimeFilter<"problems_gradebook"> | Date | string
    problem_type_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    reporter_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    user_type_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    status_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    problem_types?: XOR<Problem_typesScalarRelationFilter, problem_typesWhereInput>
    user_types?: XOR<User_typesScalarRelationFilter, user_typesWhereInput>
    statuses?: XOR<StatusesScalarRelationFilter, statusesWhereInput>
  }, "id">

  export type problems_gradebookOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    reported_time?: SortOrder
    problem_type_id?: SortOrder
    reporter_id?: SortOrder
    user_type_id?: SortOrder
    status_id?: SortOrder
    _count?: problems_gradebookCountOrderByAggregateInput
    _max?: problems_gradebookMaxOrderByAggregateInput
    _min?: problems_gradebookMinOrderByAggregateInput
  }

  export type problems_gradebookScalarWhereWithAggregatesInput = {
    AND?: problems_gradebookScalarWhereWithAggregatesInput | problems_gradebookScalarWhereWithAggregatesInput[]
    OR?: problems_gradebookScalarWhereWithAggregatesInput[]
    NOT?: problems_gradebookScalarWhereWithAggregatesInput | problems_gradebookScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"problems_gradebook"> | Uint8Array
    description?: StringWithAggregatesFilter<"problems_gradebook"> | string
    reported_time?: DateTimeWithAggregatesFilter<"problems_gradebook"> | Date | string
    problem_type_id?: BytesWithAggregatesFilter<"problems_gradebook"> | Uint8Array
    reporter_id?: BytesWithAggregatesFilter<"problems_gradebook"> | Uint8Array
    user_type_id?: BytesWithAggregatesFilter<"problems_gradebook"> | Uint8Array
    status_id?: BytesWithAggregatesFilter<"problems_gradebook"> | Uint8Array
  }

  export type school_eventsWhereInput = {
    AND?: school_eventsWhereInput | school_eventsWhereInput[]
    OR?: school_eventsWhereInput[]
    NOT?: school_eventsWhereInput | school_eventsWhereInput[]
    id?: BytesFilter<"school_events"> | Uint8Array
    name?: StringFilter<"school_events"> | string
    location?: StringFilter<"school_events"> | string
    description?: StringFilter<"school_events"> | string
    date?: DateTimeFilter<"school_events"> | Date | string
    start_time?: DateTimeFilter<"school_events"> | Date | string
    end_time?: DateTimeFilter<"school_events"> | Date | string
    event_type_id?: BytesFilter<"school_events"> | Uint8Array
    event_types?: XOR<Event_typesScalarRelationFilter, event_typesWhereInput>
  }

  export type school_eventsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    event_type_id?: SortOrder
    event_types?: event_typesOrderByWithRelationInput
    _relevance?: school_eventsOrderByRelevanceInput
  }

  export type school_eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: school_eventsWhereInput | school_eventsWhereInput[]
    OR?: school_eventsWhereInput[]
    NOT?: school_eventsWhereInput | school_eventsWhereInput[]
    name?: StringFilter<"school_events"> | string
    location?: StringFilter<"school_events"> | string
    description?: StringFilter<"school_events"> | string
    date?: DateTimeFilter<"school_events"> | Date | string
    start_time?: DateTimeFilter<"school_events"> | Date | string
    end_time?: DateTimeFilter<"school_events"> | Date | string
    event_type_id?: BytesFilter<"school_events"> | Uint8Array
    event_types?: XOR<Event_typesScalarRelationFilter, event_typesWhereInput>
  }, "id">

  export type school_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    event_type_id?: SortOrder
    _count?: school_eventsCountOrderByAggregateInput
    _max?: school_eventsMaxOrderByAggregateInput
    _min?: school_eventsMinOrderByAggregateInput
  }

  export type school_eventsScalarWhereWithAggregatesInput = {
    AND?: school_eventsScalarWhereWithAggregatesInput | school_eventsScalarWhereWithAggregatesInput[]
    OR?: school_eventsScalarWhereWithAggregatesInput[]
    NOT?: school_eventsScalarWhereWithAggregatesInput | school_eventsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"school_events"> | Uint8Array
    name?: StringWithAggregatesFilter<"school_events"> | string
    location?: StringWithAggregatesFilter<"school_events"> | string
    description?: StringWithAggregatesFilter<"school_events"> | string
    date?: DateTimeWithAggregatesFilter<"school_events"> | Date | string
    start_time?: DateTimeWithAggregatesFilter<"school_events"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"school_events"> | Date | string
    event_type_id?: BytesWithAggregatesFilter<"school_events"> | Uint8Array
  }

  export type statusesWhereInput = {
    AND?: statusesWhereInput | statusesWhereInput[]
    OR?: statusesWhereInput[]
    NOT?: statusesWhereInput | statusesWhereInput[]
    id?: BytesFilter<"statuses"> | Uint8Array
    name?: StringFilter<"statuses"> | string
    problems_gradebook?: Problems_gradebookListRelationFilter
  }

  export type statusesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    problems_gradebook?: problems_gradebookOrderByRelationAggregateInput
    _relevance?: statusesOrderByRelevanceInput
  }

  export type statusesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: statusesWhereInput | statusesWhereInput[]
    OR?: statusesWhereInput[]
    NOT?: statusesWhereInput | statusesWhereInput[]
    problems_gradebook?: Problems_gradebookListRelationFilter
  }, "id" | "name">

  export type statusesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: statusesCountOrderByAggregateInput
    _max?: statusesMaxOrderByAggregateInput
    _min?: statusesMinOrderByAggregateInput
  }

  export type statusesScalarWhereWithAggregatesInput = {
    AND?: statusesScalarWhereWithAggregatesInput | statusesScalarWhereWithAggregatesInput[]
    OR?: statusesScalarWhereWithAggregatesInput[]
    NOT?: statusesScalarWhereWithAggregatesInput | statusesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"statuses"> | Uint8Array
    name?: StringWithAggregatesFilter<"statuses"> | string
  }

  export type studentsWhereInput = {
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    id?: BytesFilter<"students"> | Uint8Array
    pesel?: StringFilter<"students"> | string
    email?: StringFilter<"students"> | string
    phone_number?: StringFilter<"students"> | string
    password?: StringFilter<"students"> | string
    first_name?: StringFilter<"students"> | string
    last_name?: StringFilter<"students"> | string
    reset_password_token?: StringNullableFilter<"students"> | string | null
    reset_password_expires?: DateTimeNullableFilter<"students"> | Date | string | null
    class_id?: BytesNullableFilter<"students"> | Uint8Array | null
    attempts?: AttemptsListRelationFilter
    attendances?: AttendancesListRelationFilter
    badges_history?: Badges_historyListRelationFilter
    final_grades?: Final_gradesListRelationFilter
    grades_exams?: Grades_examsListRelationFilter
    grades_gradebook?: Grades_gradebookListRelationFilter
    notifications?: NotificationsListRelationFilter
    questions_responses?: Questions_responsesListRelationFilter
    student_closed_answers?: Student_closed_answersListRelationFilter
    student_open_answers?: Student_open_answersListRelationFilter
    classes?: XOR<ClassesNullableScalarRelationFilter, classesWhereInput> | null
    students_exams?: Students_examsListRelationFilter
    students_parents?: Students_parentsListRelationFilter
  }

  export type studentsOrderByWithRelationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    class_id?: SortOrderInput | SortOrder
    attempts?: attemptsOrderByRelationAggregateInput
    attendances?: attendancesOrderByRelationAggregateInput
    badges_history?: badges_historyOrderByRelationAggregateInput
    final_grades?: final_gradesOrderByRelationAggregateInput
    grades_exams?: grades_examsOrderByRelationAggregateInput
    grades_gradebook?: grades_gradebookOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    questions_responses?: questions_responsesOrderByRelationAggregateInput
    student_closed_answers?: student_closed_answersOrderByRelationAggregateInput
    student_open_answers?: student_open_answersOrderByRelationAggregateInput
    classes?: classesOrderByWithRelationInput
    students_exams?: students_examsOrderByRelationAggregateInput
    students_parents?: students_parentsOrderByRelationAggregateInput
    _relevance?: studentsOrderByRelevanceInput
  }

  export type studentsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    pesel?: string
    email?: string
    phone_number?: string
    reset_password_token?: string
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    password?: StringFilter<"students"> | string
    first_name?: StringFilter<"students"> | string
    last_name?: StringFilter<"students"> | string
    reset_password_expires?: DateTimeNullableFilter<"students"> | Date | string | null
    class_id?: BytesNullableFilter<"students"> | Uint8Array | null
    attempts?: AttemptsListRelationFilter
    attendances?: AttendancesListRelationFilter
    badges_history?: Badges_historyListRelationFilter
    final_grades?: Final_gradesListRelationFilter
    grades_exams?: Grades_examsListRelationFilter
    grades_gradebook?: Grades_gradebookListRelationFilter
    notifications?: NotificationsListRelationFilter
    questions_responses?: Questions_responsesListRelationFilter
    student_closed_answers?: Student_closed_answersListRelationFilter
    student_open_answers?: Student_open_answersListRelationFilter
    classes?: XOR<ClassesNullableScalarRelationFilter, classesWhereInput> | null
    students_exams?: Students_examsListRelationFilter
    students_parents?: Students_parentsListRelationFilter
  }, "id" | "pesel" | "email" | "phone_number" | "reset_password_token">

  export type studentsOrderByWithAggregationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    class_id?: SortOrderInput | SortOrder
    _count?: studentsCountOrderByAggregateInput
    _max?: studentsMaxOrderByAggregateInput
    _min?: studentsMinOrderByAggregateInput
  }

  export type studentsScalarWhereWithAggregatesInput = {
    AND?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    OR?: studentsScalarWhereWithAggregatesInput[]
    NOT?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"students"> | Uint8Array
    pesel?: StringWithAggregatesFilter<"students"> | string
    email?: StringWithAggregatesFilter<"students"> | string
    phone_number?: StringWithAggregatesFilter<"students"> | string
    password?: StringWithAggregatesFilter<"students"> | string
    first_name?: StringWithAggregatesFilter<"students"> | string
    last_name?: StringWithAggregatesFilter<"students"> | string
    reset_password_token?: StringNullableWithAggregatesFilter<"students"> | string | null
    reset_password_expires?: DateTimeNullableWithAggregatesFilter<"students"> | Date | string | null
    class_id?: BytesNullableWithAggregatesFilter<"students"> | Uint8Array | null
  }

  export type students_parentsWhereInput = {
    AND?: students_parentsWhereInput | students_parentsWhereInput[]
    OR?: students_parentsWhereInput[]
    NOT?: students_parentsWhereInput | students_parentsWhereInput[]
    student_id?: BytesFilter<"students_parents"> | Uint8Array
    parent_id?: BytesFilter<"students_parents"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    parents?: XOR<ParentsScalarRelationFilter, parentsWhereInput>
  }

  export type students_parentsOrderByWithRelationInput = {
    student_id?: SortOrder
    parent_id?: SortOrder
    students?: studentsOrderByWithRelationInput
    parents?: parentsOrderByWithRelationInput
  }

  export type students_parentsWhereUniqueInput = Prisma.AtLeast<{
    student_id_parent_id?: students_parentsStudent_idParent_idCompoundUniqueInput
    AND?: students_parentsWhereInput | students_parentsWhereInput[]
    OR?: students_parentsWhereInput[]
    NOT?: students_parentsWhereInput | students_parentsWhereInput[]
    student_id?: BytesFilter<"students_parents"> | Uint8Array
    parent_id?: BytesFilter<"students_parents"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    parents?: XOR<ParentsScalarRelationFilter, parentsWhereInput>
  }, "student_id_parent_id">

  export type students_parentsOrderByWithAggregationInput = {
    student_id?: SortOrder
    parent_id?: SortOrder
    _count?: students_parentsCountOrderByAggregateInput
    _max?: students_parentsMaxOrderByAggregateInput
    _min?: students_parentsMinOrderByAggregateInput
  }

  export type students_parentsScalarWhereWithAggregatesInput = {
    AND?: students_parentsScalarWhereWithAggregatesInput | students_parentsScalarWhereWithAggregatesInput[]
    OR?: students_parentsScalarWhereWithAggregatesInput[]
    NOT?: students_parentsScalarWhereWithAggregatesInput | students_parentsScalarWhereWithAggregatesInput[]
    student_id?: BytesWithAggregatesFilter<"students_parents"> | Uint8Array
    parent_id?: BytesWithAggregatesFilter<"students_parents"> | Uint8Array
  }

  export type subjectsWhereInput = {
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    id?: BytesFilter<"subjects"> | Uint8Array
    name?: StringFilter<"subjects"> | string
    final_grades?: Final_gradesListRelationFilter
    grades_gradebook?: Grades_gradebookListRelationFilter
    lessons?: LessonsListRelationFilter
    teachers_subjects?: Teachers_subjectsListRelationFilter
  }

  export type subjectsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    final_grades?: final_gradesOrderByRelationAggregateInput
    grades_gradebook?: grades_gradebookOrderByRelationAggregateInput
    lessons?: lessonsOrderByRelationAggregateInput
    teachers_subjects?: teachers_subjectsOrderByRelationAggregateInput
    _relevance?: subjectsOrderByRelevanceInput
  }

  export type subjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    final_grades?: Final_gradesListRelationFilter
    grades_gradebook?: Grades_gradebookListRelationFilter
    lessons?: LessonsListRelationFilter
    teachers_subjects?: Teachers_subjectsListRelationFilter
  }, "id" | "name">

  export type subjectsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: subjectsCountOrderByAggregateInput
    _max?: subjectsMaxOrderByAggregateInput
    _min?: subjectsMinOrderByAggregateInput
  }

  export type subjectsScalarWhereWithAggregatesInput = {
    AND?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    OR?: subjectsScalarWhereWithAggregatesInput[]
    NOT?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"subjects"> | Uint8Array
    name?: StringWithAggregatesFilter<"subjects"> | string
  }

  export type surveysWhereInput = {
    AND?: surveysWhereInput | surveysWhereInput[]
    OR?: surveysWhereInput[]
    NOT?: surveysWhereInput | surveysWhereInput[]
    id?: BytesFilter<"surveys"> | Uint8Array
    name?: StringFilter<"surveys"> | string
    description?: StringFilter<"surveys"> | string
    start_time?: DateTimeFilter<"surveys"> | Date | string
    end_time?: DateTimeFilter<"surveys"> | Date | string
    questions?: QuestionsListRelationFilter
  }

  export type surveysOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    questions?: questionsOrderByRelationAggregateInput
    _relevance?: surveysOrderByRelevanceInput
  }

  export type surveysWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: surveysWhereInput | surveysWhereInput[]
    OR?: surveysWhereInput[]
    NOT?: surveysWhereInput | surveysWhereInput[]
    name?: StringFilter<"surveys"> | string
    description?: StringFilter<"surveys"> | string
    start_time?: DateTimeFilter<"surveys"> | Date | string
    end_time?: DateTimeFilter<"surveys"> | Date | string
    questions?: QuestionsListRelationFilter
  }, "id">

  export type surveysOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    _count?: surveysCountOrderByAggregateInput
    _max?: surveysMaxOrderByAggregateInput
    _min?: surveysMinOrderByAggregateInput
  }

  export type surveysScalarWhereWithAggregatesInput = {
    AND?: surveysScalarWhereWithAggregatesInput | surveysScalarWhereWithAggregatesInput[]
    OR?: surveysScalarWhereWithAggregatesInput[]
    NOT?: surveysScalarWhereWithAggregatesInput | surveysScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"surveys"> | Uint8Array
    name?: StringWithAggregatesFilter<"surveys"> | string
    description?: StringWithAggregatesFilter<"surveys"> | string
    start_time?: DateTimeWithAggregatesFilter<"surveys"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"surveys"> | Date | string
  }

  export type teachersWhereInput = {
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    id?: BytesFilter<"teachers"> | Uint8Array
    pesel?: StringFilter<"teachers"> | string
    email?: StringFilter<"teachers"> | string
    phone_number?: StringFilter<"teachers"> | string
    password?: StringFilter<"teachers"> | string
    first_name?: StringFilter<"teachers"> | string
    last_name?: StringFilter<"teachers"> | string
    reset_password_token?: StringNullableFilter<"teachers"> | string | null
    reset_password_expires?: DateTimeNullableFilter<"teachers"> | Date | string | null
    classes?: ClassesListRelationFilter
    exams?: ExamsListRelationFilter
    final_grades?: Final_gradesListRelationFilter
    grades_gradebook?: Grades_gradebookListRelationFilter
    lessons?: LessonsListRelationFilter
    teachers_subjects?: Teachers_subjectsListRelationFilter
  }

  export type teachersOrderByWithRelationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    classes?: classesOrderByRelationAggregateInput
    exams?: examsOrderByRelationAggregateInput
    final_grades?: final_gradesOrderByRelationAggregateInput
    grades_gradebook?: grades_gradebookOrderByRelationAggregateInput
    lessons?: lessonsOrderByRelationAggregateInput
    teachers_subjects?: teachers_subjectsOrderByRelationAggregateInput
    _relevance?: teachersOrderByRelevanceInput
  }

  export type teachersWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    pesel?: string
    email?: string
    phone_number?: string
    reset_password_token?: string
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    password?: StringFilter<"teachers"> | string
    first_name?: StringFilter<"teachers"> | string
    last_name?: StringFilter<"teachers"> | string
    reset_password_expires?: DateTimeNullableFilter<"teachers"> | Date | string | null
    classes?: ClassesListRelationFilter
    exams?: ExamsListRelationFilter
    final_grades?: Final_gradesListRelationFilter
    grades_gradebook?: Grades_gradebookListRelationFilter
    lessons?: LessonsListRelationFilter
    teachers_subjects?: Teachers_subjectsListRelationFilter
  }, "id" | "pesel" | "email" | "phone_number" | "reset_password_token">

  export type teachersOrderByWithAggregationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    _count?: teachersCountOrderByAggregateInput
    _max?: teachersMaxOrderByAggregateInput
    _min?: teachersMinOrderByAggregateInput
  }

  export type teachersScalarWhereWithAggregatesInput = {
    AND?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    OR?: teachersScalarWhereWithAggregatesInput[]
    NOT?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"teachers"> | Uint8Array
    pesel?: StringWithAggregatesFilter<"teachers"> | string
    email?: StringWithAggregatesFilter<"teachers"> | string
    phone_number?: StringWithAggregatesFilter<"teachers"> | string
    password?: StringWithAggregatesFilter<"teachers"> | string
    first_name?: StringWithAggregatesFilter<"teachers"> | string
    last_name?: StringWithAggregatesFilter<"teachers"> | string
    reset_password_token?: StringNullableWithAggregatesFilter<"teachers"> | string | null
    reset_password_expires?: DateTimeNullableWithAggregatesFilter<"teachers"> | Date | string | null
  }

  export type teachers_subjectsWhereInput = {
    AND?: teachers_subjectsWhereInput | teachers_subjectsWhereInput[]
    OR?: teachers_subjectsWhereInput[]
    NOT?: teachers_subjectsWhereInput | teachers_subjectsWhereInput[]
    teacher_id?: BytesFilter<"teachers_subjects"> | Uint8Array
    subject_id?: BytesFilter<"teachers_subjects"> | Uint8Array
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }

  export type teachers_subjectsOrderByWithRelationInput = {
    teacher_id?: SortOrder
    subject_id?: SortOrder
    teachers?: teachersOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
  }

  export type teachers_subjectsWhereUniqueInput = Prisma.AtLeast<{
    teacher_id_subject_id?: teachers_subjectsTeacher_idSubject_idCompoundUniqueInput
    AND?: teachers_subjectsWhereInput | teachers_subjectsWhereInput[]
    OR?: teachers_subjectsWhereInput[]
    NOT?: teachers_subjectsWhereInput | teachers_subjectsWhereInput[]
    teacher_id?: BytesFilter<"teachers_subjects"> | Uint8Array
    subject_id?: BytesFilter<"teachers_subjects"> | Uint8Array
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
  }, "teacher_id_subject_id">

  export type teachers_subjectsOrderByWithAggregationInput = {
    teacher_id?: SortOrder
    subject_id?: SortOrder
    _count?: teachers_subjectsCountOrderByAggregateInput
    _max?: teachers_subjectsMaxOrderByAggregateInput
    _min?: teachers_subjectsMinOrderByAggregateInput
  }

  export type teachers_subjectsScalarWhereWithAggregatesInput = {
    AND?: teachers_subjectsScalarWhereWithAggregatesInput | teachers_subjectsScalarWhereWithAggregatesInput[]
    OR?: teachers_subjectsScalarWhereWithAggregatesInput[]
    NOT?: teachers_subjectsScalarWhereWithAggregatesInput | teachers_subjectsScalarWhereWithAggregatesInput[]
    teacher_id?: BytesWithAggregatesFilter<"teachers_subjects"> | Uint8Array
    subject_id?: BytesWithAggregatesFilter<"teachers_subjects"> | Uint8Array
  }

  export type updatesWhereInput = {
    AND?: updatesWhereInput | updatesWhereInput[]
    OR?: updatesWhereInput[]
    NOT?: updatesWhereInput | updatesWhereInput[]
    id?: BytesFilter<"updates"> | Uint8Array
    description?: StringFilter<"updates"> | string
    version?: StringFilter<"updates"> | string
    release_time?: DateTimeFilter<"updates"> | Date | string
  }

  export type updatesOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    version?: SortOrder
    release_time?: SortOrder
    _relevance?: updatesOrderByRelevanceInput
  }

  export type updatesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    version?: string
    AND?: updatesWhereInput | updatesWhereInput[]
    OR?: updatesWhereInput[]
    NOT?: updatesWhereInput | updatesWhereInput[]
    description?: StringFilter<"updates"> | string
    release_time?: DateTimeFilter<"updates"> | Date | string
  }, "id" | "version">

  export type updatesOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    version?: SortOrder
    release_time?: SortOrder
    _count?: updatesCountOrderByAggregateInput
    _max?: updatesMaxOrderByAggregateInput
    _min?: updatesMinOrderByAggregateInput
  }

  export type updatesScalarWhereWithAggregatesInput = {
    AND?: updatesScalarWhereWithAggregatesInput | updatesScalarWhereWithAggregatesInput[]
    OR?: updatesScalarWhereWithAggregatesInput[]
    NOT?: updatesScalarWhereWithAggregatesInput | updatesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"updates"> | Uint8Array
    description?: StringWithAggregatesFilter<"updates"> | string
    version?: StringWithAggregatesFilter<"updates"> | string
    release_time?: DateTimeWithAggregatesFilter<"updates"> | Date | string
  }

  export type administratorsWhereInput = {
    AND?: administratorsWhereInput | administratorsWhereInput[]
    OR?: administratorsWhereInput[]
    NOT?: administratorsWhereInput | administratorsWhereInput[]
    id?: BytesFilter<"administrators"> | Uint8Array
    pesel?: StringFilter<"administrators"> | string
    email?: StringFilter<"administrators"> | string
    phone_number?: StringFilter<"administrators"> | string
    password?: StringFilter<"administrators"> | string
    first_name?: StringFilter<"administrators"> | string
    last_name?: StringFilter<"administrators"> | string
    reset_password_token?: StringNullableFilter<"administrators"> | string | null
    reset_password_expires?: DateTimeNullableFilter<"administrators"> | Date | string | null
  }

  export type administratorsOrderByWithRelationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    _relevance?: administratorsOrderByRelevanceInput
  }

  export type administratorsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    pesel?: string
    email?: string
    phone_number?: string
    reset_password_token?: string
    AND?: administratorsWhereInput | administratorsWhereInput[]
    OR?: administratorsWhereInput[]
    NOT?: administratorsWhereInput | administratorsWhereInput[]
    password?: StringFilter<"administrators"> | string
    first_name?: StringFilter<"administrators"> | string
    last_name?: StringFilter<"administrators"> | string
    reset_password_expires?: DateTimeNullableFilter<"administrators"> | Date | string | null
  }, "id" | "pesel" | "email" | "phone_number" | "reset_password_token">

  export type administratorsOrderByWithAggregationInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrderInput | SortOrder
    reset_password_expires?: SortOrderInput | SortOrder
    _count?: administratorsCountOrderByAggregateInput
    _max?: administratorsMaxOrderByAggregateInput
    _min?: administratorsMinOrderByAggregateInput
  }

  export type administratorsScalarWhereWithAggregatesInput = {
    AND?: administratorsScalarWhereWithAggregatesInput | administratorsScalarWhereWithAggregatesInput[]
    OR?: administratorsScalarWhereWithAggregatesInput[]
    NOT?: administratorsScalarWhereWithAggregatesInput | administratorsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"administrators"> | Uint8Array
    pesel?: StringWithAggregatesFilter<"administrators"> | string
    email?: StringWithAggregatesFilter<"administrators"> | string
    phone_number?: StringWithAggregatesFilter<"administrators"> | string
    password?: StringWithAggregatesFilter<"administrators"> | string
    first_name?: StringWithAggregatesFilter<"administrators"> | string
    last_name?: StringWithAggregatesFilter<"administrators"> | string
    reset_password_token?: StringNullableWithAggregatesFilter<"administrators"> | string | null
    reset_password_expires?: DateTimeNullableWithAggregatesFilter<"administrators"> | Date | string | null
  }

  export type user_typesWhereInput = {
    AND?: user_typesWhereInput | user_typesWhereInput[]
    OR?: user_typesWhereInput[]
    NOT?: user_typesWhereInput | user_typesWhereInput[]
    id?: BytesFilter<"user_types"> | Uint8Array
    name?: StringFilter<"user_types"> | string
    messages_messages_sender_type_idTouser_types?: MessagesListRelationFilter
    messages_messages_receiver_type_idTouser_types?: MessagesListRelationFilter
    problems_gradebook?: Problems_gradebookListRelationFilter
  }

  export type user_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    messages_messages_sender_type_idTouser_types?: messagesOrderByRelationAggregateInput
    messages_messages_receiver_type_idTouser_types?: messagesOrderByRelationAggregateInput
    problems_gradebook?: problems_gradebookOrderByRelationAggregateInput
    _relevance?: user_typesOrderByRelevanceInput
  }

  export type user_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: user_typesWhereInput | user_typesWhereInput[]
    OR?: user_typesWhereInput[]
    NOT?: user_typesWhereInput | user_typesWhereInput[]
    messages_messages_sender_type_idTouser_types?: MessagesListRelationFilter
    messages_messages_receiver_type_idTouser_types?: MessagesListRelationFilter
    problems_gradebook?: Problems_gradebookListRelationFilter
  }, "id" | "name">

  export type user_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: user_typesCountOrderByAggregateInput
    _max?: user_typesMaxOrderByAggregateInput
    _min?: user_typesMinOrderByAggregateInput
  }

  export type user_typesScalarWhereWithAggregatesInput = {
    AND?: user_typesScalarWhereWithAggregatesInput | user_typesScalarWhereWithAggregatesInput[]
    OR?: user_typesScalarWhereWithAggregatesInput[]
    NOT?: user_typesScalarWhereWithAggregatesInput | user_typesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"user_types"> | Uint8Array
    name?: StringWithAggregatesFilter<"user_types"> | string
  }

  export type school_yearsWhereInput = {
    AND?: school_yearsWhereInput | school_yearsWhereInput[]
    OR?: school_yearsWhereInput[]
    NOT?: school_yearsWhereInput | school_yearsWhereInput[]
    id?: BytesFilter<"school_years"> | Uint8Array
    name?: StringFilter<"school_years"> | string
    start_date?: DateTimeFilter<"school_years"> | Date | string
    end_date?: DateTimeFilter<"school_years"> | Date | string
    classes?: ClassesListRelationFilter
    semesters?: SemestersListRelationFilter
  }

  export type school_yearsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    classes?: classesOrderByRelationAggregateInput
    semesters?: semestersOrderByRelationAggregateInput
    _relevance?: school_yearsOrderByRelevanceInput
  }

  export type school_yearsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: school_yearsWhereInput | school_yearsWhereInput[]
    OR?: school_yearsWhereInput[]
    NOT?: school_yearsWhereInput | school_yearsWhereInput[]
    start_date?: DateTimeFilter<"school_years"> | Date | string
    end_date?: DateTimeFilter<"school_years"> | Date | string
    classes?: ClassesListRelationFilter
    semesters?: SemestersListRelationFilter
  }, "id" | "name">

  export type school_yearsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    _count?: school_yearsCountOrderByAggregateInput
    _max?: school_yearsMaxOrderByAggregateInput
    _min?: school_yearsMinOrderByAggregateInput
  }

  export type school_yearsScalarWhereWithAggregatesInput = {
    AND?: school_yearsScalarWhereWithAggregatesInput | school_yearsScalarWhereWithAggregatesInput[]
    OR?: school_yearsScalarWhereWithAggregatesInput[]
    NOT?: school_yearsScalarWhereWithAggregatesInput | school_yearsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"school_years"> | Uint8Array
    name?: StringWithAggregatesFilter<"school_years"> | string
    start_date?: DateTimeWithAggregatesFilter<"school_years"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"school_years"> | Date | string
  }

  export type semestersWhereInput = {
    AND?: semestersWhereInput | semestersWhereInput[]
    OR?: semestersWhereInput[]
    NOT?: semestersWhereInput | semestersWhereInput[]
    id?: BytesFilter<"semesters"> | Uint8Array
    semester?: IntFilter<"semesters"> | number
    start_date?: DateTimeFilter<"semesters"> | Date | string
    end_date?: DateTimeFilter<"semesters"> | Date | string
    school_year_id?: BytesFilter<"semesters"> | Uint8Array
    final_grades?: Final_gradesListRelationFilter
    school_years?: XOR<School_yearsScalarRelationFilter, school_yearsWhereInput>
  }

  export type semestersOrderByWithRelationInput = {
    id?: SortOrder
    semester?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    school_year_id?: SortOrder
    final_grades?: final_gradesOrderByRelationAggregateInput
    school_years?: school_yearsOrderByWithRelationInput
  }

  export type semestersWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    semester_school_year_id?: semestersSemesterSchool_year_idCompoundUniqueInput
    AND?: semestersWhereInput | semestersWhereInput[]
    OR?: semestersWhereInput[]
    NOT?: semestersWhereInput | semestersWhereInput[]
    semester?: IntFilter<"semesters"> | number
    start_date?: DateTimeFilter<"semesters"> | Date | string
    end_date?: DateTimeFilter<"semesters"> | Date | string
    school_year_id?: BytesFilter<"semesters"> | Uint8Array
    final_grades?: Final_gradesListRelationFilter
    school_years?: XOR<School_yearsScalarRelationFilter, school_yearsWhereInput>
  }, "id" | "semester_school_year_id">

  export type semestersOrderByWithAggregationInput = {
    id?: SortOrder
    semester?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    school_year_id?: SortOrder
    _count?: semestersCountOrderByAggregateInput
    _avg?: semestersAvgOrderByAggregateInput
    _max?: semestersMaxOrderByAggregateInput
    _min?: semestersMinOrderByAggregateInput
    _sum?: semestersSumOrderByAggregateInput
  }

  export type semestersScalarWhereWithAggregatesInput = {
    AND?: semestersScalarWhereWithAggregatesInput | semestersScalarWhereWithAggregatesInput[]
    OR?: semestersScalarWhereWithAggregatesInput[]
    NOT?: semestersScalarWhereWithAggregatesInput | semestersScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"semesters"> | Uint8Array
    semester?: IntWithAggregatesFilter<"semesters"> | number
    start_date?: DateTimeWithAggregatesFilter<"semesters"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"semesters"> | Date | string
    school_year_id?: BytesWithAggregatesFilter<"semesters"> | Uint8Array
  }

  export type class_namesWhereInput = {
    AND?: class_namesWhereInput | class_namesWhereInput[]
    OR?: class_namesWhereInput[]
    NOT?: class_namesWhereInput | class_namesWhereInput[]
    id?: BytesFilter<"class_names"> | Uint8Array
    name?: StringFilter<"class_names"> | string
    classes?: ClassesListRelationFilter
  }

  export type class_namesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    classes?: classesOrderByRelationAggregateInput
    _relevance?: class_namesOrderByRelevanceInput
  }

  export type class_namesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: class_namesWhereInput | class_namesWhereInput[]
    OR?: class_namesWhereInput[]
    NOT?: class_namesWhereInput | class_namesWhereInput[]
    classes?: ClassesListRelationFilter
  }, "id" | "name">

  export type class_namesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: class_namesCountOrderByAggregateInput
    _max?: class_namesMaxOrderByAggregateInput
    _min?: class_namesMinOrderByAggregateInput
  }

  export type class_namesScalarWhereWithAggregatesInput = {
    AND?: class_namesScalarWhereWithAggregatesInput | class_namesScalarWhereWithAggregatesInput[]
    OR?: class_namesScalarWhereWithAggregatesInput[]
    NOT?: class_namesScalarWhereWithAggregatesInput | class_namesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"class_names"> | Uint8Array
    name?: StringWithAggregatesFilter<"class_names"> | string
  }

  export type examsWhereInput = {
    AND?: examsWhereInput | examsWhereInput[]
    OR?: examsWhereInput[]
    NOT?: examsWhereInput | examsWhereInput[]
    id?: BytesFilter<"exams"> | Uint8Array
    lesson_id?: BytesFilter<"exams"> | Uint8Array
    title?: StringNullableFilter<"exams"> | string | null
    topic?: StringNullableFilter<"exams"> | string | null
    scope?: StringNullableFilter<"exams"> | string | null
    start_date_time?: DateTimeFilter<"exams"> | Date | string
    end_date_time?: DateTimeFilter<"exams"> | Date | string
    visibility?: BoolFilter<"exams"> | boolean
    number_of_questions?: IntNullableFilter<"exams"> | number | null
    duration?: IntFilter<"exams"> | number
    teacher_id?: BytesFilter<"exams"> | Uint8Array
    description?: StringNullableFilter<"exams"> | string | null
    number_of_tries?: IntNullableFilter<"exams"> | number | null
    multiple_tries?: BoolFilter<"exams"> | boolean
    time_limit_for_each_question?: BoolFilter<"exams"> | boolean
    randomise_questions?: BoolFilter<"exams"> | boolean
    end_test_after_leaving_window?: BoolFilter<"exams"> | boolean
    block_copying_pasting?: BoolFilter<"exams"> | boolean
    randomise_answers?: BoolFilter<"exams"> | boolean
    latest_attempt_counts?: BoolFilter<"exams"> | boolean
    best_attempt_counts?: BoolFilter<"exams"> | boolean
    hide_results?: BoolFilter<"exams"> | boolean
    display_points_per_question?: BoolFilter<"exams"> | boolean
    show_correct_answers?: BoolFilter<"exams"> | boolean
    allow_navigation?: BoolFilter<"exams"> | boolean
    allow_review?: BoolFilter<"exams"> | boolean
    attempts?: AttemptsListRelationFilter
    classes_exams?: Classes_examsListRelationFilter
    closed_questions?: Closed_questionsListRelationFilter
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    files_repository?: Files_repositoryListRelationFilter
    grades_exams?: Grades_examsListRelationFilter
    notifications?: NotificationsListRelationFilter
    open_questions?: Open_questionsListRelationFilter
    students_exams?: Students_examsListRelationFilter
  }

  export type examsOrderByWithRelationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    title?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    start_date_time?: SortOrder
    end_date_time?: SortOrder
    visibility?: SortOrder
    number_of_questions?: SortOrderInput | SortOrder
    duration?: SortOrder
    teacher_id?: SortOrder
    description?: SortOrderInput | SortOrder
    number_of_tries?: SortOrderInput | SortOrder
    multiple_tries?: SortOrder
    time_limit_for_each_question?: SortOrder
    randomise_questions?: SortOrder
    end_test_after_leaving_window?: SortOrder
    block_copying_pasting?: SortOrder
    randomise_answers?: SortOrder
    latest_attempt_counts?: SortOrder
    best_attempt_counts?: SortOrder
    hide_results?: SortOrder
    display_points_per_question?: SortOrder
    show_correct_answers?: SortOrder
    allow_navigation?: SortOrder
    allow_review?: SortOrder
    attempts?: attemptsOrderByRelationAggregateInput
    classes_exams?: classes_examsOrderByRelationAggregateInput
    closed_questions?: closed_questionsOrderByRelationAggregateInput
    lessons?: lessonsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    files_repository?: files_repositoryOrderByRelationAggregateInput
    grades_exams?: grades_examsOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    open_questions?: open_questionsOrderByRelationAggregateInput
    students_exams?: students_examsOrderByRelationAggregateInput
    _relevance?: examsOrderByRelevanceInput
  }

  export type examsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: examsWhereInput | examsWhereInput[]
    OR?: examsWhereInput[]
    NOT?: examsWhereInput | examsWhereInput[]
    lesson_id?: BytesFilter<"exams"> | Uint8Array
    title?: StringNullableFilter<"exams"> | string | null
    topic?: StringNullableFilter<"exams"> | string | null
    scope?: StringNullableFilter<"exams"> | string | null
    start_date_time?: DateTimeFilter<"exams"> | Date | string
    end_date_time?: DateTimeFilter<"exams"> | Date | string
    visibility?: BoolFilter<"exams"> | boolean
    number_of_questions?: IntNullableFilter<"exams"> | number | null
    duration?: IntFilter<"exams"> | number
    teacher_id?: BytesFilter<"exams"> | Uint8Array
    description?: StringNullableFilter<"exams"> | string | null
    number_of_tries?: IntNullableFilter<"exams"> | number | null
    multiple_tries?: BoolFilter<"exams"> | boolean
    time_limit_for_each_question?: BoolFilter<"exams"> | boolean
    randomise_questions?: BoolFilter<"exams"> | boolean
    end_test_after_leaving_window?: BoolFilter<"exams"> | boolean
    block_copying_pasting?: BoolFilter<"exams"> | boolean
    randomise_answers?: BoolFilter<"exams"> | boolean
    latest_attempt_counts?: BoolFilter<"exams"> | boolean
    best_attempt_counts?: BoolFilter<"exams"> | boolean
    hide_results?: BoolFilter<"exams"> | boolean
    display_points_per_question?: BoolFilter<"exams"> | boolean
    show_correct_answers?: BoolFilter<"exams"> | boolean
    allow_navigation?: BoolFilter<"exams"> | boolean
    allow_review?: BoolFilter<"exams"> | boolean
    attempts?: AttemptsListRelationFilter
    classes_exams?: Classes_examsListRelationFilter
    closed_questions?: Closed_questionsListRelationFilter
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    files_repository?: Files_repositoryListRelationFilter
    grades_exams?: Grades_examsListRelationFilter
    notifications?: NotificationsListRelationFilter
    open_questions?: Open_questionsListRelationFilter
    students_exams?: Students_examsListRelationFilter
  }, "id">

  export type examsOrderByWithAggregationInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    title?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    start_date_time?: SortOrder
    end_date_time?: SortOrder
    visibility?: SortOrder
    number_of_questions?: SortOrderInput | SortOrder
    duration?: SortOrder
    teacher_id?: SortOrder
    description?: SortOrderInput | SortOrder
    number_of_tries?: SortOrderInput | SortOrder
    multiple_tries?: SortOrder
    time_limit_for_each_question?: SortOrder
    randomise_questions?: SortOrder
    end_test_after_leaving_window?: SortOrder
    block_copying_pasting?: SortOrder
    randomise_answers?: SortOrder
    latest_attempt_counts?: SortOrder
    best_attempt_counts?: SortOrder
    hide_results?: SortOrder
    display_points_per_question?: SortOrder
    show_correct_answers?: SortOrder
    allow_navigation?: SortOrder
    allow_review?: SortOrder
    _count?: examsCountOrderByAggregateInput
    _avg?: examsAvgOrderByAggregateInput
    _max?: examsMaxOrderByAggregateInput
    _min?: examsMinOrderByAggregateInput
    _sum?: examsSumOrderByAggregateInput
  }

  export type examsScalarWhereWithAggregatesInput = {
    AND?: examsScalarWhereWithAggregatesInput | examsScalarWhereWithAggregatesInput[]
    OR?: examsScalarWhereWithAggregatesInput[]
    NOT?: examsScalarWhereWithAggregatesInput | examsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"exams"> | Uint8Array
    lesson_id?: BytesWithAggregatesFilter<"exams"> | Uint8Array
    title?: StringNullableWithAggregatesFilter<"exams"> | string | null
    topic?: StringNullableWithAggregatesFilter<"exams"> | string | null
    scope?: StringNullableWithAggregatesFilter<"exams"> | string | null
    start_date_time?: DateTimeWithAggregatesFilter<"exams"> | Date | string
    end_date_time?: DateTimeWithAggregatesFilter<"exams"> | Date | string
    visibility?: BoolWithAggregatesFilter<"exams"> | boolean
    number_of_questions?: IntNullableWithAggregatesFilter<"exams"> | number | null
    duration?: IntWithAggregatesFilter<"exams"> | number
    teacher_id?: BytesWithAggregatesFilter<"exams"> | Uint8Array
    description?: StringNullableWithAggregatesFilter<"exams"> | string | null
    number_of_tries?: IntNullableWithAggregatesFilter<"exams"> | number | null
    multiple_tries?: BoolWithAggregatesFilter<"exams"> | boolean
    time_limit_for_each_question?: BoolWithAggregatesFilter<"exams"> | boolean
    randomise_questions?: BoolWithAggregatesFilter<"exams"> | boolean
    end_test_after_leaving_window?: BoolWithAggregatesFilter<"exams"> | boolean
    block_copying_pasting?: BoolWithAggregatesFilter<"exams"> | boolean
    randomise_answers?: BoolWithAggregatesFilter<"exams"> | boolean
    latest_attempt_counts?: BoolWithAggregatesFilter<"exams"> | boolean
    best_attempt_counts?: BoolWithAggregatesFilter<"exams"> | boolean
    hide_results?: BoolWithAggregatesFilter<"exams"> | boolean
    display_points_per_question?: BoolWithAggregatesFilter<"exams"> | boolean
    show_correct_answers?: BoolWithAggregatesFilter<"exams"> | boolean
    allow_navigation?: BoolWithAggregatesFilter<"exams"> | boolean
    allow_review?: BoolWithAggregatesFilter<"exams"> | boolean
  }

  export type final_gradesWhereInput = {
    AND?: final_gradesWhereInput | final_gradesWhereInput[]
    OR?: final_gradesWhereInput[]
    NOT?: final_gradesWhereInput | final_gradesWhereInput[]
    id?: BytesFilter<"final_grades"> | Uint8Array
    grade?: IntFilter<"final_grades"> | number
    student_id?: BytesFilter<"final_grades"> | Uint8Array
    subject_id?: BytesFilter<"final_grades"> | Uint8Array
    teacher_id?: BytesFilter<"final_grades"> | Uint8Array
    semester_id?: BytesFilter<"final_grades"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    semesters?: XOR<SemestersScalarRelationFilter, semestersWhereInput>
  }

  export type final_gradesOrderByWithRelationInput = {
    id?: SortOrder
    grade?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
    semester_id?: SortOrder
    students?: studentsOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    semesters?: semestersOrderByWithRelationInput
  }

  export type final_gradesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: final_gradesWhereInput | final_gradesWhereInput[]
    OR?: final_gradesWhereInput[]
    NOT?: final_gradesWhereInput | final_gradesWhereInput[]
    grade?: IntFilter<"final_grades"> | number
    student_id?: BytesFilter<"final_grades"> | Uint8Array
    subject_id?: BytesFilter<"final_grades"> | Uint8Array
    teacher_id?: BytesFilter<"final_grades"> | Uint8Array
    semester_id?: BytesFilter<"final_grades"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
    semesters?: XOR<SemestersScalarRelationFilter, semestersWhereInput>
  }, "id">

  export type final_gradesOrderByWithAggregationInput = {
    id?: SortOrder
    grade?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
    semester_id?: SortOrder
    _count?: final_gradesCountOrderByAggregateInput
    _avg?: final_gradesAvgOrderByAggregateInput
    _max?: final_gradesMaxOrderByAggregateInput
    _min?: final_gradesMinOrderByAggregateInput
    _sum?: final_gradesSumOrderByAggregateInput
  }

  export type final_gradesScalarWhereWithAggregatesInput = {
    AND?: final_gradesScalarWhereWithAggregatesInput | final_gradesScalarWhereWithAggregatesInput[]
    OR?: final_gradesScalarWhereWithAggregatesInput[]
    NOT?: final_gradesScalarWhereWithAggregatesInput | final_gradesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"final_grades"> | Uint8Array
    grade?: IntWithAggregatesFilter<"final_grades"> | number
    student_id?: BytesWithAggregatesFilter<"final_grades"> | Uint8Array
    subject_id?: BytesWithAggregatesFilter<"final_grades"> | Uint8Array
    teacher_id?: BytesWithAggregatesFilter<"final_grades"> | Uint8Array
    semester_id?: BytesWithAggregatesFilter<"final_grades"> | Uint8Array
  }

  export type questionsWhereInput = {
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    id?: BytesFilter<"questions"> | Uint8Array
    content?: StringFilter<"questions"> | string
    survey_id?: BytesFilter<"questions"> | Uint8Array
    question_type_id?: BytesFilter<"questions"> | Uint8Array
    surveys?: XOR<SurveysScalarRelationFilter, surveysWhereInput>
    questions_types?: XOR<Questions_typesScalarRelationFilter, questions_typesWhereInput>
    questions_possible_responses?: Questions_possible_responsesListRelationFilter
    questions_responses?: Questions_responsesListRelationFilter
  }

  export type questionsOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    survey_id?: SortOrder
    question_type_id?: SortOrder
    surveys?: surveysOrderByWithRelationInput
    questions_types?: questions_typesOrderByWithRelationInput
    questions_possible_responses?: questions_possible_responsesOrderByRelationAggregateInput
    questions_responses?: questions_responsesOrderByRelationAggregateInput
    _relevance?: questionsOrderByRelevanceInput
  }

  export type questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    content?: StringFilter<"questions"> | string
    survey_id?: BytesFilter<"questions"> | Uint8Array
    question_type_id?: BytesFilter<"questions"> | Uint8Array
    surveys?: XOR<SurveysScalarRelationFilter, surveysWhereInput>
    questions_types?: XOR<Questions_typesScalarRelationFilter, questions_typesWhereInput>
    questions_possible_responses?: Questions_possible_responsesListRelationFilter
    questions_responses?: Questions_responsesListRelationFilter
  }, "id">

  export type questionsOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    survey_id?: SortOrder
    question_type_id?: SortOrder
    _count?: questionsCountOrderByAggregateInput
    _max?: questionsMaxOrderByAggregateInput
    _min?: questionsMinOrderByAggregateInput
  }

  export type questionsScalarWhereWithAggregatesInput = {
    AND?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    OR?: questionsScalarWhereWithAggregatesInput[]
    NOT?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"questions"> | Uint8Array
    content?: StringWithAggregatesFilter<"questions"> | string
    survey_id?: BytesWithAggregatesFilter<"questions"> | Uint8Array
    question_type_id?: BytesWithAggregatesFilter<"questions"> | Uint8Array
  }

  export type questions_possible_responsesWhereInput = {
    AND?: questions_possible_responsesWhereInput | questions_possible_responsesWhereInput[]
    OR?: questions_possible_responsesWhereInput[]
    NOT?: questions_possible_responsesWhereInput | questions_possible_responsesWhereInput[]
    id?: BytesFilter<"questions_possible_responses"> | Uint8Array
    content?: StringFilter<"questions_possible_responses"> | string
    question_id?: BytesFilter<"questions_possible_responses"> | Uint8Array
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
  }

  export type questions_possible_responsesOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    question_id?: SortOrder
    questions?: questionsOrderByWithRelationInput
    _relevance?: questions_possible_responsesOrderByRelevanceInput
  }

  export type questions_possible_responsesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: questions_possible_responsesWhereInput | questions_possible_responsesWhereInput[]
    OR?: questions_possible_responsesWhereInput[]
    NOT?: questions_possible_responsesWhereInput | questions_possible_responsesWhereInput[]
    content?: StringFilter<"questions_possible_responses"> | string
    question_id?: BytesFilter<"questions_possible_responses"> | Uint8Array
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
  }, "id">

  export type questions_possible_responsesOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    question_id?: SortOrder
    _count?: questions_possible_responsesCountOrderByAggregateInput
    _max?: questions_possible_responsesMaxOrderByAggregateInput
    _min?: questions_possible_responsesMinOrderByAggregateInput
  }

  export type questions_possible_responsesScalarWhereWithAggregatesInput = {
    AND?: questions_possible_responsesScalarWhereWithAggregatesInput | questions_possible_responsesScalarWhereWithAggregatesInput[]
    OR?: questions_possible_responsesScalarWhereWithAggregatesInput[]
    NOT?: questions_possible_responsesScalarWhereWithAggregatesInput | questions_possible_responsesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"questions_possible_responses"> | Uint8Array
    content?: StringWithAggregatesFilter<"questions_possible_responses"> | string
    question_id?: BytesWithAggregatesFilter<"questions_possible_responses"> | Uint8Array
  }

  export type questions_responsesWhereInput = {
    AND?: questions_responsesWhereInput | questions_responsesWhereInput[]
    OR?: questions_responsesWhereInput[]
    NOT?: questions_responsesWhereInput | questions_responsesWhereInput[]
    id?: BytesFilter<"questions_responses"> | Uint8Array
    content?: StringFilter<"questions_responses"> | string
    student_id?: BytesFilter<"questions_responses"> | Uint8Array
    question_id?: BytesFilter<"questions_responses"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
  }

  export type questions_responsesOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    student_id?: SortOrder
    question_id?: SortOrder
    students?: studentsOrderByWithRelationInput
    questions?: questionsOrderByWithRelationInput
    _relevance?: questions_responsesOrderByRelevanceInput
  }

  export type questions_responsesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    student_id_question_id?: questions_responsesStudent_idQuestion_idCompoundUniqueInput
    AND?: questions_responsesWhereInput | questions_responsesWhereInput[]
    OR?: questions_responsesWhereInput[]
    NOT?: questions_responsesWhereInput | questions_responsesWhereInput[]
    content?: StringFilter<"questions_responses"> | string
    student_id?: BytesFilter<"questions_responses"> | Uint8Array
    question_id?: BytesFilter<"questions_responses"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
  }, "id" | "student_id_question_id">

  export type questions_responsesOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    student_id?: SortOrder
    question_id?: SortOrder
    _count?: questions_responsesCountOrderByAggregateInput
    _max?: questions_responsesMaxOrderByAggregateInput
    _min?: questions_responsesMinOrderByAggregateInput
  }

  export type questions_responsesScalarWhereWithAggregatesInput = {
    AND?: questions_responsesScalarWhereWithAggregatesInput | questions_responsesScalarWhereWithAggregatesInput[]
    OR?: questions_responsesScalarWhereWithAggregatesInput[]
    NOT?: questions_responsesScalarWhereWithAggregatesInput | questions_responsesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"questions_responses"> | Uint8Array
    content?: StringWithAggregatesFilter<"questions_responses"> | string
    student_id?: BytesWithAggregatesFilter<"questions_responses"> | Uint8Array
    question_id?: BytesWithAggregatesFilter<"questions_responses"> | Uint8Array
  }

  export type questions_typesWhereInput = {
    AND?: questions_typesWhereInput | questions_typesWhereInput[]
    OR?: questions_typesWhereInput[]
    NOT?: questions_typesWhereInput | questions_typesWhereInput[]
    id?: BytesFilter<"questions_types"> | Uint8Array
    name?: StringFilter<"questions_types"> | string
    questions?: QuestionsListRelationFilter
  }

  export type questions_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    questions?: questionsOrderByRelationAggregateInput
    _relevance?: questions_typesOrderByRelevanceInput
  }

  export type questions_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: questions_typesWhereInput | questions_typesWhereInput[]
    OR?: questions_typesWhereInput[]
    NOT?: questions_typesWhereInput | questions_typesWhereInput[]
    questions?: QuestionsListRelationFilter
  }, "id" | "name">

  export type questions_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: questions_typesCountOrderByAggregateInput
    _max?: questions_typesMaxOrderByAggregateInput
    _min?: questions_typesMinOrderByAggregateInput
  }

  export type questions_typesScalarWhereWithAggregatesInput = {
    AND?: questions_typesScalarWhereWithAggregatesInput | questions_typesScalarWhereWithAggregatesInput[]
    OR?: questions_typesScalarWhereWithAggregatesInput[]
    NOT?: questions_typesScalarWhereWithAggregatesInput | questions_typesScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"questions_types"> | Uint8Array
    name?: StringWithAggregatesFilter<"questions_types"> | string
  }

  export type attempt_questionsWhereInput = {
    AND?: attempt_questionsWhereInput | attempt_questionsWhereInput[]
    OR?: attempt_questionsWhereInput[]
    NOT?: attempt_questionsWhereInput | attempt_questionsWhereInput[]
    id?: BytesFilter<"attempt_questions"> | Uint8Array
    attempt_id?: BytesFilter<"attempt_questions"> | Uint8Array
    open_question_id?: BytesNullableFilter<"attempt_questions"> | Uint8Array | null
    closed_question_id?: BytesNullableFilter<"attempt_questions"> | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFilter<"attempt_questions"> | $Enums.attempt_questions_question_type
    created_at?: DateTimeNullableFilter<"attempt_questions"> | Date | string | null
    attempts?: XOR<AttemptsScalarRelationFilter, attemptsWhereInput>
    open_questions?: XOR<Open_questionsNullableScalarRelationFilter, open_questionsWhereInput> | null
    closed_questions?: XOR<Closed_questionsNullableScalarRelationFilter, closed_questionsWhereInput> | null
  }

  export type attempt_questionsOrderByWithRelationInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    open_question_id?: SortOrderInput | SortOrder
    closed_question_id?: SortOrderInput | SortOrder
    question_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    attempts?: attemptsOrderByWithRelationInput
    open_questions?: open_questionsOrderByWithRelationInput
    closed_questions?: closed_questionsOrderByWithRelationInput
  }

  export type attempt_questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: attempt_questionsWhereInput | attempt_questionsWhereInput[]
    OR?: attempt_questionsWhereInput[]
    NOT?: attempt_questionsWhereInput | attempt_questionsWhereInput[]
    attempt_id?: BytesFilter<"attempt_questions"> | Uint8Array
    open_question_id?: BytesNullableFilter<"attempt_questions"> | Uint8Array | null
    closed_question_id?: BytesNullableFilter<"attempt_questions"> | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFilter<"attempt_questions"> | $Enums.attempt_questions_question_type
    created_at?: DateTimeNullableFilter<"attempt_questions"> | Date | string | null
    attempts?: XOR<AttemptsScalarRelationFilter, attemptsWhereInput>
    open_questions?: XOR<Open_questionsNullableScalarRelationFilter, open_questionsWhereInput> | null
    closed_questions?: XOR<Closed_questionsNullableScalarRelationFilter, closed_questionsWhereInput> | null
  }, "id">

  export type attempt_questionsOrderByWithAggregationInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    open_question_id?: SortOrderInput | SortOrder
    closed_question_id?: SortOrderInput | SortOrder
    question_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: attempt_questionsCountOrderByAggregateInput
    _max?: attempt_questionsMaxOrderByAggregateInput
    _min?: attempt_questionsMinOrderByAggregateInput
  }

  export type attempt_questionsScalarWhereWithAggregatesInput = {
    AND?: attempt_questionsScalarWhereWithAggregatesInput | attempt_questionsScalarWhereWithAggregatesInput[]
    OR?: attempt_questionsScalarWhereWithAggregatesInput[]
    NOT?: attempt_questionsScalarWhereWithAggregatesInput | attempt_questionsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"attempt_questions"> | Uint8Array
    attempt_id?: BytesWithAggregatesFilter<"attempt_questions"> | Uint8Array
    open_question_id?: BytesNullableWithAggregatesFilter<"attempt_questions"> | Uint8Array | null
    closed_question_id?: BytesNullableWithAggregatesFilter<"attempt_questions"> | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeWithAggregatesFilter<"attempt_questions"> | $Enums.attempt_questions_question_type
    created_at?: DateTimeNullableWithAggregatesFilter<"attempt_questions"> | Date | string | null
  }

  export type attemptsWhereInput = {
    AND?: attemptsWhereInput | attemptsWhereInput[]
    OR?: attemptsWhereInput[]
    NOT?: attemptsWhereInput | attemptsWhereInput[]
    id?: BytesFilter<"attempts"> | Uint8Array
    student_id?: BytesFilter<"attempts"> | Uint8Array
    exam_id?: BytesFilter<"attempts"> | Uint8Array
    attempt_number?: IntFilter<"attempts"> | number
    total_score?: IntNullableFilter<"attempts"> | number | null
    max_score?: IntNullableFilter<"attempts"> | number | null
    graded?: BoolFilter<"attempts"> | boolean
    start_time?: DateTimeFilter<"attempts"> | Date | string
    end_time?: DateTimeNullableFilter<"attempts"> | Date | string | null
    attempt_questions?: Attempt_questionsListRelationFilter
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
    student_closed_answers?: Student_closed_answersListRelationFilter
    student_open_answers?: Student_open_answersListRelationFilter
  }

  export type attemptsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    attempt_number?: SortOrder
    total_score?: SortOrderInput | SortOrder
    max_score?: SortOrderInput | SortOrder
    graded?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrderInput | SortOrder
    attempt_questions?: attempt_questionsOrderByRelationAggregateInput
    students?: studentsOrderByWithRelationInput
    exams?: examsOrderByWithRelationInput
    student_closed_answers?: student_closed_answersOrderByRelationAggregateInput
    student_open_answers?: student_open_answersOrderByRelationAggregateInput
  }

  export type attemptsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    student_id_exam_id_attempt_number?: attemptsStudent_idExam_idAttempt_numberCompoundUniqueInput
    AND?: attemptsWhereInput | attemptsWhereInput[]
    OR?: attemptsWhereInput[]
    NOT?: attemptsWhereInput | attemptsWhereInput[]
    student_id?: BytesFilter<"attempts"> | Uint8Array
    exam_id?: BytesFilter<"attempts"> | Uint8Array
    attempt_number?: IntFilter<"attempts"> | number
    total_score?: IntNullableFilter<"attempts"> | number | null
    max_score?: IntNullableFilter<"attempts"> | number | null
    graded?: BoolFilter<"attempts"> | boolean
    start_time?: DateTimeFilter<"attempts"> | Date | string
    end_time?: DateTimeNullableFilter<"attempts"> | Date | string | null
    attempt_questions?: Attempt_questionsListRelationFilter
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
    student_closed_answers?: Student_closed_answersListRelationFilter
    student_open_answers?: Student_open_answersListRelationFilter
  }, "id" | "student_id_exam_id_attempt_number">

  export type attemptsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    attempt_number?: SortOrder
    total_score?: SortOrderInput | SortOrder
    max_score?: SortOrderInput | SortOrder
    graded?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrderInput | SortOrder
    _count?: attemptsCountOrderByAggregateInput
    _avg?: attemptsAvgOrderByAggregateInput
    _max?: attemptsMaxOrderByAggregateInput
    _min?: attemptsMinOrderByAggregateInput
    _sum?: attemptsSumOrderByAggregateInput
  }

  export type attemptsScalarWhereWithAggregatesInput = {
    AND?: attemptsScalarWhereWithAggregatesInput | attemptsScalarWhereWithAggregatesInput[]
    OR?: attemptsScalarWhereWithAggregatesInput[]
    NOT?: attemptsScalarWhereWithAggregatesInput | attemptsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"attempts"> | Uint8Array
    student_id?: BytesWithAggregatesFilter<"attempts"> | Uint8Array
    exam_id?: BytesWithAggregatesFilter<"attempts"> | Uint8Array
    attempt_number?: IntWithAggregatesFilter<"attempts"> | number
    total_score?: IntNullableWithAggregatesFilter<"attempts"> | number | null
    max_score?: IntNullableWithAggregatesFilter<"attempts"> | number | null
    graded?: BoolWithAggregatesFilter<"attempts"> | boolean
    start_time?: DateTimeWithAggregatesFilter<"attempts"> | Date | string
    end_time?: DateTimeNullableWithAggregatesFilter<"attempts"> | Date | string | null
  }

  export type classes_examsWhereInput = {
    AND?: classes_examsWhereInput | classes_examsWhereInput[]
    OR?: classes_examsWhereInput[]
    NOT?: classes_examsWhereInput | classes_examsWhereInput[]
    class_id?: BytesFilter<"classes_exams"> | Uint8Array
    exam_id?: BytesFilter<"classes_exams"> | Uint8Array
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }

  export type classes_examsOrderByWithRelationInput = {
    class_id?: SortOrder
    exam_id?: SortOrder
    classes?: classesOrderByWithRelationInput
    exams?: examsOrderByWithRelationInput
  }

  export type classes_examsWhereUniqueInput = Prisma.AtLeast<{
    class_id_exam_id?: classes_examsClass_idExam_idCompoundUniqueInput
    AND?: classes_examsWhereInput | classes_examsWhereInput[]
    OR?: classes_examsWhereInput[]
    NOT?: classes_examsWhereInput | classes_examsWhereInput[]
    class_id?: BytesFilter<"classes_exams"> | Uint8Array
    exam_id?: BytesFilter<"classes_exams"> | Uint8Array
    classes?: XOR<ClassesScalarRelationFilter, classesWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }, "class_id_exam_id">

  export type classes_examsOrderByWithAggregationInput = {
    class_id?: SortOrder
    exam_id?: SortOrder
    _count?: classes_examsCountOrderByAggregateInput
    _max?: classes_examsMaxOrderByAggregateInput
    _min?: classes_examsMinOrderByAggregateInput
  }

  export type classes_examsScalarWhereWithAggregatesInput = {
    AND?: classes_examsScalarWhereWithAggregatesInput | classes_examsScalarWhereWithAggregatesInput[]
    OR?: classes_examsScalarWhereWithAggregatesInput[]
    NOT?: classes_examsScalarWhereWithAggregatesInput | classes_examsScalarWhereWithAggregatesInput[]
    class_id?: BytesWithAggregatesFilter<"classes_exams"> | Uint8Array
    exam_id?: BytesWithAggregatesFilter<"classes_exams"> | Uint8Array
  }

  export type closed_answersWhereInput = {
    AND?: closed_answersWhereInput | closed_answersWhereInput[]
    OR?: closed_answersWhereInput[]
    NOT?: closed_answersWhereInput | closed_answersWhereInput[]
    id?: BytesFilter<"closed_answers"> | Uint8Array
    closed_question_id?: BytesFilter<"closed_answers"> | Uint8Array
    is_correct?: BoolNullableFilter<"closed_answers"> | boolean | null
    description?: StringFilter<"closed_answers"> | string
    closed_questions?: XOR<Closed_questionsScalarRelationFilter, closed_questionsWhereInput>
    student_closed_answers?: Student_closed_answersListRelationFilter
  }

  export type closed_answersOrderByWithRelationInput = {
    id?: SortOrder
    closed_question_id?: SortOrder
    is_correct?: SortOrderInput | SortOrder
    description?: SortOrder
    closed_questions?: closed_questionsOrderByWithRelationInput
    student_closed_answers?: student_closed_answersOrderByRelationAggregateInput
    _relevance?: closed_answersOrderByRelevanceInput
  }

  export type closed_answersWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: closed_answersWhereInput | closed_answersWhereInput[]
    OR?: closed_answersWhereInput[]
    NOT?: closed_answersWhereInput | closed_answersWhereInput[]
    closed_question_id?: BytesFilter<"closed_answers"> | Uint8Array
    is_correct?: BoolNullableFilter<"closed_answers"> | boolean | null
    description?: StringFilter<"closed_answers"> | string
    closed_questions?: XOR<Closed_questionsScalarRelationFilter, closed_questionsWhereInput>
    student_closed_answers?: Student_closed_answersListRelationFilter
  }, "id">

  export type closed_answersOrderByWithAggregationInput = {
    id?: SortOrder
    closed_question_id?: SortOrder
    is_correct?: SortOrderInput | SortOrder
    description?: SortOrder
    _count?: closed_answersCountOrderByAggregateInput
    _max?: closed_answersMaxOrderByAggregateInput
    _min?: closed_answersMinOrderByAggregateInput
  }

  export type closed_answersScalarWhereWithAggregatesInput = {
    AND?: closed_answersScalarWhereWithAggregatesInput | closed_answersScalarWhereWithAggregatesInput[]
    OR?: closed_answersScalarWhereWithAggregatesInput[]
    NOT?: closed_answersScalarWhereWithAggregatesInput | closed_answersScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"closed_answers"> | Uint8Array
    closed_question_id?: BytesWithAggregatesFilter<"closed_answers"> | Uint8Array
    is_correct?: BoolNullableWithAggregatesFilter<"closed_answers"> | boolean | null
    description?: StringWithAggregatesFilter<"closed_answers"> | string
  }

  export type closed_questionsWhereInput = {
    AND?: closed_questionsWhereInput | closed_questionsWhereInput[]
    OR?: closed_questionsWhereInput[]
    NOT?: closed_questionsWhereInput | closed_questionsWhereInput[]
    id?: BytesFilter<"closed_questions"> | Uint8Array
    exam_id?: BytesFilter<"closed_questions"> | Uint8Array
    score?: IntNullableFilter<"closed_questions"> | number | null
    is_multiple?: BoolNullableFilter<"closed_questions"> | boolean | null
    description?: StringFilter<"closed_questions"> | string
    attempt_questions?: Attempt_questionsListRelationFilter
    closed_answers?: Closed_answersListRelationFilter
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
    student_closed_answers?: Student_closed_answersListRelationFilter
  }

  export type closed_questionsOrderByWithRelationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    score?: SortOrderInput | SortOrder
    is_multiple?: SortOrderInput | SortOrder
    description?: SortOrder
    attempt_questions?: attempt_questionsOrderByRelationAggregateInput
    closed_answers?: closed_answersOrderByRelationAggregateInput
    exams?: examsOrderByWithRelationInput
    student_closed_answers?: student_closed_answersOrderByRelationAggregateInput
    _relevance?: closed_questionsOrderByRelevanceInput
  }

  export type closed_questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: closed_questionsWhereInput | closed_questionsWhereInput[]
    OR?: closed_questionsWhereInput[]
    NOT?: closed_questionsWhereInput | closed_questionsWhereInput[]
    exam_id?: BytesFilter<"closed_questions"> | Uint8Array
    score?: IntNullableFilter<"closed_questions"> | number | null
    is_multiple?: BoolNullableFilter<"closed_questions"> | boolean | null
    description?: StringFilter<"closed_questions"> | string
    attempt_questions?: Attempt_questionsListRelationFilter
    closed_answers?: Closed_answersListRelationFilter
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
    student_closed_answers?: Student_closed_answersListRelationFilter
  }, "id">

  export type closed_questionsOrderByWithAggregationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    score?: SortOrderInput | SortOrder
    is_multiple?: SortOrderInput | SortOrder
    description?: SortOrder
    _count?: closed_questionsCountOrderByAggregateInput
    _avg?: closed_questionsAvgOrderByAggregateInput
    _max?: closed_questionsMaxOrderByAggregateInput
    _min?: closed_questionsMinOrderByAggregateInput
    _sum?: closed_questionsSumOrderByAggregateInput
  }

  export type closed_questionsScalarWhereWithAggregatesInput = {
    AND?: closed_questionsScalarWhereWithAggregatesInput | closed_questionsScalarWhereWithAggregatesInput[]
    OR?: closed_questionsScalarWhereWithAggregatesInput[]
    NOT?: closed_questionsScalarWhereWithAggregatesInput | closed_questionsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"closed_questions"> | Uint8Array
    exam_id?: BytesWithAggregatesFilter<"closed_questions"> | Uint8Array
    score?: IntNullableWithAggregatesFilter<"closed_questions"> | number | null
    is_multiple?: BoolNullableWithAggregatesFilter<"closed_questions"> | boolean | null
    description?: StringWithAggregatesFilter<"closed_questions"> | string
  }

  export type files_repositoryWhereInput = {
    AND?: files_repositoryWhereInput | files_repositoryWhereInput[]
    OR?: files_repositoryWhereInput[]
    NOT?: files_repositoryWhereInput | files_repositoryWhereInput[]
    id?: BytesFilter<"files_repository"> | Uint8Array
    title?: StringFilter<"files_repository"> | string
    description?: StringFilter<"files_repository"> | string
    file?: BytesFilter<"files_repository"> | Uint8Array
    exam_id?: BytesFilter<"files_repository"> | Uint8Array
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }

  export type files_repositoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    exam_id?: SortOrder
    exams?: examsOrderByWithRelationInput
    _relevance?: files_repositoryOrderByRelevanceInput
  }

  export type files_repositoryWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: files_repositoryWhereInput | files_repositoryWhereInput[]
    OR?: files_repositoryWhereInput[]
    NOT?: files_repositoryWhereInput | files_repositoryWhereInput[]
    title?: StringFilter<"files_repository"> | string
    description?: StringFilter<"files_repository"> | string
    file?: BytesFilter<"files_repository"> | Uint8Array
    exam_id?: BytesFilter<"files_repository"> | Uint8Array
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }, "id">

  export type files_repositoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    exam_id?: SortOrder
    _count?: files_repositoryCountOrderByAggregateInput
    _max?: files_repositoryMaxOrderByAggregateInput
    _min?: files_repositoryMinOrderByAggregateInput
  }

  export type files_repositoryScalarWhereWithAggregatesInput = {
    AND?: files_repositoryScalarWhereWithAggregatesInput | files_repositoryScalarWhereWithAggregatesInput[]
    OR?: files_repositoryScalarWhereWithAggregatesInput[]
    NOT?: files_repositoryScalarWhereWithAggregatesInput | files_repositoryScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"files_repository"> | Uint8Array
    title?: StringWithAggregatesFilter<"files_repository"> | string
    description?: StringWithAggregatesFilter<"files_repository"> | string
    file?: BytesWithAggregatesFilter<"files_repository"> | Uint8Array
    exam_id?: BytesWithAggregatesFilter<"files_repository"> | Uint8Array
  }

  export type gradebook_examsWhereInput = {
    AND?: gradebook_examsWhereInput | gradebook_examsWhereInput[]
    OR?: gradebook_examsWhereInput[]
    NOT?: gradebook_examsWhereInput | gradebook_examsWhereInput[]
    id?: BytesFilter<"gradebook_exams"> | Uint8Array
    topic?: StringFilter<"gradebook_exams"> | string
    scope?: StringFilter<"gradebook_exams"> | string
    lesson_id?: BytesFilter<"gradebook_exams"> | Uint8Array
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
  }

  export type gradebook_examsOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    lesson_id?: SortOrder
    lessons?: lessonsOrderByWithRelationInput
    _relevance?: gradebook_examsOrderByRelevanceInput
  }

  export type gradebook_examsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: gradebook_examsWhereInput | gradebook_examsWhereInput[]
    OR?: gradebook_examsWhereInput[]
    NOT?: gradebook_examsWhereInput | gradebook_examsWhereInput[]
    topic?: StringFilter<"gradebook_exams"> | string
    scope?: StringFilter<"gradebook_exams"> | string
    lesson_id?: BytesFilter<"gradebook_exams"> | Uint8Array
    lessons?: XOR<LessonsScalarRelationFilter, lessonsWhereInput>
  }, "id">

  export type gradebook_examsOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    lesson_id?: SortOrder
    _count?: gradebook_examsCountOrderByAggregateInput
    _max?: gradebook_examsMaxOrderByAggregateInput
    _min?: gradebook_examsMinOrderByAggregateInput
  }

  export type gradebook_examsScalarWhereWithAggregatesInput = {
    AND?: gradebook_examsScalarWhereWithAggregatesInput | gradebook_examsScalarWhereWithAggregatesInput[]
    OR?: gradebook_examsScalarWhereWithAggregatesInput[]
    NOT?: gradebook_examsScalarWhereWithAggregatesInput | gradebook_examsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"gradebook_exams"> | Uint8Array
    topic?: StringWithAggregatesFilter<"gradebook_exams"> | string
    scope?: StringWithAggregatesFilter<"gradebook_exams"> | string
    lesson_id?: BytesWithAggregatesFilter<"gradebook_exams"> | Uint8Array
  }

  export type grades_examsWhereInput = {
    AND?: grades_examsWhereInput | grades_examsWhereInput[]
    OR?: grades_examsWhereInput[]
    NOT?: grades_examsWhereInput | grades_examsWhereInput[]
    id?: BytesFilter<"grades_exams"> | Uint8Array
    student_id?: BytesFilter<"grades_exams"> | Uint8Array
    attempt_id?: BytesFilter<"grades_exams"> | Uint8Array
    exam_id?: BytesFilter<"grades_exams"> | Uint8Array
    description?: StringFilter<"grades_exams"> | string
    grade?: StringFilter<"grades_exams"> | string
    date_given?: DateTimeFilter<"grades_exams"> | Date | string
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }

  export type grades_examsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    exam_id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    date_given?: SortOrder
    students?: studentsOrderByWithRelationInput
    exams?: examsOrderByWithRelationInput
    _relevance?: grades_examsOrderByRelevanceInput
  }

  export type grades_examsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: grades_examsWhereInput | grades_examsWhereInput[]
    OR?: grades_examsWhereInput[]
    NOT?: grades_examsWhereInput | grades_examsWhereInput[]
    student_id?: BytesFilter<"grades_exams"> | Uint8Array
    attempt_id?: BytesFilter<"grades_exams"> | Uint8Array
    exam_id?: BytesFilter<"grades_exams"> | Uint8Array
    description?: StringFilter<"grades_exams"> | string
    grade?: StringFilter<"grades_exams"> | string
    date_given?: DateTimeFilter<"grades_exams"> | Date | string
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }, "id">

  export type grades_examsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    exam_id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    date_given?: SortOrder
    _count?: grades_examsCountOrderByAggregateInput
    _max?: grades_examsMaxOrderByAggregateInput
    _min?: grades_examsMinOrderByAggregateInput
  }

  export type grades_examsScalarWhereWithAggregatesInput = {
    AND?: grades_examsScalarWhereWithAggregatesInput | grades_examsScalarWhereWithAggregatesInput[]
    OR?: grades_examsScalarWhereWithAggregatesInput[]
    NOT?: grades_examsScalarWhereWithAggregatesInput | grades_examsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"grades_exams"> | Uint8Array
    student_id?: BytesWithAggregatesFilter<"grades_exams"> | Uint8Array
    attempt_id?: BytesWithAggregatesFilter<"grades_exams"> | Uint8Array
    exam_id?: BytesWithAggregatesFilter<"grades_exams"> | Uint8Array
    description?: StringWithAggregatesFilter<"grades_exams"> | string
    grade?: StringWithAggregatesFilter<"grades_exams"> | string
    date_given?: DateTimeWithAggregatesFilter<"grades_exams"> | Date | string
  }

  export type grading_scaleWhereInput = {
    AND?: grading_scaleWhereInput | grading_scaleWhereInput[]
    OR?: grading_scaleWhereInput[]
    NOT?: grading_scaleWhereInput | grading_scaleWhereInput[]
    id?: BytesFilter<"grading_scale"> | Uint8Array
    min_score?: IntFilter<"grading_scale"> | number
    max_score?: IntFilter<"grading_scale"> | number
    grades?: StringFilter<"grading_scale"> | string
  }

  export type grading_scaleOrderByWithRelationInput = {
    id?: SortOrder
    min_score?: SortOrder
    max_score?: SortOrder
    grades?: SortOrder
    _relevance?: grading_scaleOrderByRelevanceInput
  }

  export type grading_scaleWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: grading_scaleWhereInput | grading_scaleWhereInput[]
    OR?: grading_scaleWhereInput[]
    NOT?: grading_scaleWhereInput | grading_scaleWhereInput[]
    min_score?: IntFilter<"grading_scale"> | number
    max_score?: IntFilter<"grading_scale"> | number
    grades?: StringFilter<"grading_scale"> | string
  }, "id">

  export type grading_scaleOrderByWithAggregationInput = {
    id?: SortOrder
    min_score?: SortOrder
    max_score?: SortOrder
    grades?: SortOrder
    _count?: grading_scaleCountOrderByAggregateInput
    _avg?: grading_scaleAvgOrderByAggregateInput
    _max?: grading_scaleMaxOrderByAggregateInput
    _min?: grading_scaleMinOrderByAggregateInput
    _sum?: grading_scaleSumOrderByAggregateInput
  }

  export type grading_scaleScalarWhereWithAggregatesInput = {
    AND?: grading_scaleScalarWhereWithAggregatesInput | grading_scaleScalarWhereWithAggregatesInput[]
    OR?: grading_scaleScalarWhereWithAggregatesInput[]
    NOT?: grading_scaleScalarWhereWithAggregatesInput | grading_scaleScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"grading_scale"> | Uint8Array
    min_score?: IntWithAggregatesFilter<"grading_scale"> | number
    max_score?: IntWithAggregatesFilter<"grading_scale"> | number
    grades?: StringWithAggregatesFilter<"grading_scale"> | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: BytesFilter<"notifications"> | Uint8Array
    student_id?: BytesFilter<"notifications"> | Uint8Array
    description?: StringFilter<"notifications"> | string
    notification_date?: DateTimeFilter<"notifications"> | Date | string
    is_read?: BoolFilter<"notifications"> | boolean
    exam_id?: BytesNullableFilter<"notifications"> | Uint8Array | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsNullableScalarRelationFilter, examsWhereInput> | null
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    description?: SortOrder
    notification_date?: SortOrder
    is_read?: SortOrder
    exam_id?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
    exams?: examsOrderByWithRelationInput
    _relevance?: notificationsOrderByRelevanceInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    student_id?: BytesFilter<"notifications"> | Uint8Array
    description?: StringFilter<"notifications"> | string
    notification_date?: DateTimeFilter<"notifications"> | Date | string
    is_read?: BoolFilter<"notifications"> | boolean
    exam_id?: BytesNullableFilter<"notifications"> | Uint8Array | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsNullableScalarRelationFilter, examsWhereInput> | null
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    description?: SortOrder
    notification_date?: SortOrder
    is_read?: SortOrder
    exam_id?: SortOrderInput | SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"notifications"> | Uint8Array
    student_id?: BytesWithAggregatesFilter<"notifications"> | Uint8Array
    description?: StringWithAggregatesFilter<"notifications"> | string
    notification_date?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    is_read?: BoolWithAggregatesFilter<"notifications"> | boolean
    exam_id?: BytesNullableWithAggregatesFilter<"notifications"> | Uint8Array | null
  }

  export type open_answersWhereInput = {
    AND?: open_answersWhereInput | open_answersWhereInput[]
    OR?: open_answersWhereInput[]
    NOT?: open_answersWhereInput | open_answersWhereInput[]
    id?: BytesFilter<"open_answers"> | Uint8Array
    open_question_id?: BytesFilter<"open_answers"> | Uint8Array
    description?: StringFilter<"open_answers"> | string
    open_questions?: XOR<Open_questionsScalarRelationFilter, open_questionsWhereInput>
  }

  export type open_answersOrderByWithRelationInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    description?: SortOrder
    open_questions?: open_questionsOrderByWithRelationInput
    _relevance?: open_answersOrderByRelevanceInput
  }

  export type open_answersWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: open_answersWhereInput | open_answersWhereInput[]
    OR?: open_answersWhereInput[]
    NOT?: open_answersWhereInput | open_answersWhereInput[]
    open_question_id?: BytesFilter<"open_answers"> | Uint8Array
    description?: StringFilter<"open_answers"> | string
    open_questions?: XOR<Open_questionsScalarRelationFilter, open_questionsWhereInput>
  }, "id">

  export type open_answersOrderByWithAggregationInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    description?: SortOrder
    _count?: open_answersCountOrderByAggregateInput
    _max?: open_answersMaxOrderByAggregateInput
    _min?: open_answersMinOrderByAggregateInput
  }

  export type open_answersScalarWhereWithAggregatesInput = {
    AND?: open_answersScalarWhereWithAggregatesInput | open_answersScalarWhereWithAggregatesInput[]
    OR?: open_answersScalarWhereWithAggregatesInput[]
    NOT?: open_answersScalarWhereWithAggregatesInput | open_answersScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"open_answers"> | Uint8Array
    open_question_id?: BytesWithAggregatesFilter<"open_answers"> | Uint8Array
    description?: StringWithAggregatesFilter<"open_answers"> | string
  }

  export type open_questionsWhereInput = {
    AND?: open_questionsWhereInput | open_questionsWhereInput[]
    OR?: open_questionsWhereInput[]
    NOT?: open_questionsWhereInput | open_questionsWhereInput[]
    id?: BytesFilter<"open_questions"> | Uint8Array
    exam_id?: BytesFilter<"open_questions"> | Uint8Array
    auto_check?: BoolFilter<"open_questions"> | boolean
    description?: StringNullableFilter<"open_questions"> | string | null
    score?: IntFilter<"open_questions"> | number
    attempt_questions?: Attempt_questionsListRelationFilter
    open_answers?: Open_answersListRelationFilter
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
    student_open_answers?: Student_open_answersListRelationFilter
  }

  export type open_questionsOrderByWithRelationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    auto_check?: SortOrder
    description?: SortOrderInput | SortOrder
    score?: SortOrder
    attempt_questions?: attempt_questionsOrderByRelationAggregateInput
    open_answers?: open_answersOrderByRelationAggregateInput
    exams?: examsOrderByWithRelationInput
    student_open_answers?: student_open_answersOrderByRelationAggregateInput
    _relevance?: open_questionsOrderByRelevanceInput
  }

  export type open_questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: open_questionsWhereInput | open_questionsWhereInput[]
    OR?: open_questionsWhereInput[]
    NOT?: open_questionsWhereInput | open_questionsWhereInput[]
    exam_id?: BytesFilter<"open_questions"> | Uint8Array
    auto_check?: BoolFilter<"open_questions"> | boolean
    description?: StringNullableFilter<"open_questions"> | string | null
    score?: IntFilter<"open_questions"> | number
    attempt_questions?: Attempt_questionsListRelationFilter
    open_answers?: Open_answersListRelationFilter
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
    student_open_answers?: Student_open_answersListRelationFilter
  }, "id">

  export type open_questionsOrderByWithAggregationInput = {
    id?: SortOrder
    exam_id?: SortOrder
    auto_check?: SortOrder
    description?: SortOrderInput | SortOrder
    score?: SortOrder
    _count?: open_questionsCountOrderByAggregateInput
    _avg?: open_questionsAvgOrderByAggregateInput
    _max?: open_questionsMaxOrderByAggregateInput
    _min?: open_questionsMinOrderByAggregateInput
    _sum?: open_questionsSumOrderByAggregateInput
  }

  export type open_questionsScalarWhereWithAggregatesInput = {
    AND?: open_questionsScalarWhereWithAggregatesInput | open_questionsScalarWhereWithAggregatesInput[]
    OR?: open_questionsScalarWhereWithAggregatesInput[]
    NOT?: open_questionsScalarWhereWithAggregatesInput | open_questionsScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"open_questions"> | Uint8Array
    exam_id?: BytesWithAggregatesFilter<"open_questions"> | Uint8Array
    auto_check?: BoolWithAggregatesFilter<"open_questions"> | boolean
    description?: StringNullableWithAggregatesFilter<"open_questions"> | string | null
    score?: IntWithAggregatesFilter<"open_questions"> | number
  }

  export type student_closed_answersWhereInput = {
    AND?: student_closed_answersWhereInput | student_closed_answersWhereInput[]
    OR?: student_closed_answersWhereInput[]
    NOT?: student_closed_answersWhereInput | student_closed_answersWhereInput[]
    id?: BytesFilter<"student_closed_answers"> | Uint8Array
    student_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    closed_question_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    closed_answer_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    attempt_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    correctness?: BoolNullableFilter<"student_closed_answers"> | boolean | null
    date_time?: DateTimeNullableFilter<"student_closed_answers"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    closed_questions?: XOR<Closed_questionsScalarRelationFilter, closed_questionsWhereInput>
    closed_answers?: XOR<Closed_answersScalarRelationFilter, closed_answersWhereInput>
    attempts?: XOR<AttemptsScalarRelationFilter, attemptsWhereInput>
  }

  export type student_closed_answersOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    closed_question_id?: SortOrder
    closed_answer_id?: SortOrder
    attempt_id?: SortOrder
    correctness?: SortOrderInput | SortOrder
    date_time?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
    closed_questions?: closed_questionsOrderByWithRelationInput
    closed_answers?: closed_answersOrderByWithRelationInput
    attempts?: attemptsOrderByWithRelationInput
  }

  export type student_closed_answersWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: student_closed_answersWhereInput | student_closed_answersWhereInput[]
    OR?: student_closed_answersWhereInput[]
    NOT?: student_closed_answersWhereInput | student_closed_answersWhereInput[]
    student_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    closed_question_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    closed_answer_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    attempt_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    correctness?: BoolNullableFilter<"student_closed_answers"> | boolean | null
    date_time?: DateTimeNullableFilter<"student_closed_answers"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    closed_questions?: XOR<Closed_questionsScalarRelationFilter, closed_questionsWhereInput>
    closed_answers?: XOR<Closed_answersScalarRelationFilter, closed_answersWhereInput>
    attempts?: XOR<AttemptsScalarRelationFilter, attemptsWhereInput>
  }, "id">

  export type student_closed_answersOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    closed_question_id?: SortOrder
    closed_answer_id?: SortOrder
    attempt_id?: SortOrder
    correctness?: SortOrderInput | SortOrder
    date_time?: SortOrderInput | SortOrder
    _count?: student_closed_answersCountOrderByAggregateInput
    _max?: student_closed_answersMaxOrderByAggregateInput
    _min?: student_closed_answersMinOrderByAggregateInput
  }

  export type student_closed_answersScalarWhereWithAggregatesInput = {
    AND?: student_closed_answersScalarWhereWithAggregatesInput | student_closed_answersScalarWhereWithAggregatesInput[]
    OR?: student_closed_answersScalarWhereWithAggregatesInput[]
    NOT?: student_closed_answersScalarWhereWithAggregatesInput | student_closed_answersScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"student_closed_answers"> | Uint8Array
    student_id?: BytesWithAggregatesFilter<"student_closed_answers"> | Uint8Array
    closed_question_id?: BytesWithAggregatesFilter<"student_closed_answers"> | Uint8Array
    closed_answer_id?: BytesWithAggregatesFilter<"student_closed_answers"> | Uint8Array
    attempt_id?: BytesWithAggregatesFilter<"student_closed_answers"> | Uint8Array
    correctness?: BoolNullableWithAggregatesFilter<"student_closed_answers"> | boolean | null
    date_time?: DateTimeNullableWithAggregatesFilter<"student_closed_answers"> | Date | string | null
  }

  export type student_open_answersWhereInput = {
    AND?: student_open_answersWhereInput | student_open_answersWhereInput[]
    OR?: student_open_answersWhereInput[]
    NOT?: student_open_answersWhereInput | student_open_answersWhereInput[]
    id?: BytesFilter<"student_open_answers"> | Uint8Array
    open_question_id?: BytesFilter<"student_open_answers"> | Uint8Array
    score?: IntNullableFilter<"student_open_answers"> | number | null
    student_id?: BytesFilter<"student_open_answers"> | Uint8Array
    attempt_id?: BytesFilter<"student_open_answers"> | Uint8Array
    date_time?: DateTimeNullableFilter<"student_open_answers"> | Date | string | null
    description?: StringNullableFilter<"student_open_answers"> | string | null
    open_questions?: XOR<Open_questionsScalarRelationFilter, open_questionsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    attempts?: XOR<AttemptsScalarRelationFilter, attemptsWhereInput>
  }

  export type student_open_answersOrderByWithRelationInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    score?: SortOrderInput | SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    date_time?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    open_questions?: open_questionsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
    attempts?: attemptsOrderByWithRelationInput
    _relevance?: student_open_answersOrderByRelevanceInput
  }

  export type student_open_answersWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: student_open_answersWhereInput | student_open_answersWhereInput[]
    OR?: student_open_answersWhereInput[]
    NOT?: student_open_answersWhereInput | student_open_answersWhereInput[]
    open_question_id?: BytesFilter<"student_open_answers"> | Uint8Array
    score?: IntNullableFilter<"student_open_answers"> | number | null
    student_id?: BytesFilter<"student_open_answers"> | Uint8Array
    attempt_id?: BytesFilter<"student_open_answers"> | Uint8Array
    date_time?: DateTimeNullableFilter<"student_open_answers"> | Date | string | null
    description?: StringNullableFilter<"student_open_answers"> | string | null
    open_questions?: XOR<Open_questionsScalarRelationFilter, open_questionsWhereInput>
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    attempts?: XOR<AttemptsScalarRelationFilter, attemptsWhereInput>
  }, "id">

  export type student_open_answersOrderByWithAggregationInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    score?: SortOrderInput | SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    date_time?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: student_open_answersCountOrderByAggregateInput
    _avg?: student_open_answersAvgOrderByAggregateInput
    _max?: student_open_answersMaxOrderByAggregateInput
    _min?: student_open_answersMinOrderByAggregateInput
    _sum?: student_open_answersSumOrderByAggregateInput
  }

  export type student_open_answersScalarWhereWithAggregatesInput = {
    AND?: student_open_answersScalarWhereWithAggregatesInput | student_open_answersScalarWhereWithAggregatesInput[]
    OR?: student_open_answersScalarWhereWithAggregatesInput[]
    NOT?: student_open_answersScalarWhereWithAggregatesInput | student_open_answersScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"student_open_answers"> | Uint8Array
    open_question_id?: BytesWithAggregatesFilter<"student_open_answers"> | Uint8Array
    score?: IntNullableWithAggregatesFilter<"student_open_answers"> | number | null
    student_id?: BytesWithAggregatesFilter<"student_open_answers"> | Uint8Array
    attempt_id?: BytesWithAggregatesFilter<"student_open_answers"> | Uint8Array
    date_time?: DateTimeNullableWithAggregatesFilter<"student_open_answers"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"student_open_answers"> | string | null
  }

  export type students_examsWhereInput = {
    AND?: students_examsWhereInput | students_examsWhereInput[]
    OR?: students_examsWhereInput[]
    NOT?: students_examsWhereInput | students_examsWhereInput[]
    students_id?: BytesFilter<"students_exams"> | Uint8Array
    exam_id?: BytesFilter<"students_exams"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }

  export type students_examsOrderByWithRelationInput = {
    students_id?: SortOrder
    exam_id?: SortOrder
    students?: studentsOrderByWithRelationInput
    exams?: examsOrderByWithRelationInput
  }

  export type students_examsWhereUniqueInput = Prisma.AtLeast<{
    students_id_exam_id?: students_examsStudents_idExam_idCompoundUniqueInput
    AND?: students_examsWhereInput | students_examsWhereInput[]
    OR?: students_examsWhereInput[]
    NOT?: students_examsWhereInput | students_examsWhereInput[]
    students_id?: BytesFilter<"students_exams"> | Uint8Array
    exam_id?: BytesFilter<"students_exams"> | Uint8Array
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    exams?: XOR<ExamsScalarRelationFilter, examsWhereInput>
  }, "students_id_exam_id">

  export type students_examsOrderByWithAggregationInput = {
    students_id?: SortOrder
    exam_id?: SortOrder
    _count?: students_examsCountOrderByAggregateInput
    _max?: students_examsMaxOrderByAggregateInput
    _min?: students_examsMinOrderByAggregateInput
  }

  export type students_examsScalarWhereWithAggregatesInput = {
    AND?: students_examsScalarWhereWithAggregatesInput | students_examsScalarWhereWithAggregatesInput[]
    OR?: students_examsScalarWhereWithAggregatesInput[]
    NOT?: students_examsScalarWhereWithAggregatesInput | students_examsScalarWhereWithAggregatesInput[]
    students_id?: BytesWithAggregatesFilter<"students_exams"> | Uint8Array
    exam_id?: BytesWithAggregatesFilter<"students_exams"> | Uint8Array
  }

  export type attendancesCreateInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    students: studentsCreateNestedOneWithoutAttendancesInput
    lessons: lessonsCreateNestedOneWithoutAttendancesInput
  }

  export type attendancesUncheckedCreateInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    student_id: Uint8Array
    lesson_id: Uint8Array
  }

  export type attendancesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    students?: studentsUpdateOneRequiredWithoutAttendancesNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type attendancesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type attendancesCreateManyInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    student_id: Uint8Array
    lesson_id: Uint8Array
  }

  export type attendancesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
  }

  export type attendancesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type badgesCreateInput = {
    id?: Uint8Array
    name: string
    description: string
    badges_categories: badges_categoriesCreateNestedOneWithoutBadgesInput
    badges_history?: badges_historyCreateNestedManyWithoutBadgesInput
  }

  export type badgesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    description: string
    category_id: Uint8Array
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutBadgesInput
  }

  export type badgesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badges_categories?: badges_categoriesUpdateOneRequiredWithoutBadgesNestedInput
    badges_history?: badges_historyUpdateManyWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category_id?: BytesFieldUpdateOperationsInput | Uint8Array
    badges_history?: badges_historyUncheckedUpdateManyWithoutBadgesNestedInput
  }

  export type badgesCreateManyInput = {
    id?: Uint8Array
    name: string
    description: string
    category_id: Uint8Array
  }

  export type badgesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type badgesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type badges_categoriesCreateInput = {
    id?: Uint8Array
    name: string
    badges?: badgesCreateNestedManyWithoutBadges_categoriesInput
  }

  export type badges_categoriesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    badges?: badgesUncheckedCreateNestedManyWithoutBadges_categoriesInput
  }

  export type badges_categoriesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    badges?: badgesUpdateManyWithoutBadges_categoriesNestedInput
  }

  export type badges_categoriesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    badges?: badgesUncheckedUpdateManyWithoutBadges_categoriesNestedInput
  }

  export type badges_categoriesCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type badges_categoriesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type badges_categoriesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type badges_historyCreateInput = {
    id?: Uint8Array
    date_awarded: Date | string
    students: studentsCreateNestedOneWithoutBadges_historyInput
    badges: badgesCreateNestedOneWithoutBadges_historyInput
  }

  export type badges_historyUncheckedCreateInput = {
    id?: Uint8Array
    date_awarded: Date | string
    student_id: Uint8Array
    badge_id: Uint8Array
  }

  export type badges_historyUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutBadges_historyNestedInput
    badges?: badgesUpdateOneRequiredWithoutBadges_historyNestedInput
  }

  export type badges_historyUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    badge_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type badges_historyCreateManyInput = {
    id?: Uint8Array
    date_awarded: Date | string
    student_id: Uint8Array
    badge_id: Uint8Array
  }

  export type badges_historyUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type badges_historyUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    badge_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classesCreateInput = {
    id?: Uint8Array
    class_names: class_namesCreateNestedOneWithoutClassesInput
    school_years: school_yearsCreateNestedOneWithoutClassesInput
    teachers?: teachersCreateNestedOneWithoutClassesInput
    classes_exams?: classes_examsCreateNestedManyWithoutClassesInput
    lessons?: lessonsCreateNestedManyWithoutClassesInput
    students?: studentsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
    teacher_id?: Uint8Array | null
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutClassesInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutClassesInput
    students?: studentsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_names?: class_namesUpdateOneRequiredWithoutClassesNestedInput
    school_years?: school_yearsUpdateOneRequiredWithoutClassesNestedInput
    teachers?: teachersUpdateOneWithoutClassesNestedInput
    classes_exams?: classes_examsUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUpdateManyWithoutClassesNestedInput
    students?: studentsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    classes_exams?: classes_examsUncheckedUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutClassesNestedInput
    students?: studentsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesCreateManyInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
    teacher_id?: Uint8Array | null
  }

  export type classesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type event_typesCreateInput = {
    id?: Uint8Array
    name: string
    school_events?: school_eventsCreateNestedManyWithoutEvent_typesInput
  }

  export type event_typesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    school_events?: school_eventsUncheckedCreateNestedManyWithoutEvent_typesInput
  }

  export type event_typesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    school_events?: school_eventsUpdateManyWithoutEvent_typesNestedInput
  }

  export type event_typesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    school_events?: school_eventsUncheckedUpdateManyWithoutEvent_typesNestedInput
  }

  export type event_typesCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type event_typesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_typesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type grades_gradebookCreateInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    students: studentsCreateNestedOneWithoutGrades_gradebookInput
    subjects: subjectsCreateNestedOneWithoutGrades_gradebookInput
    teachers: teachersCreateNestedOneWithoutGrades_gradebookInput
  }

  export type grades_gradebookUncheckedCreateInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type grades_gradebookUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutGrades_gradebookNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutGrades_gradebookNestedInput
    teachers?: teachersUpdateOneRequiredWithoutGrades_gradebookNestedInput
  }

  export type grades_gradebookUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_gradebookCreateManyInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type grades_gradebookUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grades_gradebookUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type homeworksCreateInput = {
    id?: Uint8Array
    description: string
    deadline: Date | string
    lessons: lessonsCreateNestedOneWithoutHomeworksInput
  }

  export type homeworksUncheckedCreateInput = {
    id?: Uint8Array
    description: string
    deadline: Date | string
    lesson_id: Uint8Array
  }

  export type homeworksUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: lessonsUpdateOneRequiredWithoutHomeworksNestedInput
  }

  export type homeworksUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type homeworksCreateManyInput = {
    id?: Uint8Array
    description: string
    deadline: Date | string
    lesson_id: Uint8Array
  }

  export type homeworksUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type homeworksUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type lessonsCreateInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    attendances?: attendancesCreateNestedManyWithoutLessonsInput
    exams?: examsCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksCreateNestedOneWithoutLessonsInput
    teachers: teachersCreateNestedOneWithoutLessonsInput
    classes: classesCreateNestedOneWithoutLessonsInput
    subjects: subjectsCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
    subject_id: Uint8Array
    attendances?: attendancesUncheckedCreateNestedManyWithoutLessonsInput
    exams?: examsUncheckedCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksUncheckedCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: attendancesUpdateManyWithoutLessonsNestedInput
    exams?: examsUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUpdateOneWithoutLessonsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLessonsNestedInput
    classes?: classesUpdateOneRequiredWithoutLessonsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attendances?: attendancesUncheckedUpdateManyWithoutLessonsNestedInput
    exams?: examsUncheckedUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUncheckedUpdateOneWithoutLessonsNestedInput
  }

  export type lessonsCreateManyInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
    subject_id: Uint8Array
  }

  export type lessonsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lessonsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type messagesCreateInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    receiver_id: Uint8Array
    user_types_messages_sender_type_idTouser_types: user_typesCreateNestedOneWithoutMessages_messages_sender_type_idTouser_typesInput
    user_types_messages_receiver_type_idTouser_types: user_typesCreateNestedOneWithoutMessages_messages_receiver_type_idTouser_typesInput
  }

  export type messagesUncheckedCreateInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    sender_type_id: Uint8Array
    receiver_id: Uint8Array
    receiver_type_id: Uint8Array
  }

  export type messagesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_types_messages_sender_type_idTouser_types?: user_typesUpdateOneRequiredWithoutMessages_messages_sender_type_idTouser_typesNestedInput
    user_types_messages_receiver_type_idTouser_types?: user_typesUpdateOneRequiredWithoutMessages_messages_receiver_type_idTouser_typesNestedInput
  }

  export type messagesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    sender_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type messagesCreateManyInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    sender_type_id: Uint8Array
    receiver_id: Uint8Array
    receiver_type_id: Uint8Array
  }

  export type messagesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type messagesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    sender_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type parentsCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    students_parents?: students_parentsCreateNestedManyWithoutParentsInput
  }

  export type parentsUncheckedCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students_parents?: students_parentsUpdateManyWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students_parents?: students_parentsUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type parentsCreateManyInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type parentsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parentsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type problem_typesCreateInput = {
    id?: Uint8Array
    name: string
    problems_gradebook?: problems_gradebookCreateNestedManyWithoutProblem_typesInput
  }

  export type problem_typesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    problems_gradebook?: problems_gradebookUncheckedCreateNestedManyWithoutProblem_typesInput
  }

  export type problem_typesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    problems_gradebook?: problems_gradebookUpdateManyWithoutProblem_typesNestedInput
  }

  export type problem_typesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    problems_gradebook?: problems_gradebookUncheckedUpdateManyWithoutProblem_typesNestedInput
  }

  export type problem_typesCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type problem_typesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type problem_typesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type problems_gradebookCreateInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    reporter_id: Uint8Array
    problem_types: problem_typesCreateNestedOneWithoutProblems_gradebookInput
    user_types: user_typesCreateNestedOneWithoutProblems_gradebookInput
    statuses: statusesCreateNestedOneWithoutProblems_gradebookInput
  }

  export type problems_gradebookUncheckedCreateInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    problem_type_id: Uint8Array
    reporter_id: Uint8Array
    user_type_id: Uint8Array
    status_id: Uint8Array
  }

  export type problems_gradebookUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    problem_types?: problem_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput
    user_types?: user_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput
    statuses?: statusesUpdateOneRequiredWithoutProblems_gradebookNestedInput
  }

  export type problems_gradebookUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    problem_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    status_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookCreateManyInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    problem_type_id: Uint8Array
    reporter_id: Uint8Array
    user_type_id: Uint8Array
    status_id: Uint8Array
  }

  export type problems_gradebookUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    problem_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    status_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type school_eventsCreateInput = {
    id?: Uint8Array
    name: string
    location: string
    description: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    event_types: event_typesCreateNestedOneWithoutSchool_eventsInput
  }

  export type school_eventsUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    location: string
    description: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    event_type_id: Uint8Array
  }

  export type school_eventsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    event_types?: event_typesUpdateOneRequiredWithoutSchool_eventsNestedInput
  }

  export type school_eventsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    event_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type school_eventsCreateManyInput = {
    id?: Uint8Array
    name: string
    location: string
    description: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    event_type_id: Uint8Array
  }

  export type school_eventsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type school_eventsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    event_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type statusesCreateInput = {
    id?: Uint8Array
    name: string
    problems_gradebook?: problems_gradebookCreateNestedManyWithoutStatusesInput
  }

  export type statusesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    problems_gradebook?: problems_gradebookUncheckedCreateNestedManyWithoutStatusesInput
  }

  export type statusesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    problems_gradebook?: problems_gradebookUpdateManyWithoutStatusesNestedInput
  }

  export type statusesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    problems_gradebook?: problems_gradebookUncheckedUpdateManyWithoutStatusesNestedInput
  }

  export type statusesCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type statusesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type statusesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type studentsCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsCreateManyInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
  }

  export type studentsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type students_parentsCreateInput = {
    students: studentsCreateNestedOneWithoutStudents_parentsInput
    parents: parentsCreateNestedOneWithoutStudents_parentsInput
  }

  export type students_parentsUncheckedCreateInput = {
    student_id: Uint8Array
    parent_id: Uint8Array
  }

  export type students_parentsUpdateInput = {
    students?: studentsUpdateOneRequiredWithoutStudents_parentsNestedInput
    parents?: parentsUpdateOneRequiredWithoutStudents_parentsNestedInput
  }

  export type students_parentsUncheckedUpdateInput = {
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    parent_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type students_parentsCreateManyInput = {
    student_id: Uint8Array
    parent_id: Uint8Array
  }

  export type students_parentsUpdateManyMutationInput = {

  }

  export type students_parentsUncheckedUpdateManyInput = {
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    parent_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type subjectsCreateInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesCreateNestedManyWithoutSubjectsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutSubjectsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUpdateManyWithoutSubjectsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUncheckedUpdateManyWithoutSubjectsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type subjectsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type subjectsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type surveysCreateInput = {
    id?: Uint8Array
    name: string
    description: string
    start_time: Date | string
    end_time: Date | string
    questions?: questionsCreateNestedManyWithoutSurveysInput
  }

  export type surveysUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    description: string
    start_time: Date | string
    end_time: Date | string
    questions?: questionsUncheckedCreateNestedManyWithoutSurveysInput
  }

  export type surveysUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateManyWithoutSurveysNestedInput
  }

  export type surveysUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutSurveysNestedInput
  }

  export type surveysCreateManyInput = {
    id?: Uint8Array
    name: string
    description: string
    start_time: Date | string
    end_time: Date | string
  }

  export type surveysUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveysUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teachersCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutTeachersInput
    lessons?: lessonsCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutTeachersInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type teachersCreateManyInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type teachersUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teachersUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teachers_subjectsCreateInput = {
    teachers: teachersCreateNestedOneWithoutTeachers_subjectsInput
    subjects: subjectsCreateNestedOneWithoutTeachers_subjectsInput
  }

  export type teachers_subjectsUncheckedCreateInput = {
    teacher_id: Uint8Array
    subject_id: Uint8Array
  }

  export type teachers_subjectsUpdateInput = {
    teachers?: teachersUpdateOneRequiredWithoutTeachers_subjectsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutTeachers_subjectsNestedInput
  }

  export type teachers_subjectsUncheckedUpdateInput = {
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type teachers_subjectsCreateManyInput = {
    teacher_id: Uint8Array
    subject_id: Uint8Array
  }

  export type teachers_subjectsUpdateManyMutationInput = {

  }

  export type teachers_subjectsUncheckedUpdateManyInput = {
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type updatesCreateInput = {
    id?: Uint8Array
    description: string
    version: string
    release_time: Date | string
  }

  export type updatesUncheckedCreateInput = {
    id?: Uint8Array
    description: string
    version: string
    release_time: Date | string
  }

  export type updatesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type updatesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type updatesCreateManyInput = {
    id?: Uint8Array
    description: string
    version: string
    release_time: Date | string
  }

  export type updatesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type updatesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type administratorsCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type administratorsUncheckedCreateInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type administratorsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type administratorsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type administratorsCreateManyInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type administratorsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type administratorsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_typesCreateInput = {
    id?: Uint8Array
    name: string
    messages_messages_sender_type_idTouser_types?: messagesCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput
    messages_messages_receiver_type_idTouser_types?: messagesCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput
    problems_gradebook?: problems_gradebookCreateNestedManyWithoutUser_typesInput
  }

  export type user_typesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    messages_messages_sender_type_idTouser_types?: messagesUncheckedCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput
    messages_messages_receiver_type_idTouser_types?: messagesUncheckedCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput
    problems_gradebook?: problems_gradebookUncheckedCreateNestedManyWithoutUser_typesInput
  }

  export type user_typesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_sender_type_idTouser_types?: messagesUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput
    messages_messages_receiver_type_idTouser_types?: messagesUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput
    problems_gradebook?: problems_gradebookUpdateManyWithoutUser_typesNestedInput
  }

  export type user_typesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_sender_type_idTouser_types?: messagesUncheckedUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput
    messages_messages_receiver_type_idTouser_types?: messagesUncheckedUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput
    problems_gradebook?: problems_gradebookUncheckedUpdateManyWithoutUser_typesNestedInput
  }

  export type user_typesCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type user_typesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type user_typesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type school_yearsCreateInput = {
    id?: Uint8Array
    name: string
    start_date: Date | string
    end_date: Date | string
    classes?: classesCreateNestedManyWithoutSchool_yearsInput
    semesters?: semestersCreateNestedManyWithoutSchool_yearsInput
  }

  export type school_yearsUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    start_date: Date | string
    end_date: Date | string
    classes?: classesUncheckedCreateNestedManyWithoutSchool_yearsInput
    semesters?: semestersUncheckedCreateNestedManyWithoutSchool_yearsInput
  }

  export type school_yearsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: classesUpdateManyWithoutSchool_yearsNestedInput
    semesters?: semestersUpdateManyWithoutSchool_yearsNestedInput
  }

  export type school_yearsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: classesUncheckedUpdateManyWithoutSchool_yearsNestedInput
    semesters?: semestersUncheckedUpdateManyWithoutSchool_yearsNestedInput
  }

  export type school_yearsCreateManyInput = {
    id?: Uint8Array
    name: string
    start_date: Date | string
    end_date: Date | string
  }

  export type school_yearsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type school_yearsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semestersCreateInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
    final_grades?: final_gradesCreateNestedManyWithoutSemestersInput
    school_years: school_yearsCreateNestedOneWithoutSemestersInput
  }

  export type semestersUncheckedCreateInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
    school_year_id: Uint8Array
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutSemestersInput
  }

  export type semestersUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    final_grades?: final_gradesUpdateManyWithoutSemestersNestedInput
    school_years?: school_yearsUpdateOneRequiredWithoutSemestersNestedInput
  }

  export type semestersUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    final_grades?: final_gradesUncheckedUpdateManyWithoutSemestersNestedInput
  }

  export type semestersCreateManyInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
    school_year_id: Uint8Array
  }

  export type semestersUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semestersUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type class_namesCreateInput = {
    id?: Uint8Array
    name: string
    classes?: classesCreateNestedManyWithoutClass_namesInput
  }

  export type class_namesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    classes?: classesUncheckedCreateNestedManyWithoutClass_namesInput
  }

  export type class_namesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    classes?: classesUpdateManyWithoutClass_namesNestedInput
  }

  export type class_namesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    classes?: classesUncheckedUpdateManyWithoutClass_namesNestedInput
  }

  export type class_namesCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type class_namesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type class_namesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type examsCreateInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type examsCreateManyInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
  }

  export type examsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
  }

  export type examsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
  }

  export type final_gradesCreateInput = {
    id?: Uint8Array
    grade: number
    students: studentsCreateNestedOneWithoutFinal_gradesInput
    subjects: subjectsCreateNestedOneWithoutFinal_gradesInput
    teachers: teachersCreateNestedOneWithoutFinal_gradesInput
    semesters: semestersCreateNestedOneWithoutFinal_gradesInput
  }

  export type final_gradesUncheckedCreateInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
    semester_id: Uint8Array
  }

  export type final_gradesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    students?: studentsUpdateOneRequiredWithoutFinal_gradesNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutFinal_gradesNestedInput
    teachers?: teachersUpdateOneRequiredWithoutFinal_gradesNestedInput
    semesters?: semestersUpdateOneRequiredWithoutFinal_gradesNestedInput
  }

  export type final_gradesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type final_gradesCreateManyInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
    semester_id: Uint8Array
  }

  export type final_gradesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
  }

  export type final_gradesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questionsCreateInput = {
    id?: Uint8Array
    content: string
    surveys: surveysCreateNestedOneWithoutQuestionsInput
    questions_types: questions_typesCreateNestedOneWithoutQuestionsInput
    questions_possible_responses?: questions_possible_responsesCreateNestedManyWithoutQuestionsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateInput = {
    id?: Uint8Array
    content: string
    survey_id: Uint8Array
    question_type_id: Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedCreateNestedManyWithoutQuestionsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    surveys?: surveysUpdateOneRequiredWithoutQuestionsNestedInput
    questions_types?: questions_typesUpdateOneRequiredWithoutQuestionsNestedInput
    questions_possible_responses?: questions_possible_responsesUpdateManyWithoutQuestionsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    survey_id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsCreateManyInput = {
    id?: Uint8Array
    content: string
    survey_id: Uint8Array
    question_type_id: Uint8Array
  }

  export type questionsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
  }

  export type questionsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    survey_id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_possible_responsesCreateInput = {
    id?: Uint8Array
    content: string
    questions: questionsCreateNestedOneWithoutQuestions_possible_responsesInput
  }

  export type questions_possible_responsesUncheckedCreateInput = {
    id?: Uint8Array
    content: string
    question_id: Uint8Array
  }

  export type questions_possible_responsesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    questions?: questionsUpdateOneRequiredWithoutQuestions_possible_responsesNestedInput
  }

  export type questions_possible_responsesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    question_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_possible_responsesCreateManyInput = {
    id?: Uint8Array
    content: string
    question_id: Uint8Array
  }

  export type questions_possible_responsesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
  }

  export type questions_possible_responsesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    question_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_responsesCreateInput = {
    id?: Uint8Array
    content: string
    students: studentsCreateNestedOneWithoutQuestions_responsesInput
    questions: questionsCreateNestedOneWithoutQuestions_responsesInput
  }

  export type questions_responsesUncheckedCreateInput = {
    id?: Uint8Array
    content: string
    student_id: Uint8Array
    question_id: Uint8Array
  }

  export type questions_responsesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    students?: studentsUpdateOneRequiredWithoutQuestions_responsesNestedInput
    questions?: questionsUpdateOneRequiredWithoutQuestions_responsesNestedInput
  }

  export type questions_responsesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_responsesCreateManyInput = {
    id?: Uint8Array
    content: string
    student_id: Uint8Array
    question_id: Uint8Array
  }

  export type questions_responsesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
  }

  export type questions_responsesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_typesCreateInput = {
    id?: Uint8Array
    name: string
    questions?: questionsCreateNestedManyWithoutQuestions_typesInput
  }

  export type questions_typesUncheckedCreateInput = {
    id?: Uint8Array
    name: string
    questions?: questionsUncheckedCreateNestedManyWithoutQuestions_typesInput
  }

  export type questions_typesUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    questions?: questionsUpdateManyWithoutQuestions_typesNestedInput
  }

  export type questions_typesUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    questions?: questionsUncheckedUpdateManyWithoutQuestions_typesNestedInput
  }

  export type questions_typesCreateManyInput = {
    id?: Uint8Array
    name: string
  }

  export type questions_typesUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type questions_typesUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type attempt_questionsCreateInput = {
    id: Uint8Array
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
    attempts: attemptsCreateNestedOneWithoutAttempt_questionsInput
    open_questions?: open_questionsCreateNestedOneWithoutAttempt_questionsInput
    closed_questions?: closed_questionsCreateNestedOneWithoutAttempt_questionsInput
  }

  export type attempt_questionsUncheckedCreateInput = {
    id: Uint8Array
    attempt_id: Uint8Array
    open_question_id?: Uint8Array | null
    closed_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type attempt_questionsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateOneRequiredWithoutAttempt_questionsNestedInput
    open_questions?: open_questionsUpdateOneWithoutAttempt_questionsNestedInput
    closed_questions?: closed_questionsUpdateOneWithoutAttempt_questionsNestedInput
  }

  export type attempt_questionsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    closed_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attempt_questionsCreateManyInput = {
    id: Uint8Array
    attempt_id: Uint8Array
    open_question_id?: Uint8Array | null
    closed_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type attempt_questionsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attempt_questionsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    closed_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attemptsCreateInput = {
    id?: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsCreateNestedManyWithoutAttemptsInput
    students: studentsCreateNestedOneWithoutAttemptsInput
    exams: examsCreateNestedOneWithoutAttemptsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsUncheckedCreateInput = {
    id?: Uint8Array
    student_id: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutAttemptsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUpdateManyWithoutAttemptsNestedInput
    students?: studentsUpdateOneRequiredWithoutAttemptsNestedInput
    exams?: examsUpdateOneRequiredWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsCreateManyInput = {
    id?: Uint8Array
    student_id: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
  }

  export type attemptsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attemptsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classes_examsCreateInput = {
    classes: classesCreateNestedOneWithoutClasses_examsInput
    exams: examsCreateNestedOneWithoutClasses_examsInput
  }

  export type classes_examsUncheckedCreateInput = {
    class_id: Uint8Array
    exam_id: Uint8Array
  }

  export type classes_examsUpdateInput = {
    classes?: classesUpdateOneRequiredWithoutClasses_examsNestedInput
    exams?: examsUpdateOneRequiredWithoutClasses_examsNestedInput
  }

  export type classes_examsUncheckedUpdateInput = {
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classes_examsCreateManyInput = {
    class_id: Uint8Array
    exam_id: Uint8Array
  }

  export type classes_examsUpdateManyMutationInput = {

  }

  export type classes_examsUncheckedUpdateManyInput = {
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type closed_answersCreateInput = {
    id?: Uint8Array
    is_correct?: boolean | null
    description: string
    closed_questions: closed_questionsCreateNestedOneWithoutClosed_answersInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutClosed_answersInput
  }

  export type closed_answersUncheckedCreateInput = {
    id?: Uint8Array
    closed_question_id: Uint8Array
    is_correct?: boolean | null
    description: string
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutClosed_answersInput
  }

  export type closed_answersUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    closed_questions?: closed_questionsUpdateOneRequiredWithoutClosed_answersNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutClosed_answersNestedInput
  }

  export type closed_answersUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutClosed_answersNestedInput
  }

  export type closed_answersCreateManyInput = {
    id?: Uint8Array
    closed_question_id: Uint8Array
    is_correct?: boolean | null
    description: string
  }

  export type closed_answersUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type closed_answersUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type closed_questionsCreateInput = {
    id?: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsCreateNestedManyWithoutClosed_questionsInput
    closed_answers?: closed_answersCreateNestedManyWithoutClosed_questionsInput
    exams: examsCreateNestedOneWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsUncheckedCreateInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutClosed_questionsInput
    closed_answers?: closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUpdateManyWithoutClosed_questionsNestedInput
    closed_answers?: closed_answersUpdateManyWithoutClosed_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutClosed_questionsNestedInput
  }

  export type closed_questionsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutClosed_questionsNestedInput
    closed_answers?: closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
  }

  export type closed_questionsCreateManyInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
  }

  export type closed_questionsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type closed_questionsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type files_repositoryCreateInput = {
    id?: Uint8Array
    title: string
    description: string
    file: Uint8Array
    exams: examsCreateNestedOneWithoutFiles_repositoryInput
  }

  export type files_repositoryUncheckedCreateInput = {
    id?: Uint8Array
    title: string
    description: string
    file: Uint8Array
    exam_id: Uint8Array
  }

  export type files_repositoryUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    file?: BytesFieldUpdateOperationsInput | Uint8Array
    exams?: examsUpdateOneRequiredWithoutFiles_repositoryNestedInput
  }

  export type files_repositoryUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    file?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type files_repositoryCreateManyInput = {
    id?: Uint8Array
    title: string
    description: string
    file: Uint8Array
    exam_id: Uint8Array
  }

  export type files_repositoryUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    file?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type files_repositoryUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    file?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type gradebook_examsCreateInput = {
    id?: Uint8Array
    topic: string
    scope: string
    lessons: lessonsCreateNestedOneWithoutGradebook_examsInput
  }

  export type gradebook_examsUncheckedCreateInput = {
    id?: Uint8Array
    topic: string
    scope: string
    lesson_id: Uint8Array
  }

  export type gradebook_examsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    topic?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    lessons?: lessonsUpdateOneRequiredWithoutGradebook_examsNestedInput
  }

  export type gradebook_examsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    topic?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type gradebook_examsCreateManyInput = {
    id?: Uint8Array
    topic: string
    scope: string
    lesson_id: Uint8Array
  }

  export type gradebook_examsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    topic?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type gradebook_examsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    topic?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_examsCreateInput = {
    id?: Uint8Array
    attempt_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
    students: studentsCreateNestedOneWithoutGrades_examsInput
    exams: examsCreateNestedOneWithoutGrades_examsInput
  }

  export type grades_examsUncheckedCreateInput = {
    id?: Uint8Array
    student_id: Uint8Array
    attempt_id: Uint8Array
    exam_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
  }

  export type grades_examsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutGrades_examsNestedInput
    exams?: examsUpdateOneRequiredWithoutGrades_examsNestedInput
  }

  export type grades_examsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grades_examsCreateManyInput = {
    id?: Uint8Array
    student_id: Uint8Array
    attempt_id: Uint8Array
    exam_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
  }

  export type grades_examsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grades_examsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grading_scaleCreateInput = {
    id?: Uint8Array
    min_score: number
    max_score: number
    grades: string
  }

  export type grading_scaleUncheckedCreateInput = {
    id?: Uint8Array
    min_score: number
    max_score: number
    grades: string
  }

  export type grading_scaleUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    min_score?: IntFieldUpdateOperationsInput | number
    max_score?: IntFieldUpdateOperationsInput | number
    grades?: StringFieldUpdateOperationsInput | string
  }

  export type grading_scaleUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    min_score?: IntFieldUpdateOperationsInput | number
    max_score?: IntFieldUpdateOperationsInput | number
    grades?: StringFieldUpdateOperationsInput | string
  }

  export type grading_scaleCreateManyInput = {
    id?: Uint8Array
    min_score: number
    max_score: number
    grades: string
  }

  export type grading_scaleUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    min_score?: IntFieldUpdateOperationsInput | number
    max_score?: IntFieldUpdateOperationsInput | number
    grades?: StringFieldUpdateOperationsInput | string
  }

  export type grading_scaleUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    min_score?: IntFieldUpdateOperationsInput | number
    max_score?: IntFieldUpdateOperationsInput | number
    grades?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsCreateInput = {
    id?: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
    students: studentsCreateNestedOneWithoutNotificationsInput
    exams?: examsCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: Uint8Array
    student_id: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
    exam_id?: Uint8Array | null
  }

  export type notificationsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    students?: studentsUpdateOneRequiredWithoutNotificationsNestedInput
    exams?: examsUpdateOneWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    exam_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type notificationsCreateManyInput = {
    id?: Uint8Array
    student_id: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
    exam_id?: Uint8Array | null
  }

  export type notificationsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    exam_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type open_answersCreateInput = {
    id?: Uint8Array
    description: string
    open_questions: open_questionsCreateNestedOneWithoutOpen_answersInput
  }

  export type open_answersUncheckedCreateInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    description: string
  }

  export type open_answersUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    open_questions?: open_questionsUpdateOneRequiredWithoutOpen_answersNestedInput
  }

  export type open_answersUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
  }

  export type open_answersCreateManyInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    description: string
  }

  export type open_answersUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
  }

  export type open_answersUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
  }

  export type open_questionsCreateInput = {
    id?: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsCreateNestedManyWithoutOpen_questionsInput
    open_answers?: open_answersCreateNestedManyWithoutOpen_questionsInput
    exams: examsCreateNestedOneWithoutOpen_questionsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsUncheckedCreateInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutOpen_questionsInput
    open_answers?: open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUpdateManyWithoutOpen_questionsNestedInput
    open_answers?: open_answersUpdateManyWithoutOpen_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutOpen_questionsNestedInput
  }

  export type open_questionsUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutOpen_questionsNestedInput
    open_answers?: open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
  }

  export type open_questionsCreateManyInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
  }

  export type open_questionsUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
  }

  export type open_questionsUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
  }

  export type student_closed_answersCreateInput = {
    id?: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
    students: studentsCreateNestedOneWithoutStudent_closed_answersInput
    closed_questions: closed_questionsCreateNestedOneWithoutStudent_closed_answersInput
    closed_answers: closed_answersCreateNestedOneWithoutStudent_closed_answersInput
    attempts: attemptsCreateNestedOneWithoutStudent_closed_answersInput
  }

  export type student_closed_answersUncheckedCreateInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_question_id: Uint8Array
    closed_answer_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_closed_answersUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    closed_questions?: closed_questionsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    closed_answers?: closed_answersUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    attempts?: attemptsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
  }

  export type student_closed_answersUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_closed_answersCreateManyInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_question_id: Uint8Array
    closed_answer_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_closed_answersUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_closed_answersUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_open_answersCreateInput = {
    id?: Uint8Array
    score?: number | null
    date_time?: Date | string | null
    description?: string | null
    open_questions: open_questionsCreateNestedOneWithoutStudent_open_answersInput
    students: studentsCreateNestedOneWithoutStudent_open_answersInput
    attempts: attemptsCreateNestedOneWithoutStudent_open_answersInput
  }

  export type student_open_answersUncheckedCreateInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    score?: number | null
    student_id: Uint8Array
    attempt_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type student_open_answersUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    open_questions?: open_questionsUpdateOneRequiredWithoutStudent_open_answersNestedInput
    students?: studentsUpdateOneRequiredWithoutStudent_open_answersNestedInput
    attempts?: attemptsUpdateOneRequiredWithoutStudent_open_answersNestedInput
  }

  export type student_open_answersUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_open_answersCreateManyInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    score?: number | null
    student_id: Uint8Array
    attempt_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type student_open_answersUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_open_answersUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type students_examsCreateInput = {
    students: studentsCreateNestedOneWithoutStudents_examsInput
    exams: examsCreateNestedOneWithoutStudents_examsInput
  }

  export type students_examsUncheckedCreateInput = {
    students_id: Uint8Array
    exam_id: Uint8Array
  }

  export type students_examsUpdateInput = {
    students?: studentsUpdateOneRequiredWithoutStudents_examsNestedInput
    exams?: examsUpdateOneRequiredWithoutStudents_examsNestedInput
  }

  export type students_examsUncheckedUpdateInput = {
    students_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type students_examsCreateManyInput = {
    students_id: Uint8Array
    exam_id: Uint8Array
  }

  export type students_examsUpdateManyMutationInput = {

  }

  export type students_examsUncheckedUpdateManyInput = {
    students_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StudentsScalarRelationFilter = {
    is?: studentsWhereInput
    isNot?: studentsWhereInput
  }

  export type LessonsScalarRelationFilter = {
    is?: lessonsWhereInput
    isNot?: lessonsWhereInput
  }

  export type attendancesStudent_idLesson_idCompoundUniqueInput = {
    student_id: Uint8Array
    lesson_id: Uint8Array
  }

  export type attendancesCountOrderByAggregateInput = {
    id?: SortOrder
    date_time?: SortOrder
    was_present?: SortOrder
    was_late?: SortOrder
    was_excused?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type attendancesMaxOrderByAggregateInput = {
    id?: SortOrder
    date_time?: SortOrder
    was_present?: SortOrder
    was_late?: SortOrder
    was_excused?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type attendancesMinOrderByAggregateInput = {
    id?: SortOrder
    date_time?: SortOrder
    was_present?: SortOrder
    was_late?: SortOrder
    was_excused?: SortOrder
    student_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Badges_categoriesScalarRelationFilter = {
    is?: badges_categoriesWhereInput
    isNot?: badges_categoriesWhereInput
  }

  export type Badges_historyListRelationFilter = {
    every?: badges_historyWhereInput
    some?: badges_historyWhereInput
    none?: badges_historyWhereInput
  }

  export type badges_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type badgesOrderByRelevanceInput = {
    fields: badgesOrderByRelevanceFieldEnum | badgesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type badgesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
  }

  export type badgesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
  }

  export type badgesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BadgesListRelationFilter = {
    every?: badgesWhereInput
    some?: badgesWhereInput
    none?: badgesWhereInput
  }

  export type badgesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type badges_categoriesOrderByRelevanceInput = {
    fields: badges_categoriesOrderByRelevanceFieldEnum | badges_categoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type badges_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type badges_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type badges_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BadgesScalarRelationFilter = {
    is?: badgesWhereInput
    isNot?: badgesWhereInput
  }

  export type badges_historyCountOrderByAggregateInput = {
    id?: SortOrder
    date_awarded?: SortOrder
    student_id?: SortOrder
    badge_id?: SortOrder
  }

  export type badges_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    date_awarded?: SortOrder
    student_id?: SortOrder
    badge_id?: SortOrder
  }

  export type badges_historyMinOrderByAggregateInput = {
    id?: SortOrder
    date_awarded?: SortOrder
    student_id?: SortOrder
    badge_id?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type Class_namesScalarRelationFilter = {
    is?: class_namesWhereInput
    isNot?: class_namesWhereInput
  }

  export type School_yearsScalarRelationFilter = {
    is?: school_yearsWhereInput
    isNot?: school_yearsWhereInput
  }

  export type TeachersNullableScalarRelationFilter = {
    is?: teachersWhereInput | null
    isNot?: teachersWhereInput | null
  }

  export type Classes_examsListRelationFilter = {
    every?: classes_examsWhereInput
    some?: classes_examsWhereInput
    none?: classes_examsWhereInput
  }

  export type LessonsListRelationFilter = {
    every?: lessonsWhereInput
    some?: lessonsWhereInput
    none?: lessonsWhereInput
  }

  export type StudentsListRelationFilter = {
    every?: studentsWhereInput
    some?: studentsWhereInput
    none?: studentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type classes_examsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lessonsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type classesClass_name_idSchool_year_idCompoundUniqueInput = {
    class_name_id: Uint8Array
    school_year_id: Uint8Array
  }

  export type classesCountOrderByAggregateInput = {
    id?: SortOrder
    class_name_id?: SortOrder
    school_year_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type classesMaxOrderByAggregateInput = {
    id?: SortOrder
    class_name_id?: SortOrder
    school_year_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type classesMinOrderByAggregateInput = {
    id?: SortOrder
    class_name_id?: SortOrder
    school_year_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type School_eventsListRelationFilter = {
    every?: school_eventsWhereInput
    some?: school_eventsWhereInput
    none?: school_eventsWhereInput
  }

  export type school_eventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type event_typesOrderByRelevanceInput = {
    fields: event_typesOrderByRelevanceFieldEnum | event_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type event_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type event_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type event_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SubjectsScalarRelationFilter = {
    is?: subjectsWhereInput
    isNot?: subjectsWhereInput
  }

  export type TeachersScalarRelationFilter = {
    is?: teachersWhereInput
    isNot?: teachersWhereInput
  }

  export type grades_gradebookOrderByRelevanceInput = {
    fields: grades_gradebookOrderByRelevanceFieldEnum | grades_gradebookOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type grades_gradebookCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    weight?: SortOrder
    date_given?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type grades_gradebookAvgOrderByAggregateInput = {
    grade?: SortOrder
    weight?: SortOrder
  }

  export type grades_gradebookMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    weight?: SortOrder
    date_given?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type grades_gradebookMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    weight?: SortOrder
    date_given?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
  }

  export type grades_gradebookSumOrderByAggregateInput = {
    grade?: SortOrder
    weight?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type homeworksOrderByRelevanceInput = {
    fields: homeworksOrderByRelevanceFieldEnum | homeworksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type homeworksCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    lesson_id?: SortOrder
  }

  export type homeworksMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    lesson_id?: SortOrder
  }

  export type homeworksMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    deadline?: SortOrder
    lesson_id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AttendancesListRelationFilter = {
    every?: attendancesWhereInput
    some?: attendancesWhereInput
    none?: attendancesWhereInput
  }

  export type ExamsListRelationFilter = {
    every?: examsWhereInput
    some?: examsWhereInput
    none?: examsWhereInput
  }

  export type Gradebook_examsListRelationFilter = {
    every?: gradebook_examsWhereInput
    some?: gradebook_examsWhereInput
    none?: gradebook_examsWhereInput
  }

  export type HomeworksNullableScalarRelationFilter = {
    is?: homeworksWhereInput | null
    isNot?: homeworksWhereInput | null
  }

  export type ClassesScalarRelationFilter = {
    is?: classesWhereInput
    isNot?: classesWhereInput
  }

  export type attendancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gradebook_examsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lessonsOrderByRelevanceInput = {
    fields: lessonsOrderByRelevanceFieldEnum | lessonsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type lessonsCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
  }

  export type lessonsMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
  }

  export type lessonsMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    teacher_id?: SortOrder
    class_id?: SortOrder
    subject_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type User_typesScalarRelationFilter = {
    is?: user_typesWhereInput
    isNot?: user_typesWhereInput
  }

  export type messagesOrderByRelevanceInput = {
    fields: messagesOrderByRelevanceFieldEnum | messagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type messagesCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    date_time?: SortOrder
    was_read?: SortOrder
    sender_id?: SortOrder
    sender_type_id?: SortOrder
    receiver_id?: SortOrder
    receiver_type_id?: SortOrder
  }

  export type messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    date_time?: SortOrder
    was_read?: SortOrder
    sender_id?: SortOrder
    sender_type_id?: SortOrder
    receiver_id?: SortOrder
    receiver_type_id?: SortOrder
  }

  export type messagesMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    date_time?: SortOrder
    was_read?: SortOrder
    sender_id?: SortOrder
    sender_type_id?: SortOrder
    receiver_id?: SortOrder
    receiver_type_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Students_parentsListRelationFilter = {
    every?: students_parentsWhereInput
    some?: students_parentsWhereInput
    none?: students_parentsWhereInput
  }

  export type students_parentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parentsOrderByRelevanceInput = {
    fields: parentsOrderByRelevanceFieldEnum | parentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type parentsCountOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type parentsMaxOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type parentsMinOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Problems_gradebookListRelationFilter = {
    every?: problems_gradebookWhereInput
    some?: problems_gradebookWhereInput
    none?: problems_gradebookWhereInput
  }

  export type problems_gradebookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type problem_typesOrderByRelevanceInput = {
    fields: problem_typesOrderByRelevanceFieldEnum | problem_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type problem_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type problem_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type problem_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type Problem_typesScalarRelationFilter = {
    is?: problem_typesWhereInput
    isNot?: problem_typesWhereInput
  }

  export type StatusesScalarRelationFilter = {
    is?: statusesWhereInput
    isNot?: statusesWhereInput
  }

  export type problems_gradebookOrderByRelevanceInput = {
    fields: problems_gradebookOrderByRelevanceFieldEnum | problems_gradebookOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type problems_gradebookCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    reported_time?: SortOrder
    problem_type_id?: SortOrder
    reporter_id?: SortOrder
    user_type_id?: SortOrder
    status_id?: SortOrder
  }

  export type problems_gradebookMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    reported_time?: SortOrder
    problem_type_id?: SortOrder
    reporter_id?: SortOrder
    user_type_id?: SortOrder
    status_id?: SortOrder
  }

  export type problems_gradebookMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    reported_time?: SortOrder
    problem_type_id?: SortOrder
    reporter_id?: SortOrder
    user_type_id?: SortOrder
    status_id?: SortOrder
  }

  export type Event_typesScalarRelationFilter = {
    is?: event_typesWhereInput
    isNot?: event_typesWhereInput
  }

  export type school_eventsOrderByRelevanceInput = {
    fields: school_eventsOrderByRelevanceFieldEnum | school_eventsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type school_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    event_type_id?: SortOrder
  }

  export type school_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    event_type_id?: SortOrder
  }

  export type school_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    description?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    event_type_id?: SortOrder
  }

  export type statusesOrderByRelevanceInput = {
    fields: statusesOrderByRelevanceFieldEnum | statusesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type statusesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type statusesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type statusesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AttemptsListRelationFilter = {
    every?: attemptsWhereInput
    some?: attemptsWhereInput
    none?: attemptsWhereInput
  }

  export type Final_gradesListRelationFilter = {
    every?: final_gradesWhereInput
    some?: final_gradesWhereInput
    none?: final_gradesWhereInput
  }

  export type Grades_examsListRelationFilter = {
    every?: grades_examsWhereInput
    some?: grades_examsWhereInput
    none?: grades_examsWhereInput
  }

  export type Grades_gradebookListRelationFilter = {
    every?: grades_gradebookWhereInput
    some?: grades_gradebookWhereInput
    none?: grades_gradebookWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type Questions_responsesListRelationFilter = {
    every?: questions_responsesWhereInput
    some?: questions_responsesWhereInput
    none?: questions_responsesWhereInput
  }

  export type Student_closed_answersListRelationFilter = {
    every?: student_closed_answersWhereInput
    some?: student_closed_answersWhereInput
    none?: student_closed_answersWhereInput
  }

  export type Student_open_answersListRelationFilter = {
    every?: student_open_answersWhereInput
    some?: student_open_answersWhereInput
    none?: student_open_answersWhereInput
  }

  export type ClassesNullableScalarRelationFilter = {
    is?: classesWhereInput | null
    isNot?: classesWhereInput | null
  }

  export type Students_examsListRelationFilter = {
    every?: students_examsWhereInput
    some?: students_examsWhereInput
    none?: students_examsWhereInput
  }

  export type attemptsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type final_gradesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type grades_examsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type grades_gradebookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questions_responsesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_closed_answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_open_answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type students_examsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsOrderByRelevanceInput = {
    fields: studentsOrderByRelevanceFieldEnum | studentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type studentsCountOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
    class_id?: SortOrder
  }

  export type studentsMaxOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
    class_id?: SortOrder
  }

  export type studentsMinOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
    class_id?: SortOrder
  }

  export type ParentsScalarRelationFilter = {
    is?: parentsWhereInput
    isNot?: parentsWhereInput
  }

  export type students_parentsStudent_idParent_idCompoundUniqueInput = {
    student_id: Uint8Array
    parent_id: Uint8Array
  }

  export type students_parentsCountOrderByAggregateInput = {
    student_id?: SortOrder
    parent_id?: SortOrder
  }

  export type students_parentsMaxOrderByAggregateInput = {
    student_id?: SortOrder
    parent_id?: SortOrder
  }

  export type students_parentsMinOrderByAggregateInput = {
    student_id?: SortOrder
    parent_id?: SortOrder
  }

  export type Teachers_subjectsListRelationFilter = {
    every?: teachers_subjectsWhereInput
    some?: teachers_subjectsWhereInput
    none?: teachers_subjectsWhereInput
  }

  export type teachers_subjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectsOrderByRelevanceInput = {
    fields: subjectsOrderByRelevanceFieldEnum | subjectsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subjectsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type subjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type subjectsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type QuestionsListRelationFilter = {
    every?: questionsWhereInput
    some?: questionsWhereInput
    none?: questionsWhereInput
  }

  export type questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type surveysOrderByRelevanceInput = {
    fields: surveysOrderByRelevanceFieldEnum | surveysOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type surveysCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type surveysMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type surveysMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type ClassesListRelationFilter = {
    every?: classesWhereInput
    some?: classesWhereInput
    none?: classesWhereInput
  }

  export type classesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teachersOrderByRelevanceInput = {
    fields: teachersOrderByRelevanceFieldEnum | teachersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type teachersCountOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type teachersMaxOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type teachersMinOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type teachers_subjectsTeacher_idSubject_idCompoundUniqueInput = {
    teacher_id: Uint8Array
    subject_id: Uint8Array
  }

  export type teachers_subjectsCountOrderByAggregateInput = {
    teacher_id?: SortOrder
    subject_id?: SortOrder
  }

  export type teachers_subjectsMaxOrderByAggregateInput = {
    teacher_id?: SortOrder
    subject_id?: SortOrder
  }

  export type teachers_subjectsMinOrderByAggregateInput = {
    teacher_id?: SortOrder
    subject_id?: SortOrder
  }

  export type updatesOrderByRelevanceInput = {
    fields: updatesOrderByRelevanceFieldEnum | updatesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type updatesCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    version?: SortOrder
    release_time?: SortOrder
  }

  export type updatesMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    version?: SortOrder
    release_time?: SortOrder
  }

  export type updatesMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    version?: SortOrder
    release_time?: SortOrder
  }

  export type administratorsOrderByRelevanceInput = {
    fields: administratorsOrderByRelevanceFieldEnum | administratorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type administratorsCountOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type administratorsMaxOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type administratorsMinOrderByAggregateInput = {
    id?: SortOrder
    pesel?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    reset_password_token?: SortOrder
    reset_password_expires?: SortOrder
  }

  export type MessagesListRelationFilter = {
    every?: messagesWhereInput
    some?: messagesWhereInput
    none?: messagesWhereInput
  }

  export type messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_typesOrderByRelevanceInput = {
    fields: user_typesOrderByRelevanceFieldEnum | user_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type user_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type user_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SemestersListRelationFilter = {
    every?: semestersWhereInput
    some?: semestersWhereInput
    none?: semestersWhereInput
  }

  export type semestersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type school_yearsOrderByRelevanceInput = {
    fields: school_yearsOrderByRelevanceFieldEnum | school_yearsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type school_yearsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type school_yearsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type school_yearsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
  }

  export type semestersSemesterSchool_year_idCompoundUniqueInput = {
    semester: number
    school_year_id: Uint8Array
  }

  export type semestersCountOrderByAggregateInput = {
    id?: SortOrder
    semester?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    school_year_id?: SortOrder
  }

  export type semestersAvgOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type semestersMaxOrderByAggregateInput = {
    id?: SortOrder
    semester?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    school_year_id?: SortOrder
  }

  export type semestersMinOrderByAggregateInput = {
    id?: SortOrder
    semester?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    school_year_id?: SortOrder
  }

  export type semestersSumOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type class_namesOrderByRelevanceInput = {
    fields: class_namesOrderByRelevanceFieldEnum | class_namesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type class_namesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type class_namesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type class_namesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Closed_questionsListRelationFilter = {
    every?: closed_questionsWhereInput
    some?: closed_questionsWhereInput
    none?: closed_questionsWhereInput
  }

  export type Files_repositoryListRelationFilter = {
    every?: files_repositoryWhereInput
    some?: files_repositoryWhereInput
    none?: files_repositoryWhereInput
  }

  export type Open_questionsListRelationFilter = {
    every?: open_questionsWhereInput
    some?: open_questionsWhereInput
    none?: open_questionsWhereInput
  }

  export type closed_questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type files_repositoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type open_questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examsOrderByRelevanceInput = {
    fields: examsOrderByRelevanceFieldEnum | examsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type examsCountOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    start_date_time?: SortOrder
    end_date_time?: SortOrder
    visibility?: SortOrder
    number_of_questions?: SortOrder
    duration?: SortOrder
    teacher_id?: SortOrder
    description?: SortOrder
    number_of_tries?: SortOrder
    multiple_tries?: SortOrder
    time_limit_for_each_question?: SortOrder
    randomise_questions?: SortOrder
    end_test_after_leaving_window?: SortOrder
    block_copying_pasting?: SortOrder
    randomise_answers?: SortOrder
    latest_attempt_counts?: SortOrder
    best_attempt_counts?: SortOrder
    hide_results?: SortOrder
    display_points_per_question?: SortOrder
    show_correct_answers?: SortOrder
    allow_navigation?: SortOrder
    allow_review?: SortOrder
  }

  export type examsAvgOrderByAggregateInput = {
    number_of_questions?: SortOrder
    duration?: SortOrder
    number_of_tries?: SortOrder
  }

  export type examsMaxOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    start_date_time?: SortOrder
    end_date_time?: SortOrder
    visibility?: SortOrder
    number_of_questions?: SortOrder
    duration?: SortOrder
    teacher_id?: SortOrder
    description?: SortOrder
    number_of_tries?: SortOrder
    multiple_tries?: SortOrder
    time_limit_for_each_question?: SortOrder
    randomise_questions?: SortOrder
    end_test_after_leaving_window?: SortOrder
    block_copying_pasting?: SortOrder
    randomise_answers?: SortOrder
    latest_attempt_counts?: SortOrder
    best_attempt_counts?: SortOrder
    hide_results?: SortOrder
    display_points_per_question?: SortOrder
    show_correct_answers?: SortOrder
    allow_navigation?: SortOrder
    allow_review?: SortOrder
  }

  export type examsMinOrderByAggregateInput = {
    id?: SortOrder
    lesson_id?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    start_date_time?: SortOrder
    end_date_time?: SortOrder
    visibility?: SortOrder
    number_of_questions?: SortOrder
    duration?: SortOrder
    teacher_id?: SortOrder
    description?: SortOrder
    number_of_tries?: SortOrder
    multiple_tries?: SortOrder
    time_limit_for_each_question?: SortOrder
    randomise_questions?: SortOrder
    end_test_after_leaving_window?: SortOrder
    block_copying_pasting?: SortOrder
    randomise_answers?: SortOrder
    latest_attempt_counts?: SortOrder
    best_attempt_counts?: SortOrder
    hide_results?: SortOrder
    display_points_per_question?: SortOrder
    show_correct_answers?: SortOrder
    allow_navigation?: SortOrder
    allow_review?: SortOrder
  }

  export type examsSumOrderByAggregateInput = {
    number_of_questions?: SortOrder
    duration?: SortOrder
    number_of_tries?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SemestersScalarRelationFilter = {
    is?: semestersWhereInput
    isNot?: semestersWhereInput
  }

  export type final_gradesCountOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
    semester_id?: SortOrder
  }

  export type final_gradesAvgOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type final_gradesMaxOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
    semester_id?: SortOrder
  }

  export type final_gradesMinOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    student_id?: SortOrder
    subject_id?: SortOrder
    teacher_id?: SortOrder
    semester_id?: SortOrder
  }

  export type final_gradesSumOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type SurveysScalarRelationFilter = {
    is?: surveysWhereInput
    isNot?: surveysWhereInput
  }

  export type Questions_typesScalarRelationFilter = {
    is?: questions_typesWhereInput
    isNot?: questions_typesWhereInput
  }

  export type Questions_possible_responsesListRelationFilter = {
    every?: questions_possible_responsesWhereInput
    some?: questions_possible_responsesWhereInput
    none?: questions_possible_responsesWhereInput
  }

  export type questions_possible_responsesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionsOrderByRelevanceInput = {
    fields: questionsOrderByRelevanceFieldEnum | questionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type questionsCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    survey_id?: SortOrder
    question_type_id?: SortOrder
  }

  export type questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    survey_id?: SortOrder
    question_type_id?: SortOrder
  }

  export type questionsMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    survey_id?: SortOrder
    question_type_id?: SortOrder
  }

  export type QuestionsScalarRelationFilter = {
    is?: questionsWhereInput
    isNot?: questionsWhereInput
  }

  export type questions_possible_responsesOrderByRelevanceInput = {
    fields: questions_possible_responsesOrderByRelevanceFieldEnum | questions_possible_responsesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type questions_possible_responsesCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    question_id?: SortOrder
  }

  export type questions_possible_responsesMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    question_id?: SortOrder
  }

  export type questions_possible_responsesMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    question_id?: SortOrder
  }

  export type questions_responsesOrderByRelevanceInput = {
    fields: questions_responsesOrderByRelevanceFieldEnum | questions_responsesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type questions_responsesStudent_idQuestion_idCompoundUniqueInput = {
    student_id: Uint8Array
    question_id: Uint8Array
  }

  export type questions_responsesCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    student_id?: SortOrder
    question_id?: SortOrder
  }

  export type questions_responsesMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    student_id?: SortOrder
    question_id?: SortOrder
  }

  export type questions_responsesMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    student_id?: SortOrder
    question_id?: SortOrder
  }

  export type questions_typesOrderByRelevanceInput = {
    fields: questions_typesOrderByRelevanceFieldEnum | questions_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type questions_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type questions_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type questions_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type Enumattempt_questions_question_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.attempt_questions_question_type | Enumattempt_questions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.attempt_questions_question_type[]
    notIn?: $Enums.attempt_questions_question_type[]
    not?: NestedEnumattempt_questions_question_typeFilter<$PrismaModel> | $Enums.attempt_questions_question_type
  }

  export type AttemptsScalarRelationFilter = {
    is?: attemptsWhereInput
    isNot?: attemptsWhereInput
  }

  export type Open_questionsNullableScalarRelationFilter = {
    is?: open_questionsWhereInput | null
    isNot?: open_questionsWhereInput | null
  }

  export type Closed_questionsNullableScalarRelationFilter = {
    is?: closed_questionsWhereInput | null
    isNot?: closed_questionsWhereInput | null
  }

  export type attempt_questionsCountOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    open_question_id?: SortOrder
    closed_question_id?: SortOrder
    question_type?: SortOrder
    created_at?: SortOrder
  }

  export type attempt_questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    open_question_id?: SortOrder
    closed_question_id?: SortOrder
    question_type?: SortOrder
    created_at?: SortOrder
  }

  export type attempt_questionsMinOrderByAggregateInput = {
    id?: SortOrder
    attempt_id?: SortOrder
    open_question_id?: SortOrder
    closed_question_id?: SortOrder
    question_type?: SortOrder
    created_at?: SortOrder
  }

  export type Enumattempt_questions_question_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attempt_questions_question_type | Enumattempt_questions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.attempt_questions_question_type[]
    notIn?: $Enums.attempt_questions_question_type[]
    not?: NestedEnumattempt_questions_question_typeWithAggregatesFilter<$PrismaModel> | $Enums.attempt_questions_question_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumattempt_questions_question_typeFilter<$PrismaModel>
    _max?: NestedEnumattempt_questions_question_typeFilter<$PrismaModel>
  }

  export type Attempt_questionsListRelationFilter = {
    every?: attempt_questionsWhereInput
    some?: attempt_questionsWhereInput
    none?: attempt_questionsWhereInput
  }

  export type ExamsScalarRelationFilter = {
    is?: examsWhereInput
    isNot?: examsWhereInput
  }

  export type attempt_questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type attemptsStudent_idExam_idAttempt_numberCompoundUniqueInput = {
    student_id: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
  }

  export type attemptsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    attempt_number?: SortOrder
    total_score?: SortOrder
    max_score?: SortOrder
    graded?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type attemptsAvgOrderByAggregateInput = {
    attempt_number?: SortOrder
    total_score?: SortOrder
    max_score?: SortOrder
  }

  export type attemptsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    attempt_number?: SortOrder
    total_score?: SortOrder
    max_score?: SortOrder
    graded?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type attemptsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    attempt_number?: SortOrder
    total_score?: SortOrder
    max_score?: SortOrder
    graded?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type attemptsSumOrderByAggregateInput = {
    attempt_number?: SortOrder
    total_score?: SortOrder
    max_score?: SortOrder
  }

  export type classes_examsClass_idExam_idCompoundUniqueInput = {
    class_id: Uint8Array
    exam_id: Uint8Array
  }

  export type classes_examsCountOrderByAggregateInput = {
    class_id?: SortOrder
    exam_id?: SortOrder
  }

  export type classes_examsMaxOrderByAggregateInput = {
    class_id?: SortOrder
    exam_id?: SortOrder
  }

  export type classes_examsMinOrderByAggregateInput = {
    class_id?: SortOrder
    exam_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Closed_questionsScalarRelationFilter = {
    is?: closed_questionsWhereInput
    isNot?: closed_questionsWhereInput
  }

  export type closed_answersOrderByRelevanceInput = {
    fields: closed_answersOrderByRelevanceFieldEnum | closed_answersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type closed_answersCountOrderByAggregateInput = {
    id?: SortOrder
    closed_question_id?: SortOrder
    is_correct?: SortOrder
    description?: SortOrder
  }

  export type closed_answersMaxOrderByAggregateInput = {
    id?: SortOrder
    closed_question_id?: SortOrder
    is_correct?: SortOrder
    description?: SortOrder
  }

  export type closed_answersMinOrderByAggregateInput = {
    id?: SortOrder
    closed_question_id?: SortOrder
    is_correct?: SortOrder
    description?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Closed_answersListRelationFilter = {
    every?: closed_answersWhereInput
    some?: closed_answersWhereInput
    none?: closed_answersWhereInput
  }

  export type closed_answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type closed_questionsOrderByRelevanceInput = {
    fields: closed_questionsOrderByRelevanceFieldEnum | closed_questionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type closed_questionsCountOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    score?: SortOrder
    is_multiple?: SortOrder
    description?: SortOrder
  }

  export type closed_questionsAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type closed_questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    score?: SortOrder
    is_multiple?: SortOrder
    description?: SortOrder
  }

  export type closed_questionsMinOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    score?: SortOrder
    is_multiple?: SortOrder
    description?: SortOrder
  }

  export type closed_questionsSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type files_repositoryOrderByRelevanceInput = {
    fields: files_repositoryOrderByRelevanceFieldEnum | files_repositoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type files_repositoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    exam_id?: SortOrder
  }

  export type files_repositoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    exam_id?: SortOrder
  }

  export type files_repositoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file?: SortOrder
    exam_id?: SortOrder
  }

  export type gradebook_examsOrderByRelevanceInput = {
    fields: gradebook_examsOrderByRelevanceFieldEnum | gradebook_examsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type gradebook_examsCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    lesson_id?: SortOrder
  }

  export type gradebook_examsMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    lesson_id?: SortOrder
  }

  export type gradebook_examsMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    scope?: SortOrder
    lesson_id?: SortOrder
  }

  export type grades_examsOrderByRelevanceInput = {
    fields: grades_examsOrderByRelevanceFieldEnum | grades_examsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type grades_examsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    exam_id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    date_given?: SortOrder
  }

  export type grades_examsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    exam_id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    date_given?: SortOrder
  }

  export type grades_examsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    exam_id?: SortOrder
    description?: SortOrder
    grade?: SortOrder
    date_given?: SortOrder
  }

  export type grading_scaleOrderByRelevanceInput = {
    fields: grading_scaleOrderByRelevanceFieldEnum | grading_scaleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type grading_scaleCountOrderByAggregateInput = {
    id?: SortOrder
    min_score?: SortOrder
    max_score?: SortOrder
    grades?: SortOrder
  }

  export type grading_scaleAvgOrderByAggregateInput = {
    min_score?: SortOrder
    max_score?: SortOrder
  }

  export type grading_scaleMaxOrderByAggregateInput = {
    id?: SortOrder
    min_score?: SortOrder
    max_score?: SortOrder
    grades?: SortOrder
  }

  export type grading_scaleMinOrderByAggregateInput = {
    id?: SortOrder
    min_score?: SortOrder
    max_score?: SortOrder
    grades?: SortOrder
  }

  export type grading_scaleSumOrderByAggregateInput = {
    min_score?: SortOrder
    max_score?: SortOrder
  }

  export type ExamsNullableScalarRelationFilter = {
    is?: examsWhereInput | null
    isNot?: examsWhereInput | null
  }

  export type notificationsOrderByRelevanceInput = {
    fields: notificationsOrderByRelevanceFieldEnum | notificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    description?: SortOrder
    notification_date?: SortOrder
    is_read?: SortOrder
    exam_id?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    description?: SortOrder
    notification_date?: SortOrder
    is_read?: SortOrder
    exam_id?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    description?: SortOrder
    notification_date?: SortOrder
    is_read?: SortOrder
    exam_id?: SortOrder
  }

  export type Open_questionsScalarRelationFilter = {
    is?: open_questionsWhereInput
    isNot?: open_questionsWhereInput
  }

  export type open_answersOrderByRelevanceInput = {
    fields: open_answersOrderByRelevanceFieldEnum | open_answersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type open_answersCountOrderByAggregateInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    description?: SortOrder
  }

  export type open_answersMaxOrderByAggregateInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    description?: SortOrder
  }

  export type open_answersMinOrderByAggregateInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    description?: SortOrder
  }

  export type Open_answersListRelationFilter = {
    every?: open_answersWhereInput
    some?: open_answersWhereInput
    none?: open_answersWhereInput
  }

  export type open_answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type open_questionsOrderByRelevanceInput = {
    fields: open_questionsOrderByRelevanceFieldEnum | open_questionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type open_questionsCountOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    auto_check?: SortOrder
    description?: SortOrder
    score?: SortOrder
  }

  export type open_questionsAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type open_questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    auto_check?: SortOrder
    description?: SortOrder
    score?: SortOrder
  }

  export type open_questionsMinOrderByAggregateInput = {
    id?: SortOrder
    exam_id?: SortOrder
    auto_check?: SortOrder
    description?: SortOrder
    score?: SortOrder
  }

  export type open_questionsSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type Closed_answersScalarRelationFilter = {
    is?: closed_answersWhereInput
    isNot?: closed_answersWhereInput
  }

  export type student_closed_answersCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    closed_question_id?: SortOrder
    closed_answer_id?: SortOrder
    attempt_id?: SortOrder
    correctness?: SortOrder
    date_time?: SortOrder
  }

  export type student_closed_answersMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    closed_question_id?: SortOrder
    closed_answer_id?: SortOrder
    attempt_id?: SortOrder
    correctness?: SortOrder
    date_time?: SortOrder
  }

  export type student_closed_answersMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    closed_question_id?: SortOrder
    closed_answer_id?: SortOrder
    attempt_id?: SortOrder
    correctness?: SortOrder
    date_time?: SortOrder
  }

  export type student_open_answersOrderByRelevanceInput = {
    fields: student_open_answersOrderByRelevanceFieldEnum | student_open_answersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type student_open_answersCountOrderByAggregateInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    score?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    date_time?: SortOrder
    description?: SortOrder
  }

  export type student_open_answersAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type student_open_answersMaxOrderByAggregateInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    score?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    date_time?: SortOrder
    description?: SortOrder
  }

  export type student_open_answersMinOrderByAggregateInput = {
    id?: SortOrder
    open_question_id?: SortOrder
    score?: SortOrder
    student_id?: SortOrder
    attempt_id?: SortOrder
    date_time?: SortOrder
    description?: SortOrder
  }

  export type student_open_answersSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type students_examsStudents_idExam_idCompoundUniqueInput = {
    students_id: Uint8Array
    exam_id: Uint8Array
  }

  export type students_examsCountOrderByAggregateInput = {
    students_id?: SortOrder
    exam_id?: SortOrder
  }

  export type students_examsMaxOrderByAggregateInput = {
    students_id?: SortOrder
    exam_id?: SortOrder
  }

  export type students_examsMinOrderByAggregateInput = {
    students_id?: SortOrder
    exam_id?: SortOrder
  }

  export type studentsCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttendancesInput
    connect?: studentsWhereUniqueInput
  }

  export type lessonsCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<lessonsCreateWithoutAttendancesInput, lessonsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutAttendancesInput
    connect?: lessonsWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type studentsUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttendancesInput
    upsert?: studentsUpsertWithoutAttendancesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutAttendancesInput, studentsUpdateWithoutAttendancesInput>, studentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type lessonsUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<lessonsCreateWithoutAttendancesInput, lessonsUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutAttendancesInput
    upsert?: lessonsUpsertWithoutAttendancesInput
    connect?: lessonsWhereUniqueInput
    update?: XOR<XOR<lessonsUpdateToOneWithWhereWithoutAttendancesInput, lessonsUpdateWithoutAttendancesInput>, lessonsUncheckedUpdateWithoutAttendancesInput>
  }

  export type badges_categoriesCreateNestedOneWithoutBadgesInput = {
    create?: XOR<badges_categoriesCreateWithoutBadgesInput, badges_categoriesUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: badges_categoriesCreateOrConnectWithoutBadgesInput
    connect?: badges_categoriesWhereUniqueInput
  }

  export type badges_historyCreateNestedManyWithoutBadgesInput = {
    create?: XOR<badges_historyCreateWithoutBadgesInput, badges_historyUncheckedCreateWithoutBadgesInput> | badges_historyCreateWithoutBadgesInput[] | badges_historyUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutBadgesInput | badges_historyCreateOrConnectWithoutBadgesInput[]
    createMany?: badges_historyCreateManyBadgesInputEnvelope
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
  }

  export type badges_historyUncheckedCreateNestedManyWithoutBadgesInput = {
    create?: XOR<badges_historyCreateWithoutBadgesInput, badges_historyUncheckedCreateWithoutBadgesInput> | badges_historyCreateWithoutBadgesInput[] | badges_historyUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutBadgesInput | badges_historyCreateOrConnectWithoutBadgesInput[]
    createMany?: badges_historyCreateManyBadgesInputEnvelope
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type badges_categoriesUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<badges_categoriesCreateWithoutBadgesInput, badges_categoriesUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: badges_categoriesCreateOrConnectWithoutBadgesInput
    upsert?: badges_categoriesUpsertWithoutBadgesInput
    connect?: badges_categoriesWhereUniqueInput
    update?: XOR<XOR<badges_categoriesUpdateToOneWithWhereWithoutBadgesInput, badges_categoriesUpdateWithoutBadgesInput>, badges_categoriesUncheckedUpdateWithoutBadgesInput>
  }

  export type badges_historyUpdateManyWithoutBadgesNestedInput = {
    create?: XOR<badges_historyCreateWithoutBadgesInput, badges_historyUncheckedCreateWithoutBadgesInput> | badges_historyCreateWithoutBadgesInput[] | badges_historyUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutBadgesInput | badges_historyCreateOrConnectWithoutBadgesInput[]
    upsert?: badges_historyUpsertWithWhereUniqueWithoutBadgesInput | badges_historyUpsertWithWhereUniqueWithoutBadgesInput[]
    createMany?: badges_historyCreateManyBadgesInputEnvelope
    set?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    disconnect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    delete?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    update?: badges_historyUpdateWithWhereUniqueWithoutBadgesInput | badges_historyUpdateWithWhereUniqueWithoutBadgesInput[]
    updateMany?: badges_historyUpdateManyWithWhereWithoutBadgesInput | badges_historyUpdateManyWithWhereWithoutBadgesInput[]
    deleteMany?: badges_historyScalarWhereInput | badges_historyScalarWhereInput[]
  }

  export type badges_historyUncheckedUpdateManyWithoutBadgesNestedInput = {
    create?: XOR<badges_historyCreateWithoutBadgesInput, badges_historyUncheckedCreateWithoutBadgesInput> | badges_historyCreateWithoutBadgesInput[] | badges_historyUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutBadgesInput | badges_historyCreateOrConnectWithoutBadgesInput[]
    upsert?: badges_historyUpsertWithWhereUniqueWithoutBadgesInput | badges_historyUpsertWithWhereUniqueWithoutBadgesInput[]
    createMany?: badges_historyCreateManyBadgesInputEnvelope
    set?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    disconnect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    delete?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    update?: badges_historyUpdateWithWhereUniqueWithoutBadgesInput | badges_historyUpdateWithWhereUniqueWithoutBadgesInput[]
    updateMany?: badges_historyUpdateManyWithWhereWithoutBadgesInput | badges_historyUpdateManyWithWhereWithoutBadgesInput[]
    deleteMany?: badges_historyScalarWhereInput | badges_historyScalarWhereInput[]
  }

  export type badgesCreateNestedManyWithoutBadges_categoriesInput = {
    create?: XOR<badgesCreateWithoutBadges_categoriesInput, badgesUncheckedCreateWithoutBadges_categoriesInput> | badgesCreateWithoutBadges_categoriesInput[] | badgesUncheckedCreateWithoutBadges_categoriesInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutBadges_categoriesInput | badgesCreateOrConnectWithoutBadges_categoriesInput[]
    createMany?: badgesCreateManyBadges_categoriesInputEnvelope
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
  }

  export type badgesUncheckedCreateNestedManyWithoutBadges_categoriesInput = {
    create?: XOR<badgesCreateWithoutBadges_categoriesInput, badgesUncheckedCreateWithoutBadges_categoriesInput> | badgesCreateWithoutBadges_categoriesInput[] | badgesUncheckedCreateWithoutBadges_categoriesInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutBadges_categoriesInput | badgesCreateOrConnectWithoutBadges_categoriesInput[]
    createMany?: badgesCreateManyBadges_categoriesInputEnvelope
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
  }

  export type badgesUpdateManyWithoutBadges_categoriesNestedInput = {
    create?: XOR<badgesCreateWithoutBadges_categoriesInput, badgesUncheckedCreateWithoutBadges_categoriesInput> | badgesCreateWithoutBadges_categoriesInput[] | badgesUncheckedCreateWithoutBadges_categoriesInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutBadges_categoriesInput | badgesCreateOrConnectWithoutBadges_categoriesInput[]
    upsert?: badgesUpsertWithWhereUniqueWithoutBadges_categoriesInput | badgesUpsertWithWhereUniqueWithoutBadges_categoriesInput[]
    createMany?: badgesCreateManyBadges_categoriesInputEnvelope
    set?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    disconnect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    delete?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    update?: badgesUpdateWithWhereUniqueWithoutBadges_categoriesInput | badgesUpdateWithWhereUniqueWithoutBadges_categoriesInput[]
    updateMany?: badgesUpdateManyWithWhereWithoutBadges_categoriesInput | badgesUpdateManyWithWhereWithoutBadges_categoriesInput[]
    deleteMany?: badgesScalarWhereInput | badgesScalarWhereInput[]
  }

  export type badgesUncheckedUpdateManyWithoutBadges_categoriesNestedInput = {
    create?: XOR<badgesCreateWithoutBadges_categoriesInput, badgesUncheckedCreateWithoutBadges_categoriesInput> | badgesCreateWithoutBadges_categoriesInput[] | badgesUncheckedCreateWithoutBadges_categoriesInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutBadges_categoriesInput | badgesCreateOrConnectWithoutBadges_categoriesInput[]
    upsert?: badgesUpsertWithWhereUniqueWithoutBadges_categoriesInput | badgesUpsertWithWhereUniqueWithoutBadges_categoriesInput[]
    createMany?: badgesCreateManyBadges_categoriesInputEnvelope
    set?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    disconnect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    delete?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    update?: badgesUpdateWithWhereUniqueWithoutBadges_categoriesInput | badgesUpdateWithWhereUniqueWithoutBadges_categoriesInput[]
    updateMany?: badgesUpdateManyWithWhereWithoutBadges_categoriesInput | badgesUpdateManyWithWhereWithoutBadges_categoriesInput[]
    deleteMany?: badgesScalarWhereInput | badgesScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutBadges_historyInput = {
    create?: XOR<studentsCreateWithoutBadges_historyInput, studentsUncheckedCreateWithoutBadges_historyInput>
    connectOrCreate?: studentsCreateOrConnectWithoutBadges_historyInput
    connect?: studentsWhereUniqueInput
  }

  export type badgesCreateNestedOneWithoutBadges_historyInput = {
    create?: XOR<badgesCreateWithoutBadges_historyInput, badgesUncheckedCreateWithoutBadges_historyInput>
    connectOrCreate?: badgesCreateOrConnectWithoutBadges_historyInput
    connect?: badgesWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutBadges_historyNestedInput = {
    create?: XOR<studentsCreateWithoutBadges_historyInput, studentsUncheckedCreateWithoutBadges_historyInput>
    connectOrCreate?: studentsCreateOrConnectWithoutBadges_historyInput
    upsert?: studentsUpsertWithoutBadges_historyInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutBadges_historyInput, studentsUpdateWithoutBadges_historyInput>, studentsUncheckedUpdateWithoutBadges_historyInput>
  }

  export type badgesUpdateOneRequiredWithoutBadges_historyNestedInput = {
    create?: XOR<badgesCreateWithoutBadges_historyInput, badgesUncheckedCreateWithoutBadges_historyInput>
    connectOrCreate?: badgesCreateOrConnectWithoutBadges_historyInput
    upsert?: badgesUpsertWithoutBadges_historyInput
    connect?: badgesWhereUniqueInput
    update?: XOR<XOR<badgesUpdateToOneWithWhereWithoutBadges_historyInput, badgesUpdateWithoutBadges_historyInput>, badgesUncheckedUpdateWithoutBadges_historyInput>
  }

  export type class_namesCreateNestedOneWithoutClassesInput = {
    create?: XOR<class_namesCreateWithoutClassesInput, class_namesUncheckedCreateWithoutClassesInput>
    connectOrCreate?: class_namesCreateOrConnectWithoutClassesInput
    connect?: class_namesWhereUniqueInput
  }

  export type school_yearsCreateNestedOneWithoutClassesInput = {
    create?: XOR<school_yearsCreateWithoutClassesInput, school_yearsUncheckedCreateWithoutClassesInput>
    connectOrCreate?: school_yearsCreateOrConnectWithoutClassesInput
    connect?: school_yearsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutClassesInput = {
    create?: XOR<teachersCreateWithoutClassesInput, teachersUncheckedCreateWithoutClassesInput>
    connectOrCreate?: teachersCreateOrConnectWithoutClassesInput
    connect?: teachersWhereUniqueInput
  }

  export type classes_examsCreateNestedManyWithoutClassesInput = {
    create?: XOR<classes_examsCreateWithoutClassesInput, classes_examsUncheckedCreateWithoutClassesInput> | classes_examsCreateWithoutClassesInput[] | classes_examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutClassesInput | classes_examsCreateOrConnectWithoutClassesInput[]
    createMany?: classes_examsCreateManyClassesInputEnvelope
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
  }

  export type lessonsCreateNestedManyWithoutClassesInput = {
    create?: XOR<lessonsCreateWithoutClassesInput, lessonsUncheckedCreateWithoutClassesInput> | lessonsCreateWithoutClassesInput[] | lessonsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutClassesInput | lessonsCreateOrConnectWithoutClassesInput[]
    createMany?: lessonsCreateManyClassesInputEnvelope
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
  }

  export type studentsCreateNestedManyWithoutClassesInput = {
    create?: XOR<studentsCreateWithoutClassesInput, studentsUncheckedCreateWithoutClassesInput> | studentsCreateWithoutClassesInput[] | studentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutClassesInput | studentsCreateOrConnectWithoutClassesInput[]
    createMany?: studentsCreateManyClassesInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type classes_examsUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<classes_examsCreateWithoutClassesInput, classes_examsUncheckedCreateWithoutClassesInput> | classes_examsCreateWithoutClassesInput[] | classes_examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutClassesInput | classes_examsCreateOrConnectWithoutClassesInput[]
    createMany?: classes_examsCreateManyClassesInputEnvelope
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
  }

  export type lessonsUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<lessonsCreateWithoutClassesInput, lessonsUncheckedCreateWithoutClassesInput> | lessonsCreateWithoutClassesInput[] | lessonsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutClassesInput | lessonsCreateOrConnectWithoutClassesInput[]
    createMany?: lessonsCreateManyClassesInputEnvelope
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedManyWithoutClassesInput = {
    create?: XOR<studentsCreateWithoutClassesInput, studentsUncheckedCreateWithoutClassesInput> | studentsCreateWithoutClassesInput[] | studentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutClassesInput | studentsCreateOrConnectWithoutClassesInput[]
    createMany?: studentsCreateManyClassesInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type class_namesUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<class_namesCreateWithoutClassesInput, class_namesUncheckedCreateWithoutClassesInput>
    connectOrCreate?: class_namesCreateOrConnectWithoutClassesInput
    upsert?: class_namesUpsertWithoutClassesInput
    connect?: class_namesWhereUniqueInput
    update?: XOR<XOR<class_namesUpdateToOneWithWhereWithoutClassesInput, class_namesUpdateWithoutClassesInput>, class_namesUncheckedUpdateWithoutClassesInput>
  }

  export type school_yearsUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<school_yearsCreateWithoutClassesInput, school_yearsUncheckedCreateWithoutClassesInput>
    connectOrCreate?: school_yearsCreateOrConnectWithoutClassesInput
    upsert?: school_yearsUpsertWithoutClassesInput
    connect?: school_yearsWhereUniqueInput
    update?: XOR<XOR<school_yearsUpdateToOneWithWhereWithoutClassesInput, school_yearsUpdateWithoutClassesInput>, school_yearsUncheckedUpdateWithoutClassesInput>
  }

  export type teachersUpdateOneWithoutClassesNestedInput = {
    create?: XOR<teachersCreateWithoutClassesInput, teachersUncheckedCreateWithoutClassesInput>
    connectOrCreate?: teachersCreateOrConnectWithoutClassesInput
    upsert?: teachersUpsertWithoutClassesInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutClassesInput, teachersUpdateWithoutClassesInput>, teachersUncheckedUpdateWithoutClassesInput>
  }

  export type classes_examsUpdateManyWithoutClassesNestedInput = {
    create?: XOR<classes_examsCreateWithoutClassesInput, classes_examsUncheckedCreateWithoutClassesInput> | classes_examsCreateWithoutClassesInput[] | classes_examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutClassesInput | classes_examsCreateOrConnectWithoutClassesInput[]
    upsert?: classes_examsUpsertWithWhereUniqueWithoutClassesInput | classes_examsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: classes_examsCreateManyClassesInputEnvelope
    set?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    disconnect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    delete?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    update?: classes_examsUpdateWithWhereUniqueWithoutClassesInput | classes_examsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: classes_examsUpdateManyWithWhereWithoutClassesInput | classes_examsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: classes_examsScalarWhereInput | classes_examsScalarWhereInput[]
  }

  export type lessonsUpdateManyWithoutClassesNestedInput = {
    create?: XOR<lessonsCreateWithoutClassesInput, lessonsUncheckedCreateWithoutClassesInput> | lessonsCreateWithoutClassesInput[] | lessonsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutClassesInput | lessonsCreateOrConnectWithoutClassesInput[]
    upsert?: lessonsUpsertWithWhereUniqueWithoutClassesInput | lessonsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: lessonsCreateManyClassesInputEnvelope
    set?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    disconnect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    delete?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    update?: lessonsUpdateWithWhereUniqueWithoutClassesInput | lessonsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: lessonsUpdateManyWithWhereWithoutClassesInput | lessonsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
  }

  export type studentsUpdateManyWithoutClassesNestedInput = {
    create?: XOR<studentsCreateWithoutClassesInput, studentsUncheckedCreateWithoutClassesInput> | studentsCreateWithoutClassesInput[] | studentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutClassesInput | studentsCreateOrConnectWithoutClassesInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutClassesInput | studentsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: studentsCreateManyClassesInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutClassesInput | studentsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutClassesInput | studentsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type classes_examsUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<classes_examsCreateWithoutClassesInput, classes_examsUncheckedCreateWithoutClassesInput> | classes_examsCreateWithoutClassesInput[] | classes_examsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutClassesInput | classes_examsCreateOrConnectWithoutClassesInput[]
    upsert?: classes_examsUpsertWithWhereUniqueWithoutClassesInput | classes_examsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: classes_examsCreateManyClassesInputEnvelope
    set?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    disconnect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    delete?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    update?: classes_examsUpdateWithWhereUniqueWithoutClassesInput | classes_examsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: classes_examsUpdateManyWithWhereWithoutClassesInput | classes_examsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: classes_examsScalarWhereInput | classes_examsScalarWhereInput[]
  }

  export type lessonsUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<lessonsCreateWithoutClassesInput, lessonsUncheckedCreateWithoutClassesInput> | lessonsCreateWithoutClassesInput[] | lessonsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutClassesInput | lessonsCreateOrConnectWithoutClassesInput[]
    upsert?: lessonsUpsertWithWhereUniqueWithoutClassesInput | lessonsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: lessonsCreateManyClassesInputEnvelope
    set?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    disconnect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    delete?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    update?: lessonsUpdateWithWhereUniqueWithoutClassesInput | lessonsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: lessonsUpdateManyWithWhereWithoutClassesInput | lessonsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
  }

  export type studentsUncheckedUpdateManyWithoutClassesNestedInput = {
    create?: XOR<studentsCreateWithoutClassesInput, studentsUncheckedCreateWithoutClassesInput> | studentsCreateWithoutClassesInput[] | studentsUncheckedCreateWithoutClassesInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutClassesInput | studentsCreateOrConnectWithoutClassesInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutClassesInput | studentsUpsertWithWhereUniqueWithoutClassesInput[]
    createMany?: studentsCreateManyClassesInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutClassesInput | studentsUpdateWithWhereUniqueWithoutClassesInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutClassesInput | studentsUpdateManyWithWhereWithoutClassesInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type school_eventsCreateNestedManyWithoutEvent_typesInput = {
    create?: XOR<school_eventsCreateWithoutEvent_typesInput, school_eventsUncheckedCreateWithoutEvent_typesInput> | school_eventsCreateWithoutEvent_typesInput[] | school_eventsUncheckedCreateWithoutEvent_typesInput[]
    connectOrCreate?: school_eventsCreateOrConnectWithoutEvent_typesInput | school_eventsCreateOrConnectWithoutEvent_typesInput[]
    createMany?: school_eventsCreateManyEvent_typesInputEnvelope
    connect?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
  }

  export type school_eventsUncheckedCreateNestedManyWithoutEvent_typesInput = {
    create?: XOR<school_eventsCreateWithoutEvent_typesInput, school_eventsUncheckedCreateWithoutEvent_typesInput> | school_eventsCreateWithoutEvent_typesInput[] | school_eventsUncheckedCreateWithoutEvent_typesInput[]
    connectOrCreate?: school_eventsCreateOrConnectWithoutEvent_typesInput | school_eventsCreateOrConnectWithoutEvent_typesInput[]
    createMany?: school_eventsCreateManyEvent_typesInputEnvelope
    connect?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
  }

  export type school_eventsUpdateManyWithoutEvent_typesNestedInput = {
    create?: XOR<school_eventsCreateWithoutEvent_typesInput, school_eventsUncheckedCreateWithoutEvent_typesInput> | school_eventsCreateWithoutEvent_typesInput[] | school_eventsUncheckedCreateWithoutEvent_typesInput[]
    connectOrCreate?: school_eventsCreateOrConnectWithoutEvent_typesInput | school_eventsCreateOrConnectWithoutEvent_typesInput[]
    upsert?: school_eventsUpsertWithWhereUniqueWithoutEvent_typesInput | school_eventsUpsertWithWhereUniqueWithoutEvent_typesInput[]
    createMany?: school_eventsCreateManyEvent_typesInputEnvelope
    set?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    disconnect?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    delete?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    connect?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    update?: school_eventsUpdateWithWhereUniqueWithoutEvent_typesInput | school_eventsUpdateWithWhereUniqueWithoutEvent_typesInput[]
    updateMany?: school_eventsUpdateManyWithWhereWithoutEvent_typesInput | school_eventsUpdateManyWithWhereWithoutEvent_typesInput[]
    deleteMany?: school_eventsScalarWhereInput | school_eventsScalarWhereInput[]
  }

  export type school_eventsUncheckedUpdateManyWithoutEvent_typesNestedInput = {
    create?: XOR<school_eventsCreateWithoutEvent_typesInput, school_eventsUncheckedCreateWithoutEvent_typesInput> | school_eventsCreateWithoutEvent_typesInput[] | school_eventsUncheckedCreateWithoutEvent_typesInput[]
    connectOrCreate?: school_eventsCreateOrConnectWithoutEvent_typesInput | school_eventsCreateOrConnectWithoutEvent_typesInput[]
    upsert?: school_eventsUpsertWithWhereUniqueWithoutEvent_typesInput | school_eventsUpsertWithWhereUniqueWithoutEvent_typesInput[]
    createMany?: school_eventsCreateManyEvent_typesInputEnvelope
    set?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    disconnect?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    delete?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    connect?: school_eventsWhereUniqueInput | school_eventsWhereUniqueInput[]
    update?: school_eventsUpdateWithWhereUniqueWithoutEvent_typesInput | school_eventsUpdateWithWhereUniqueWithoutEvent_typesInput[]
    updateMany?: school_eventsUpdateManyWithWhereWithoutEvent_typesInput | school_eventsUpdateManyWithWhereWithoutEvent_typesInput[]
    deleteMany?: school_eventsScalarWhereInput | school_eventsScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutGrades_gradebookInput = {
    create?: XOR<studentsCreateWithoutGrades_gradebookInput, studentsUncheckedCreateWithoutGrades_gradebookInput>
    connectOrCreate?: studentsCreateOrConnectWithoutGrades_gradebookInput
    connect?: studentsWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutGrades_gradebookInput = {
    create?: XOR<subjectsCreateWithoutGrades_gradebookInput, subjectsUncheckedCreateWithoutGrades_gradebookInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutGrades_gradebookInput
    connect?: subjectsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutGrades_gradebookInput = {
    create?: XOR<teachersCreateWithoutGrades_gradebookInput, teachersUncheckedCreateWithoutGrades_gradebookInput>
    connectOrCreate?: teachersCreateOrConnectWithoutGrades_gradebookInput
    connect?: teachersWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type studentsUpdateOneRequiredWithoutGrades_gradebookNestedInput = {
    create?: XOR<studentsCreateWithoutGrades_gradebookInput, studentsUncheckedCreateWithoutGrades_gradebookInput>
    connectOrCreate?: studentsCreateOrConnectWithoutGrades_gradebookInput
    upsert?: studentsUpsertWithoutGrades_gradebookInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutGrades_gradebookInput, studentsUpdateWithoutGrades_gradebookInput>, studentsUncheckedUpdateWithoutGrades_gradebookInput>
  }

  export type subjectsUpdateOneRequiredWithoutGrades_gradebookNestedInput = {
    create?: XOR<subjectsCreateWithoutGrades_gradebookInput, subjectsUncheckedCreateWithoutGrades_gradebookInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutGrades_gradebookInput
    upsert?: subjectsUpsertWithoutGrades_gradebookInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutGrades_gradebookInput, subjectsUpdateWithoutGrades_gradebookInput>, subjectsUncheckedUpdateWithoutGrades_gradebookInput>
  }

  export type teachersUpdateOneRequiredWithoutGrades_gradebookNestedInput = {
    create?: XOR<teachersCreateWithoutGrades_gradebookInput, teachersUncheckedCreateWithoutGrades_gradebookInput>
    connectOrCreate?: teachersCreateOrConnectWithoutGrades_gradebookInput
    upsert?: teachersUpsertWithoutGrades_gradebookInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutGrades_gradebookInput, teachersUpdateWithoutGrades_gradebookInput>, teachersUncheckedUpdateWithoutGrades_gradebookInput>
  }

  export type lessonsCreateNestedOneWithoutHomeworksInput = {
    create?: XOR<lessonsCreateWithoutHomeworksInput, lessonsUncheckedCreateWithoutHomeworksInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutHomeworksInput
    connect?: lessonsWhereUniqueInput
  }

  export type lessonsUpdateOneRequiredWithoutHomeworksNestedInput = {
    create?: XOR<lessonsCreateWithoutHomeworksInput, lessonsUncheckedCreateWithoutHomeworksInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutHomeworksInput
    upsert?: lessonsUpsertWithoutHomeworksInput
    connect?: lessonsWhereUniqueInput
    update?: XOR<XOR<lessonsUpdateToOneWithWhereWithoutHomeworksInput, lessonsUpdateWithoutHomeworksInput>, lessonsUncheckedUpdateWithoutHomeworksInput>
  }

  export type attendancesCreateNestedManyWithoutLessonsInput = {
    create?: XOR<attendancesCreateWithoutLessonsInput, attendancesUncheckedCreateWithoutLessonsInput> | attendancesCreateWithoutLessonsInput[] | attendancesUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutLessonsInput | attendancesCreateOrConnectWithoutLessonsInput[]
    createMany?: attendancesCreateManyLessonsInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type examsCreateNestedManyWithoutLessonsInput = {
    create?: XOR<examsCreateWithoutLessonsInput, examsUncheckedCreateWithoutLessonsInput> | examsCreateWithoutLessonsInput[] | examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: examsCreateOrConnectWithoutLessonsInput | examsCreateOrConnectWithoutLessonsInput[]
    createMany?: examsCreateManyLessonsInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type gradebook_examsCreateNestedManyWithoutLessonsInput = {
    create?: XOR<gradebook_examsCreateWithoutLessonsInput, gradebook_examsUncheckedCreateWithoutLessonsInput> | gradebook_examsCreateWithoutLessonsInput[] | gradebook_examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: gradebook_examsCreateOrConnectWithoutLessonsInput | gradebook_examsCreateOrConnectWithoutLessonsInput[]
    createMany?: gradebook_examsCreateManyLessonsInputEnvelope
    connect?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
  }

  export type homeworksCreateNestedOneWithoutLessonsInput = {
    create?: XOR<homeworksCreateWithoutLessonsInput, homeworksUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: homeworksCreateOrConnectWithoutLessonsInput
    connect?: homeworksWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutLessonsInput = {
    create?: XOR<teachersCreateWithoutLessonsInput, teachersUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutLessonsInput
    connect?: teachersWhereUniqueInput
  }

  export type classesCreateNestedOneWithoutLessonsInput = {
    create?: XOR<classesCreateWithoutLessonsInput, classesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: classesCreateOrConnectWithoutLessonsInput
    connect?: classesWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutLessonsInput = {
    create?: XOR<subjectsCreateWithoutLessonsInput, subjectsUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutLessonsInput
    connect?: subjectsWhereUniqueInput
  }

  export type attendancesUncheckedCreateNestedManyWithoutLessonsInput = {
    create?: XOR<attendancesCreateWithoutLessonsInput, attendancesUncheckedCreateWithoutLessonsInput> | attendancesCreateWithoutLessonsInput[] | attendancesUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutLessonsInput | attendancesCreateOrConnectWithoutLessonsInput[]
    createMany?: attendancesCreateManyLessonsInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type examsUncheckedCreateNestedManyWithoutLessonsInput = {
    create?: XOR<examsCreateWithoutLessonsInput, examsUncheckedCreateWithoutLessonsInput> | examsCreateWithoutLessonsInput[] | examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: examsCreateOrConnectWithoutLessonsInput | examsCreateOrConnectWithoutLessonsInput[]
    createMany?: examsCreateManyLessonsInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput = {
    create?: XOR<gradebook_examsCreateWithoutLessonsInput, gradebook_examsUncheckedCreateWithoutLessonsInput> | gradebook_examsCreateWithoutLessonsInput[] | gradebook_examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: gradebook_examsCreateOrConnectWithoutLessonsInput | gradebook_examsCreateOrConnectWithoutLessonsInput[]
    createMany?: gradebook_examsCreateManyLessonsInputEnvelope
    connect?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
  }

  export type homeworksUncheckedCreateNestedOneWithoutLessonsInput = {
    create?: XOR<homeworksCreateWithoutLessonsInput, homeworksUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: homeworksCreateOrConnectWithoutLessonsInput
    connect?: homeworksWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type attendancesUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<attendancesCreateWithoutLessonsInput, attendancesUncheckedCreateWithoutLessonsInput> | attendancesCreateWithoutLessonsInput[] | attendancesUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutLessonsInput | attendancesCreateOrConnectWithoutLessonsInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutLessonsInput | attendancesUpsertWithWhereUniqueWithoutLessonsInput[]
    createMany?: attendancesCreateManyLessonsInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutLessonsInput | attendancesUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutLessonsInput | attendancesUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type examsUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<examsCreateWithoutLessonsInput, examsUncheckedCreateWithoutLessonsInput> | examsCreateWithoutLessonsInput[] | examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: examsCreateOrConnectWithoutLessonsInput | examsCreateOrConnectWithoutLessonsInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutLessonsInput | examsUpsertWithWhereUniqueWithoutLessonsInput[]
    createMany?: examsCreateManyLessonsInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutLessonsInput | examsUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: examsUpdateManyWithWhereWithoutLessonsInput | examsUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type gradebook_examsUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<gradebook_examsCreateWithoutLessonsInput, gradebook_examsUncheckedCreateWithoutLessonsInput> | gradebook_examsCreateWithoutLessonsInput[] | gradebook_examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: gradebook_examsCreateOrConnectWithoutLessonsInput | gradebook_examsCreateOrConnectWithoutLessonsInput[]
    upsert?: gradebook_examsUpsertWithWhereUniqueWithoutLessonsInput | gradebook_examsUpsertWithWhereUniqueWithoutLessonsInput[]
    createMany?: gradebook_examsCreateManyLessonsInputEnvelope
    set?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    disconnect?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    delete?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    connect?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    update?: gradebook_examsUpdateWithWhereUniqueWithoutLessonsInput | gradebook_examsUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: gradebook_examsUpdateManyWithWhereWithoutLessonsInput | gradebook_examsUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: gradebook_examsScalarWhereInput | gradebook_examsScalarWhereInput[]
  }

  export type homeworksUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<homeworksCreateWithoutLessonsInput, homeworksUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: homeworksCreateOrConnectWithoutLessonsInput
    upsert?: homeworksUpsertWithoutLessonsInput
    disconnect?: homeworksWhereInput | boolean
    delete?: homeworksWhereInput | boolean
    connect?: homeworksWhereUniqueInput
    update?: XOR<XOR<homeworksUpdateToOneWithWhereWithoutLessonsInput, homeworksUpdateWithoutLessonsInput>, homeworksUncheckedUpdateWithoutLessonsInput>
  }

  export type teachersUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<teachersCreateWithoutLessonsInput, teachersUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutLessonsInput
    upsert?: teachersUpsertWithoutLessonsInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutLessonsInput, teachersUpdateWithoutLessonsInput>, teachersUncheckedUpdateWithoutLessonsInput>
  }

  export type classesUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<classesCreateWithoutLessonsInput, classesUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: classesCreateOrConnectWithoutLessonsInput
    upsert?: classesUpsertWithoutLessonsInput
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutLessonsInput, classesUpdateWithoutLessonsInput>, classesUncheckedUpdateWithoutLessonsInput>
  }

  export type subjectsUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<subjectsCreateWithoutLessonsInput, subjectsUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutLessonsInput
    upsert?: subjectsUpsertWithoutLessonsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutLessonsInput, subjectsUpdateWithoutLessonsInput>, subjectsUncheckedUpdateWithoutLessonsInput>
  }

  export type attendancesUncheckedUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<attendancesCreateWithoutLessonsInput, attendancesUncheckedCreateWithoutLessonsInput> | attendancesCreateWithoutLessonsInput[] | attendancesUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutLessonsInput | attendancesCreateOrConnectWithoutLessonsInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutLessonsInput | attendancesUpsertWithWhereUniqueWithoutLessonsInput[]
    createMany?: attendancesCreateManyLessonsInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutLessonsInput | attendancesUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutLessonsInput | attendancesUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type examsUncheckedUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<examsCreateWithoutLessonsInput, examsUncheckedCreateWithoutLessonsInput> | examsCreateWithoutLessonsInput[] | examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: examsCreateOrConnectWithoutLessonsInput | examsCreateOrConnectWithoutLessonsInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutLessonsInput | examsUpsertWithWhereUniqueWithoutLessonsInput[]
    createMany?: examsCreateManyLessonsInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutLessonsInput | examsUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: examsUpdateManyWithWhereWithoutLessonsInput | examsUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<gradebook_examsCreateWithoutLessonsInput, gradebook_examsUncheckedCreateWithoutLessonsInput> | gradebook_examsCreateWithoutLessonsInput[] | gradebook_examsUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: gradebook_examsCreateOrConnectWithoutLessonsInput | gradebook_examsCreateOrConnectWithoutLessonsInput[]
    upsert?: gradebook_examsUpsertWithWhereUniqueWithoutLessonsInput | gradebook_examsUpsertWithWhereUniqueWithoutLessonsInput[]
    createMany?: gradebook_examsCreateManyLessonsInputEnvelope
    set?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    disconnect?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    delete?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    connect?: gradebook_examsWhereUniqueInput | gradebook_examsWhereUniqueInput[]
    update?: gradebook_examsUpdateWithWhereUniqueWithoutLessonsInput | gradebook_examsUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: gradebook_examsUpdateManyWithWhereWithoutLessonsInput | gradebook_examsUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: gradebook_examsScalarWhereInput | gradebook_examsScalarWhereInput[]
  }

  export type homeworksUncheckedUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<homeworksCreateWithoutLessonsInput, homeworksUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: homeworksCreateOrConnectWithoutLessonsInput
    upsert?: homeworksUpsertWithoutLessonsInput
    disconnect?: homeworksWhereInput | boolean
    delete?: homeworksWhereInput | boolean
    connect?: homeworksWhereUniqueInput
    update?: XOR<XOR<homeworksUpdateToOneWithWhereWithoutLessonsInput, homeworksUpdateWithoutLessonsInput>, homeworksUncheckedUpdateWithoutLessonsInput>
  }

  export type user_typesCreateNestedOneWithoutMessages_messages_sender_type_idTouser_typesInput = {
    create?: XOR<user_typesCreateWithoutMessages_messages_sender_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_sender_type_idTouser_typesInput>
    connectOrCreate?: user_typesCreateOrConnectWithoutMessages_messages_sender_type_idTouser_typesInput
    connect?: user_typesWhereUniqueInput
  }

  export type user_typesCreateNestedOneWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    create?: XOR<user_typesCreateWithoutMessages_messages_receiver_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_receiver_type_idTouser_typesInput>
    connectOrCreate?: user_typesCreateOrConnectWithoutMessages_messages_receiver_type_idTouser_typesInput
    connect?: user_typesWhereUniqueInput
  }

  export type user_typesUpdateOneRequiredWithoutMessages_messages_sender_type_idTouser_typesNestedInput = {
    create?: XOR<user_typesCreateWithoutMessages_messages_sender_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_sender_type_idTouser_typesInput>
    connectOrCreate?: user_typesCreateOrConnectWithoutMessages_messages_sender_type_idTouser_typesInput
    upsert?: user_typesUpsertWithoutMessages_messages_sender_type_idTouser_typesInput
    connect?: user_typesWhereUniqueInput
    update?: XOR<XOR<user_typesUpdateToOneWithWhereWithoutMessages_messages_sender_type_idTouser_typesInput, user_typesUpdateWithoutMessages_messages_sender_type_idTouser_typesInput>, user_typesUncheckedUpdateWithoutMessages_messages_sender_type_idTouser_typesInput>
  }

  export type user_typesUpdateOneRequiredWithoutMessages_messages_receiver_type_idTouser_typesNestedInput = {
    create?: XOR<user_typesCreateWithoutMessages_messages_receiver_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_receiver_type_idTouser_typesInput>
    connectOrCreate?: user_typesCreateOrConnectWithoutMessages_messages_receiver_type_idTouser_typesInput
    upsert?: user_typesUpsertWithoutMessages_messages_receiver_type_idTouser_typesInput
    connect?: user_typesWhereUniqueInput
    update?: XOR<XOR<user_typesUpdateToOneWithWhereWithoutMessages_messages_receiver_type_idTouser_typesInput, user_typesUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput>, user_typesUncheckedUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput>
  }

  export type students_parentsCreateNestedManyWithoutParentsInput = {
    create?: XOR<students_parentsCreateWithoutParentsInput, students_parentsUncheckedCreateWithoutParentsInput> | students_parentsCreateWithoutParentsInput[] | students_parentsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutParentsInput | students_parentsCreateOrConnectWithoutParentsInput[]
    createMany?: students_parentsCreateManyParentsInputEnvelope
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
  }

  export type students_parentsUncheckedCreateNestedManyWithoutParentsInput = {
    create?: XOR<students_parentsCreateWithoutParentsInput, students_parentsUncheckedCreateWithoutParentsInput> | students_parentsCreateWithoutParentsInput[] | students_parentsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutParentsInput | students_parentsCreateOrConnectWithoutParentsInput[]
    createMany?: students_parentsCreateManyParentsInputEnvelope
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type students_parentsUpdateManyWithoutParentsNestedInput = {
    create?: XOR<students_parentsCreateWithoutParentsInput, students_parentsUncheckedCreateWithoutParentsInput> | students_parentsCreateWithoutParentsInput[] | students_parentsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutParentsInput | students_parentsCreateOrConnectWithoutParentsInput[]
    upsert?: students_parentsUpsertWithWhereUniqueWithoutParentsInput | students_parentsUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: students_parentsCreateManyParentsInputEnvelope
    set?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    disconnect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    delete?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    update?: students_parentsUpdateWithWhereUniqueWithoutParentsInput | students_parentsUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: students_parentsUpdateManyWithWhereWithoutParentsInput | students_parentsUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: students_parentsScalarWhereInput | students_parentsScalarWhereInput[]
  }

  export type students_parentsUncheckedUpdateManyWithoutParentsNestedInput = {
    create?: XOR<students_parentsCreateWithoutParentsInput, students_parentsUncheckedCreateWithoutParentsInput> | students_parentsCreateWithoutParentsInput[] | students_parentsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutParentsInput | students_parentsCreateOrConnectWithoutParentsInput[]
    upsert?: students_parentsUpsertWithWhereUniqueWithoutParentsInput | students_parentsUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: students_parentsCreateManyParentsInputEnvelope
    set?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    disconnect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    delete?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    update?: students_parentsUpdateWithWhereUniqueWithoutParentsInput | students_parentsUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: students_parentsUpdateManyWithWhereWithoutParentsInput | students_parentsUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: students_parentsScalarWhereInput | students_parentsScalarWhereInput[]
  }

  export type problems_gradebookCreateNestedManyWithoutProblem_typesInput = {
    create?: XOR<problems_gradebookCreateWithoutProblem_typesInput, problems_gradebookUncheckedCreateWithoutProblem_typesInput> | problems_gradebookCreateWithoutProblem_typesInput[] | problems_gradebookUncheckedCreateWithoutProblem_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutProblem_typesInput | problems_gradebookCreateOrConnectWithoutProblem_typesInput[]
    createMany?: problems_gradebookCreateManyProblem_typesInputEnvelope
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
  }

  export type problems_gradebookUncheckedCreateNestedManyWithoutProblem_typesInput = {
    create?: XOR<problems_gradebookCreateWithoutProblem_typesInput, problems_gradebookUncheckedCreateWithoutProblem_typesInput> | problems_gradebookCreateWithoutProblem_typesInput[] | problems_gradebookUncheckedCreateWithoutProblem_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutProblem_typesInput | problems_gradebookCreateOrConnectWithoutProblem_typesInput[]
    createMany?: problems_gradebookCreateManyProblem_typesInputEnvelope
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
  }

  export type problems_gradebookUpdateManyWithoutProblem_typesNestedInput = {
    create?: XOR<problems_gradebookCreateWithoutProblem_typesInput, problems_gradebookUncheckedCreateWithoutProblem_typesInput> | problems_gradebookCreateWithoutProblem_typesInput[] | problems_gradebookUncheckedCreateWithoutProblem_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutProblem_typesInput | problems_gradebookCreateOrConnectWithoutProblem_typesInput[]
    upsert?: problems_gradebookUpsertWithWhereUniqueWithoutProblem_typesInput | problems_gradebookUpsertWithWhereUniqueWithoutProblem_typesInput[]
    createMany?: problems_gradebookCreateManyProblem_typesInputEnvelope
    set?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    disconnect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    delete?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    update?: problems_gradebookUpdateWithWhereUniqueWithoutProblem_typesInput | problems_gradebookUpdateWithWhereUniqueWithoutProblem_typesInput[]
    updateMany?: problems_gradebookUpdateManyWithWhereWithoutProblem_typesInput | problems_gradebookUpdateManyWithWhereWithoutProblem_typesInput[]
    deleteMany?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
  }

  export type problems_gradebookUncheckedUpdateManyWithoutProblem_typesNestedInput = {
    create?: XOR<problems_gradebookCreateWithoutProblem_typesInput, problems_gradebookUncheckedCreateWithoutProblem_typesInput> | problems_gradebookCreateWithoutProblem_typesInput[] | problems_gradebookUncheckedCreateWithoutProblem_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutProblem_typesInput | problems_gradebookCreateOrConnectWithoutProblem_typesInput[]
    upsert?: problems_gradebookUpsertWithWhereUniqueWithoutProblem_typesInput | problems_gradebookUpsertWithWhereUniqueWithoutProblem_typesInput[]
    createMany?: problems_gradebookCreateManyProblem_typesInputEnvelope
    set?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    disconnect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    delete?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    update?: problems_gradebookUpdateWithWhereUniqueWithoutProblem_typesInput | problems_gradebookUpdateWithWhereUniqueWithoutProblem_typesInput[]
    updateMany?: problems_gradebookUpdateManyWithWhereWithoutProblem_typesInput | problems_gradebookUpdateManyWithWhereWithoutProblem_typesInput[]
    deleteMany?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
  }

  export type problem_typesCreateNestedOneWithoutProblems_gradebookInput = {
    create?: XOR<problem_typesCreateWithoutProblems_gradebookInput, problem_typesUncheckedCreateWithoutProblems_gradebookInput>
    connectOrCreate?: problem_typesCreateOrConnectWithoutProblems_gradebookInput
    connect?: problem_typesWhereUniqueInput
  }

  export type user_typesCreateNestedOneWithoutProblems_gradebookInput = {
    create?: XOR<user_typesCreateWithoutProblems_gradebookInput, user_typesUncheckedCreateWithoutProblems_gradebookInput>
    connectOrCreate?: user_typesCreateOrConnectWithoutProblems_gradebookInput
    connect?: user_typesWhereUniqueInput
  }

  export type statusesCreateNestedOneWithoutProblems_gradebookInput = {
    create?: XOR<statusesCreateWithoutProblems_gradebookInput, statusesUncheckedCreateWithoutProblems_gradebookInput>
    connectOrCreate?: statusesCreateOrConnectWithoutProblems_gradebookInput
    connect?: statusesWhereUniqueInput
  }

  export type problem_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput = {
    create?: XOR<problem_typesCreateWithoutProblems_gradebookInput, problem_typesUncheckedCreateWithoutProblems_gradebookInput>
    connectOrCreate?: problem_typesCreateOrConnectWithoutProblems_gradebookInput
    upsert?: problem_typesUpsertWithoutProblems_gradebookInput
    connect?: problem_typesWhereUniqueInput
    update?: XOR<XOR<problem_typesUpdateToOneWithWhereWithoutProblems_gradebookInput, problem_typesUpdateWithoutProblems_gradebookInput>, problem_typesUncheckedUpdateWithoutProblems_gradebookInput>
  }

  export type user_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput = {
    create?: XOR<user_typesCreateWithoutProblems_gradebookInput, user_typesUncheckedCreateWithoutProblems_gradebookInput>
    connectOrCreate?: user_typesCreateOrConnectWithoutProblems_gradebookInput
    upsert?: user_typesUpsertWithoutProblems_gradebookInput
    connect?: user_typesWhereUniqueInput
    update?: XOR<XOR<user_typesUpdateToOneWithWhereWithoutProblems_gradebookInput, user_typesUpdateWithoutProblems_gradebookInput>, user_typesUncheckedUpdateWithoutProblems_gradebookInput>
  }

  export type statusesUpdateOneRequiredWithoutProblems_gradebookNestedInput = {
    create?: XOR<statusesCreateWithoutProblems_gradebookInput, statusesUncheckedCreateWithoutProblems_gradebookInput>
    connectOrCreate?: statusesCreateOrConnectWithoutProblems_gradebookInput
    upsert?: statusesUpsertWithoutProblems_gradebookInput
    connect?: statusesWhereUniqueInput
    update?: XOR<XOR<statusesUpdateToOneWithWhereWithoutProblems_gradebookInput, statusesUpdateWithoutProblems_gradebookInput>, statusesUncheckedUpdateWithoutProblems_gradebookInput>
  }

  export type event_typesCreateNestedOneWithoutSchool_eventsInput = {
    create?: XOR<event_typesCreateWithoutSchool_eventsInput, event_typesUncheckedCreateWithoutSchool_eventsInput>
    connectOrCreate?: event_typesCreateOrConnectWithoutSchool_eventsInput
    connect?: event_typesWhereUniqueInput
  }

  export type event_typesUpdateOneRequiredWithoutSchool_eventsNestedInput = {
    create?: XOR<event_typesCreateWithoutSchool_eventsInput, event_typesUncheckedCreateWithoutSchool_eventsInput>
    connectOrCreate?: event_typesCreateOrConnectWithoutSchool_eventsInput
    upsert?: event_typesUpsertWithoutSchool_eventsInput
    connect?: event_typesWhereUniqueInput
    update?: XOR<XOR<event_typesUpdateToOneWithWhereWithoutSchool_eventsInput, event_typesUpdateWithoutSchool_eventsInput>, event_typesUncheckedUpdateWithoutSchool_eventsInput>
  }

  export type problems_gradebookCreateNestedManyWithoutStatusesInput = {
    create?: XOR<problems_gradebookCreateWithoutStatusesInput, problems_gradebookUncheckedCreateWithoutStatusesInput> | problems_gradebookCreateWithoutStatusesInput[] | problems_gradebookUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutStatusesInput | problems_gradebookCreateOrConnectWithoutStatusesInput[]
    createMany?: problems_gradebookCreateManyStatusesInputEnvelope
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
  }

  export type problems_gradebookUncheckedCreateNestedManyWithoutStatusesInput = {
    create?: XOR<problems_gradebookCreateWithoutStatusesInput, problems_gradebookUncheckedCreateWithoutStatusesInput> | problems_gradebookCreateWithoutStatusesInput[] | problems_gradebookUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutStatusesInput | problems_gradebookCreateOrConnectWithoutStatusesInput[]
    createMany?: problems_gradebookCreateManyStatusesInputEnvelope
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
  }

  export type problems_gradebookUpdateManyWithoutStatusesNestedInput = {
    create?: XOR<problems_gradebookCreateWithoutStatusesInput, problems_gradebookUncheckedCreateWithoutStatusesInput> | problems_gradebookCreateWithoutStatusesInput[] | problems_gradebookUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutStatusesInput | problems_gradebookCreateOrConnectWithoutStatusesInput[]
    upsert?: problems_gradebookUpsertWithWhereUniqueWithoutStatusesInput | problems_gradebookUpsertWithWhereUniqueWithoutStatusesInput[]
    createMany?: problems_gradebookCreateManyStatusesInputEnvelope
    set?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    disconnect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    delete?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    update?: problems_gradebookUpdateWithWhereUniqueWithoutStatusesInput | problems_gradebookUpdateWithWhereUniqueWithoutStatusesInput[]
    updateMany?: problems_gradebookUpdateManyWithWhereWithoutStatusesInput | problems_gradebookUpdateManyWithWhereWithoutStatusesInput[]
    deleteMany?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
  }

  export type problems_gradebookUncheckedUpdateManyWithoutStatusesNestedInput = {
    create?: XOR<problems_gradebookCreateWithoutStatusesInput, problems_gradebookUncheckedCreateWithoutStatusesInput> | problems_gradebookCreateWithoutStatusesInput[] | problems_gradebookUncheckedCreateWithoutStatusesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutStatusesInput | problems_gradebookCreateOrConnectWithoutStatusesInput[]
    upsert?: problems_gradebookUpsertWithWhereUniqueWithoutStatusesInput | problems_gradebookUpsertWithWhereUniqueWithoutStatusesInput[]
    createMany?: problems_gradebookCreateManyStatusesInputEnvelope
    set?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    disconnect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    delete?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    update?: problems_gradebookUpdateWithWhereUniqueWithoutStatusesInput | problems_gradebookUpdateWithWhereUniqueWithoutStatusesInput[]
    updateMany?: problems_gradebookUpdateManyWithWhereWithoutStatusesInput | problems_gradebookUpdateManyWithWhereWithoutStatusesInput[]
    deleteMany?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
  }

  export type attemptsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attemptsCreateWithoutStudentsInput, attemptsUncheckedCreateWithoutStudentsInput> | attemptsCreateWithoutStudentsInput[] | attemptsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutStudentsInput | attemptsCreateOrConnectWithoutStudentsInput[]
    createMany?: attemptsCreateManyStudentsInputEnvelope
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
  }

  export type attendancesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type badges_historyCreateNestedManyWithoutStudentsInput = {
    create?: XOR<badges_historyCreateWithoutStudentsInput, badges_historyUncheckedCreateWithoutStudentsInput> | badges_historyCreateWithoutStudentsInput[] | badges_historyUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutStudentsInput | badges_historyCreateOrConnectWithoutStudentsInput[]
    createMany?: badges_historyCreateManyStudentsInputEnvelope
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
  }

  export type final_gradesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<final_gradesCreateWithoutStudentsInput, final_gradesUncheckedCreateWithoutStudentsInput> | final_gradesCreateWithoutStudentsInput[] | final_gradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutStudentsInput | final_gradesCreateOrConnectWithoutStudentsInput[]
    createMany?: final_gradesCreateManyStudentsInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type grades_examsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<grades_examsCreateWithoutStudentsInput, grades_examsUncheckedCreateWithoutStudentsInput> | grades_examsCreateWithoutStudentsInput[] | grades_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutStudentsInput | grades_examsCreateOrConnectWithoutStudentsInput[]
    createMany?: grades_examsCreateManyStudentsInputEnvelope
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
  }

  export type grades_gradebookCreateNestedManyWithoutStudentsInput = {
    create?: XOR<grades_gradebookCreateWithoutStudentsInput, grades_gradebookUncheckedCreateWithoutStudentsInput> | grades_gradebookCreateWithoutStudentsInput[] | grades_gradebookUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutStudentsInput | grades_gradebookCreateOrConnectWithoutStudentsInput[]
    createMany?: grades_gradebookCreateManyStudentsInputEnvelope
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<notificationsCreateWithoutStudentsInput, notificationsUncheckedCreateWithoutStudentsInput> | notificationsCreateWithoutStudentsInput[] | notificationsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutStudentsInput | notificationsCreateOrConnectWithoutStudentsInput[]
    createMany?: notificationsCreateManyStudentsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type questions_responsesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<questions_responsesCreateWithoutStudentsInput, questions_responsesUncheckedCreateWithoutStudentsInput> | questions_responsesCreateWithoutStudentsInput[] | questions_responsesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutStudentsInput | questions_responsesCreateOrConnectWithoutStudentsInput[]
    createMany?: questions_responsesCreateManyStudentsInputEnvelope
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
  }

  export type student_closed_answersCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_closed_answersCreateWithoutStudentsInput, student_closed_answersUncheckedCreateWithoutStudentsInput> | student_closed_answersCreateWithoutStudentsInput[] | student_closed_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutStudentsInput | student_closed_answersCreateOrConnectWithoutStudentsInput[]
    createMany?: student_closed_answersCreateManyStudentsInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type student_open_answersCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_open_answersCreateWithoutStudentsInput, student_open_answersUncheckedCreateWithoutStudentsInput> | student_open_answersCreateWithoutStudentsInput[] | student_open_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutStudentsInput | student_open_answersCreateOrConnectWithoutStudentsInput[]
    createMany?: student_open_answersCreateManyStudentsInputEnvelope
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
  }

  export type classesCreateNestedOneWithoutStudentsInput = {
    create?: XOR<classesCreateWithoutStudentsInput, classesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: classesCreateOrConnectWithoutStudentsInput
    connect?: classesWhereUniqueInput
  }

  export type students_examsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<students_examsCreateWithoutStudentsInput, students_examsUncheckedCreateWithoutStudentsInput> | students_examsCreateWithoutStudentsInput[] | students_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutStudentsInput | students_examsCreateOrConnectWithoutStudentsInput[]
    createMany?: students_examsCreateManyStudentsInputEnvelope
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
  }

  export type students_parentsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<students_parentsCreateWithoutStudentsInput, students_parentsUncheckedCreateWithoutStudentsInput> | students_parentsCreateWithoutStudentsInput[] | students_parentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutStudentsInput | students_parentsCreateOrConnectWithoutStudentsInput[]
    createMany?: students_parentsCreateManyStudentsInputEnvelope
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
  }

  export type attemptsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attemptsCreateWithoutStudentsInput, attemptsUncheckedCreateWithoutStudentsInput> | attemptsCreateWithoutStudentsInput[] | attemptsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutStudentsInput | attemptsCreateOrConnectWithoutStudentsInput[]
    createMany?: attemptsCreateManyStudentsInputEnvelope
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
  }

  export type attendancesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
  }

  export type badges_historyUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<badges_historyCreateWithoutStudentsInput, badges_historyUncheckedCreateWithoutStudentsInput> | badges_historyCreateWithoutStudentsInput[] | badges_historyUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutStudentsInput | badges_historyCreateOrConnectWithoutStudentsInput[]
    createMany?: badges_historyCreateManyStudentsInputEnvelope
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
  }

  export type final_gradesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<final_gradesCreateWithoutStudentsInput, final_gradesUncheckedCreateWithoutStudentsInput> | final_gradesCreateWithoutStudentsInput[] | final_gradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutStudentsInput | final_gradesCreateOrConnectWithoutStudentsInput[]
    createMany?: final_gradesCreateManyStudentsInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type grades_examsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<grades_examsCreateWithoutStudentsInput, grades_examsUncheckedCreateWithoutStudentsInput> | grades_examsCreateWithoutStudentsInput[] | grades_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutStudentsInput | grades_examsCreateOrConnectWithoutStudentsInput[]
    createMany?: grades_examsCreateManyStudentsInputEnvelope
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
  }

  export type grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<grades_gradebookCreateWithoutStudentsInput, grades_gradebookUncheckedCreateWithoutStudentsInput> | grades_gradebookCreateWithoutStudentsInput[] | grades_gradebookUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutStudentsInput | grades_gradebookCreateOrConnectWithoutStudentsInput[]
    createMany?: grades_gradebookCreateManyStudentsInputEnvelope
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<notificationsCreateWithoutStudentsInput, notificationsUncheckedCreateWithoutStudentsInput> | notificationsCreateWithoutStudentsInput[] | notificationsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutStudentsInput | notificationsCreateOrConnectWithoutStudentsInput[]
    createMany?: notificationsCreateManyStudentsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type questions_responsesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<questions_responsesCreateWithoutStudentsInput, questions_responsesUncheckedCreateWithoutStudentsInput> | questions_responsesCreateWithoutStudentsInput[] | questions_responsesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutStudentsInput | questions_responsesCreateOrConnectWithoutStudentsInput[]
    createMany?: questions_responsesCreateManyStudentsInputEnvelope
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
  }

  export type student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_closed_answersCreateWithoutStudentsInput, student_closed_answersUncheckedCreateWithoutStudentsInput> | student_closed_answersCreateWithoutStudentsInput[] | student_closed_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutStudentsInput | student_closed_answersCreateOrConnectWithoutStudentsInput[]
    createMany?: student_closed_answersCreateManyStudentsInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type student_open_answersUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_open_answersCreateWithoutStudentsInput, student_open_answersUncheckedCreateWithoutStudentsInput> | student_open_answersCreateWithoutStudentsInput[] | student_open_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutStudentsInput | student_open_answersCreateOrConnectWithoutStudentsInput[]
    createMany?: student_open_answersCreateManyStudentsInputEnvelope
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
  }

  export type students_examsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<students_examsCreateWithoutStudentsInput, students_examsUncheckedCreateWithoutStudentsInput> | students_examsCreateWithoutStudentsInput[] | students_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutStudentsInput | students_examsCreateOrConnectWithoutStudentsInput[]
    createMany?: students_examsCreateManyStudentsInputEnvelope
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
  }

  export type students_parentsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<students_parentsCreateWithoutStudentsInput, students_parentsUncheckedCreateWithoutStudentsInput> | students_parentsCreateWithoutStudentsInput[] | students_parentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutStudentsInput | students_parentsCreateOrConnectWithoutStudentsInput[]
    createMany?: students_parentsCreateManyStudentsInputEnvelope
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
  }

  export type attemptsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attemptsCreateWithoutStudentsInput, attemptsUncheckedCreateWithoutStudentsInput> | attemptsCreateWithoutStudentsInput[] | attemptsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutStudentsInput | attemptsCreateOrConnectWithoutStudentsInput[]
    upsert?: attemptsUpsertWithWhereUniqueWithoutStudentsInput | attemptsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attemptsCreateManyStudentsInputEnvelope
    set?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    disconnect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    delete?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    update?: attemptsUpdateWithWhereUniqueWithoutStudentsInput | attemptsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attemptsUpdateManyWithWhereWithoutStudentsInput | attemptsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attemptsScalarWhereInput | attemptsScalarWhereInput[]
  }

  export type attendancesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutStudentsInput | attendancesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutStudentsInput | attendancesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutStudentsInput | attendancesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type badges_historyUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<badges_historyCreateWithoutStudentsInput, badges_historyUncheckedCreateWithoutStudentsInput> | badges_historyCreateWithoutStudentsInput[] | badges_historyUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutStudentsInput | badges_historyCreateOrConnectWithoutStudentsInput[]
    upsert?: badges_historyUpsertWithWhereUniqueWithoutStudentsInput | badges_historyUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: badges_historyCreateManyStudentsInputEnvelope
    set?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    disconnect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    delete?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    update?: badges_historyUpdateWithWhereUniqueWithoutStudentsInput | badges_historyUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: badges_historyUpdateManyWithWhereWithoutStudentsInput | badges_historyUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: badges_historyScalarWhereInput | badges_historyScalarWhereInput[]
  }

  export type final_gradesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<final_gradesCreateWithoutStudentsInput, final_gradesUncheckedCreateWithoutStudentsInput> | final_gradesCreateWithoutStudentsInput[] | final_gradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutStudentsInput | final_gradesCreateOrConnectWithoutStudentsInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutStudentsInput | final_gradesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: final_gradesCreateManyStudentsInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutStudentsInput | final_gradesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutStudentsInput | final_gradesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type grades_examsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<grades_examsCreateWithoutStudentsInput, grades_examsUncheckedCreateWithoutStudentsInput> | grades_examsCreateWithoutStudentsInput[] | grades_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutStudentsInput | grades_examsCreateOrConnectWithoutStudentsInput[]
    upsert?: grades_examsUpsertWithWhereUniqueWithoutStudentsInput | grades_examsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: grades_examsCreateManyStudentsInputEnvelope
    set?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    disconnect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    delete?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    update?: grades_examsUpdateWithWhereUniqueWithoutStudentsInput | grades_examsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: grades_examsUpdateManyWithWhereWithoutStudentsInput | grades_examsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: grades_examsScalarWhereInput | grades_examsScalarWhereInput[]
  }

  export type grades_gradebookUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<grades_gradebookCreateWithoutStudentsInput, grades_gradebookUncheckedCreateWithoutStudentsInput> | grades_gradebookCreateWithoutStudentsInput[] | grades_gradebookUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutStudentsInput | grades_gradebookCreateOrConnectWithoutStudentsInput[]
    upsert?: grades_gradebookUpsertWithWhereUniqueWithoutStudentsInput | grades_gradebookUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: grades_gradebookCreateManyStudentsInputEnvelope
    set?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    disconnect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    delete?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    update?: grades_gradebookUpdateWithWhereUniqueWithoutStudentsInput | grades_gradebookUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: grades_gradebookUpdateManyWithWhereWithoutStudentsInput | grades_gradebookUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<notificationsCreateWithoutStudentsInput, notificationsUncheckedCreateWithoutStudentsInput> | notificationsCreateWithoutStudentsInput[] | notificationsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutStudentsInput | notificationsCreateOrConnectWithoutStudentsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutStudentsInput | notificationsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: notificationsCreateManyStudentsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutStudentsInput | notificationsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutStudentsInput | notificationsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type questions_responsesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<questions_responsesCreateWithoutStudentsInput, questions_responsesUncheckedCreateWithoutStudentsInput> | questions_responsesCreateWithoutStudentsInput[] | questions_responsesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutStudentsInput | questions_responsesCreateOrConnectWithoutStudentsInput[]
    upsert?: questions_responsesUpsertWithWhereUniqueWithoutStudentsInput | questions_responsesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: questions_responsesCreateManyStudentsInputEnvelope
    set?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    disconnect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    delete?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    update?: questions_responsesUpdateWithWhereUniqueWithoutStudentsInput | questions_responsesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: questions_responsesUpdateManyWithWhereWithoutStudentsInput | questions_responsesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: questions_responsesScalarWhereInput | questions_responsesScalarWhereInput[]
  }

  export type student_closed_answersUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutStudentsInput, student_closed_answersUncheckedCreateWithoutStudentsInput> | student_closed_answersCreateWithoutStudentsInput[] | student_closed_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutStudentsInput | student_closed_answersCreateOrConnectWithoutStudentsInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutStudentsInput | student_closed_answersUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_closed_answersCreateManyStudentsInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutStudentsInput | student_closed_answersUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutStudentsInput | student_closed_answersUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type student_open_answersUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_open_answersCreateWithoutStudentsInput, student_open_answersUncheckedCreateWithoutStudentsInput> | student_open_answersCreateWithoutStudentsInput[] | student_open_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutStudentsInput | student_open_answersCreateOrConnectWithoutStudentsInput[]
    upsert?: student_open_answersUpsertWithWhereUniqueWithoutStudentsInput | student_open_answersUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_open_answersCreateManyStudentsInputEnvelope
    set?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    disconnect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    delete?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    update?: student_open_answersUpdateWithWhereUniqueWithoutStudentsInput | student_open_answersUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_open_answersUpdateManyWithWhereWithoutStudentsInput | student_open_answersUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
  }

  export type classesUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<classesCreateWithoutStudentsInput, classesUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: classesCreateOrConnectWithoutStudentsInput
    upsert?: classesUpsertWithoutStudentsInput
    disconnect?: classesWhereInput | boolean
    delete?: classesWhereInput | boolean
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutStudentsInput, classesUpdateWithoutStudentsInput>, classesUncheckedUpdateWithoutStudentsInput>
  }

  export type students_examsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<students_examsCreateWithoutStudentsInput, students_examsUncheckedCreateWithoutStudentsInput> | students_examsCreateWithoutStudentsInput[] | students_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutStudentsInput | students_examsCreateOrConnectWithoutStudentsInput[]
    upsert?: students_examsUpsertWithWhereUniqueWithoutStudentsInput | students_examsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: students_examsCreateManyStudentsInputEnvelope
    set?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    disconnect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    delete?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    update?: students_examsUpdateWithWhereUniqueWithoutStudentsInput | students_examsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: students_examsUpdateManyWithWhereWithoutStudentsInput | students_examsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: students_examsScalarWhereInput | students_examsScalarWhereInput[]
  }

  export type students_parentsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<students_parentsCreateWithoutStudentsInput, students_parentsUncheckedCreateWithoutStudentsInput> | students_parentsCreateWithoutStudentsInput[] | students_parentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutStudentsInput | students_parentsCreateOrConnectWithoutStudentsInput[]
    upsert?: students_parentsUpsertWithWhereUniqueWithoutStudentsInput | students_parentsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: students_parentsCreateManyStudentsInputEnvelope
    set?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    disconnect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    delete?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    update?: students_parentsUpdateWithWhereUniqueWithoutStudentsInput | students_parentsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: students_parentsUpdateManyWithWhereWithoutStudentsInput | students_parentsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: students_parentsScalarWhereInput | students_parentsScalarWhereInput[]
  }

  export type attemptsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attemptsCreateWithoutStudentsInput, attemptsUncheckedCreateWithoutStudentsInput> | attemptsCreateWithoutStudentsInput[] | attemptsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutStudentsInput | attemptsCreateOrConnectWithoutStudentsInput[]
    upsert?: attemptsUpsertWithWhereUniqueWithoutStudentsInput | attemptsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attemptsCreateManyStudentsInputEnvelope
    set?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    disconnect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    delete?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    update?: attemptsUpdateWithWhereUniqueWithoutStudentsInput | attemptsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attemptsUpdateManyWithWhereWithoutStudentsInput | attemptsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attemptsScalarWhereInput | attemptsScalarWhereInput[]
  }

  export type attendancesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput> | attendancesCreateWithoutStudentsInput[] | attendancesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendancesCreateOrConnectWithoutStudentsInput | attendancesCreateOrConnectWithoutStudentsInput[]
    upsert?: attendancesUpsertWithWhereUniqueWithoutStudentsInput | attendancesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attendancesCreateManyStudentsInputEnvelope
    set?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    disconnect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    delete?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    connect?: attendancesWhereUniqueInput | attendancesWhereUniqueInput[]
    update?: attendancesUpdateWithWhereUniqueWithoutStudentsInput | attendancesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attendancesUpdateManyWithWhereWithoutStudentsInput | attendancesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
  }

  export type badges_historyUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<badges_historyCreateWithoutStudentsInput, badges_historyUncheckedCreateWithoutStudentsInput> | badges_historyCreateWithoutStudentsInput[] | badges_historyUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: badges_historyCreateOrConnectWithoutStudentsInput | badges_historyCreateOrConnectWithoutStudentsInput[]
    upsert?: badges_historyUpsertWithWhereUniqueWithoutStudentsInput | badges_historyUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: badges_historyCreateManyStudentsInputEnvelope
    set?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    disconnect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    delete?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    connect?: badges_historyWhereUniqueInput | badges_historyWhereUniqueInput[]
    update?: badges_historyUpdateWithWhereUniqueWithoutStudentsInput | badges_historyUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: badges_historyUpdateManyWithWhereWithoutStudentsInput | badges_historyUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: badges_historyScalarWhereInput | badges_historyScalarWhereInput[]
  }

  export type final_gradesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<final_gradesCreateWithoutStudentsInput, final_gradesUncheckedCreateWithoutStudentsInput> | final_gradesCreateWithoutStudentsInput[] | final_gradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutStudentsInput | final_gradesCreateOrConnectWithoutStudentsInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutStudentsInput | final_gradesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: final_gradesCreateManyStudentsInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutStudentsInput | final_gradesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutStudentsInput | final_gradesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type grades_examsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<grades_examsCreateWithoutStudentsInput, grades_examsUncheckedCreateWithoutStudentsInput> | grades_examsCreateWithoutStudentsInput[] | grades_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutStudentsInput | grades_examsCreateOrConnectWithoutStudentsInput[]
    upsert?: grades_examsUpsertWithWhereUniqueWithoutStudentsInput | grades_examsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: grades_examsCreateManyStudentsInputEnvelope
    set?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    disconnect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    delete?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    update?: grades_examsUpdateWithWhereUniqueWithoutStudentsInput | grades_examsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: grades_examsUpdateManyWithWhereWithoutStudentsInput | grades_examsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: grades_examsScalarWhereInput | grades_examsScalarWhereInput[]
  }

  export type grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<grades_gradebookCreateWithoutStudentsInput, grades_gradebookUncheckedCreateWithoutStudentsInput> | grades_gradebookCreateWithoutStudentsInput[] | grades_gradebookUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutStudentsInput | grades_gradebookCreateOrConnectWithoutStudentsInput[]
    upsert?: grades_gradebookUpsertWithWhereUniqueWithoutStudentsInput | grades_gradebookUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: grades_gradebookCreateManyStudentsInputEnvelope
    set?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    disconnect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    delete?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    update?: grades_gradebookUpdateWithWhereUniqueWithoutStudentsInput | grades_gradebookUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: grades_gradebookUpdateManyWithWhereWithoutStudentsInput | grades_gradebookUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<notificationsCreateWithoutStudentsInput, notificationsUncheckedCreateWithoutStudentsInput> | notificationsCreateWithoutStudentsInput[] | notificationsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutStudentsInput | notificationsCreateOrConnectWithoutStudentsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutStudentsInput | notificationsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: notificationsCreateManyStudentsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutStudentsInput | notificationsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutStudentsInput | notificationsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<questions_responsesCreateWithoutStudentsInput, questions_responsesUncheckedCreateWithoutStudentsInput> | questions_responsesCreateWithoutStudentsInput[] | questions_responsesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutStudentsInput | questions_responsesCreateOrConnectWithoutStudentsInput[]
    upsert?: questions_responsesUpsertWithWhereUniqueWithoutStudentsInput | questions_responsesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: questions_responsesCreateManyStudentsInputEnvelope
    set?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    disconnect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    delete?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    update?: questions_responsesUpdateWithWhereUniqueWithoutStudentsInput | questions_responsesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: questions_responsesUpdateManyWithWhereWithoutStudentsInput | questions_responsesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: questions_responsesScalarWhereInput | questions_responsesScalarWhereInput[]
  }

  export type student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutStudentsInput, student_closed_answersUncheckedCreateWithoutStudentsInput> | student_closed_answersCreateWithoutStudentsInput[] | student_closed_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutStudentsInput | student_closed_answersCreateOrConnectWithoutStudentsInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutStudentsInput | student_closed_answersUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_closed_answersCreateManyStudentsInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutStudentsInput | student_closed_answersUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutStudentsInput | student_closed_answersUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_open_answersCreateWithoutStudentsInput, student_open_answersUncheckedCreateWithoutStudentsInput> | student_open_answersCreateWithoutStudentsInput[] | student_open_answersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutStudentsInput | student_open_answersCreateOrConnectWithoutStudentsInput[]
    upsert?: student_open_answersUpsertWithWhereUniqueWithoutStudentsInput | student_open_answersUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_open_answersCreateManyStudentsInputEnvelope
    set?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    disconnect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    delete?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    update?: student_open_answersUpdateWithWhereUniqueWithoutStudentsInput | student_open_answersUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_open_answersUpdateManyWithWhereWithoutStudentsInput | student_open_answersUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
  }

  export type students_examsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<students_examsCreateWithoutStudentsInput, students_examsUncheckedCreateWithoutStudentsInput> | students_examsCreateWithoutStudentsInput[] | students_examsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutStudentsInput | students_examsCreateOrConnectWithoutStudentsInput[]
    upsert?: students_examsUpsertWithWhereUniqueWithoutStudentsInput | students_examsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: students_examsCreateManyStudentsInputEnvelope
    set?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    disconnect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    delete?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    update?: students_examsUpdateWithWhereUniqueWithoutStudentsInput | students_examsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: students_examsUpdateManyWithWhereWithoutStudentsInput | students_examsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: students_examsScalarWhereInput | students_examsScalarWhereInput[]
  }

  export type students_parentsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<students_parentsCreateWithoutStudentsInput, students_parentsUncheckedCreateWithoutStudentsInput> | students_parentsCreateWithoutStudentsInput[] | students_parentsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: students_parentsCreateOrConnectWithoutStudentsInput | students_parentsCreateOrConnectWithoutStudentsInput[]
    upsert?: students_parentsUpsertWithWhereUniqueWithoutStudentsInput | students_parentsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: students_parentsCreateManyStudentsInputEnvelope
    set?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    disconnect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    delete?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    connect?: students_parentsWhereUniqueInput | students_parentsWhereUniqueInput[]
    update?: students_parentsUpdateWithWhereUniqueWithoutStudentsInput | students_parentsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: students_parentsUpdateManyWithWhereWithoutStudentsInput | students_parentsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: students_parentsScalarWhereInput | students_parentsScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutStudents_parentsInput = {
    create?: XOR<studentsCreateWithoutStudents_parentsInput, studentsUncheckedCreateWithoutStudents_parentsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudents_parentsInput
    connect?: studentsWhereUniqueInput
  }

  export type parentsCreateNestedOneWithoutStudents_parentsInput = {
    create?: XOR<parentsCreateWithoutStudents_parentsInput, parentsUncheckedCreateWithoutStudents_parentsInput>
    connectOrCreate?: parentsCreateOrConnectWithoutStudents_parentsInput
    connect?: parentsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutStudents_parentsNestedInput = {
    create?: XOR<studentsCreateWithoutStudents_parentsInput, studentsUncheckedCreateWithoutStudents_parentsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudents_parentsInput
    upsert?: studentsUpsertWithoutStudents_parentsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudents_parentsInput, studentsUpdateWithoutStudents_parentsInput>, studentsUncheckedUpdateWithoutStudents_parentsInput>
  }

  export type parentsUpdateOneRequiredWithoutStudents_parentsNestedInput = {
    create?: XOR<parentsCreateWithoutStudents_parentsInput, parentsUncheckedCreateWithoutStudents_parentsInput>
    connectOrCreate?: parentsCreateOrConnectWithoutStudents_parentsInput
    upsert?: parentsUpsertWithoutStudents_parentsInput
    connect?: parentsWhereUniqueInput
    update?: XOR<XOR<parentsUpdateToOneWithWhereWithoutStudents_parentsInput, parentsUpdateWithoutStudents_parentsInput>, parentsUncheckedUpdateWithoutStudents_parentsInput>
  }

  export type final_gradesCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<final_gradesCreateWithoutSubjectsInput, final_gradesUncheckedCreateWithoutSubjectsInput> | final_gradesCreateWithoutSubjectsInput[] | final_gradesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSubjectsInput | final_gradesCreateOrConnectWithoutSubjectsInput[]
    createMany?: final_gradesCreateManySubjectsInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type grades_gradebookCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<grades_gradebookCreateWithoutSubjectsInput, grades_gradebookUncheckedCreateWithoutSubjectsInput> | grades_gradebookCreateWithoutSubjectsInput[] | grades_gradebookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutSubjectsInput | grades_gradebookCreateOrConnectWithoutSubjectsInput[]
    createMany?: grades_gradebookCreateManySubjectsInputEnvelope
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
  }

  export type lessonsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<lessonsCreateWithoutSubjectsInput, lessonsUncheckedCreateWithoutSubjectsInput> | lessonsCreateWithoutSubjectsInput[] | lessonsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutSubjectsInput | lessonsCreateOrConnectWithoutSubjectsInput[]
    createMany?: lessonsCreateManySubjectsInputEnvelope
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
  }

  export type teachers_subjectsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<teachers_subjectsCreateWithoutSubjectsInput, teachers_subjectsUncheckedCreateWithoutSubjectsInput> | teachers_subjectsCreateWithoutSubjectsInput[] | teachers_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutSubjectsInput | teachers_subjectsCreateOrConnectWithoutSubjectsInput[]
    createMany?: teachers_subjectsCreateManySubjectsInputEnvelope
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
  }

  export type final_gradesUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<final_gradesCreateWithoutSubjectsInput, final_gradesUncheckedCreateWithoutSubjectsInput> | final_gradesCreateWithoutSubjectsInput[] | final_gradesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSubjectsInput | final_gradesCreateOrConnectWithoutSubjectsInput[]
    createMany?: final_gradesCreateManySubjectsInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type grades_gradebookUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<grades_gradebookCreateWithoutSubjectsInput, grades_gradebookUncheckedCreateWithoutSubjectsInput> | grades_gradebookCreateWithoutSubjectsInput[] | grades_gradebookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutSubjectsInput | grades_gradebookCreateOrConnectWithoutSubjectsInput[]
    createMany?: grades_gradebookCreateManySubjectsInputEnvelope
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
  }

  export type lessonsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<lessonsCreateWithoutSubjectsInput, lessonsUncheckedCreateWithoutSubjectsInput> | lessonsCreateWithoutSubjectsInput[] | lessonsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutSubjectsInput | lessonsCreateOrConnectWithoutSubjectsInput[]
    createMany?: lessonsCreateManySubjectsInputEnvelope
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
  }

  export type teachers_subjectsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<teachers_subjectsCreateWithoutSubjectsInput, teachers_subjectsUncheckedCreateWithoutSubjectsInput> | teachers_subjectsCreateWithoutSubjectsInput[] | teachers_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutSubjectsInput | teachers_subjectsCreateOrConnectWithoutSubjectsInput[]
    createMany?: teachers_subjectsCreateManySubjectsInputEnvelope
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
  }

  export type final_gradesUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<final_gradesCreateWithoutSubjectsInput, final_gradesUncheckedCreateWithoutSubjectsInput> | final_gradesCreateWithoutSubjectsInput[] | final_gradesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSubjectsInput | final_gradesCreateOrConnectWithoutSubjectsInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutSubjectsInput | final_gradesUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: final_gradesCreateManySubjectsInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutSubjectsInput | final_gradesUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutSubjectsInput | final_gradesUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type grades_gradebookUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<grades_gradebookCreateWithoutSubjectsInput, grades_gradebookUncheckedCreateWithoutSubjectsInput> | grades_gradebookCreateWithoutSubjectsInput[] | grades_gradebookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutSubjectsInput | grades_gradebookCreateOrConnectWithoutSubjectsInput[]
    upsert?: grades_gradebookUpsertWithWhereUniqueWithoutSubjectsInput | grades_gradebookUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: grades_gradebookCreateManySubjectsInputEnvelope
    set?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    disconnect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    delete?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    update?: grades_gradebookUpdateWithWhereUniqueWithoutSubjectsInput | grades_gradebookUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: grades_gradebookUpdateManyWithWhereWithoutSubjectsInput | grades_gradebookUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
  }

  export type lessonsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<lessonsCreateWithoutSubjectsInput, lessonsUncheckedCreateWithoutSubjectsInput> | lessonsCreateWithoutSubjectsInput[] | lessonsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutSubjectsInput | lessonsCreateOrConnectWithoutSubjectsInput[]
    upsert?: lessonsUpsertWithWhereUniqueWithoutSubjectsInput | lessonsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: lessonsCreateManySubjectsInputEnvelope
    set?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    disconnect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    delete?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    update?: lessonsUpdateWithWhereUniqueWithoutSubjectsInput | lessonsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: lessonsUpdateManyWithWhereWithoutSubjectsInput | lessonsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
  }

  export type teachers_subjectsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<teachers_subjectsCreateWithoutSubjectsInput, teachers_subjectsUncheckedCreateWithoutSubjectsInput> | teachers_subjectsCreateWithoutSubjectsInput[] | teachers_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutSubjectsInput | teachers_subjectsCreateOrConnectWithoutSubjectsInput[]
    upsert?: teachers_subjectsUpsertWithWhereUniqueWithoutSubjectsInput | teachers_subjectsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: teachers_subjectsCreateManySubjectsInputEnvelope
    set?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    disconnect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    delete?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    update?: teachers_subjectsUpdateWithWhereUniqueWithoutSubjectsInput | teachers_subjectsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: teachers_subjectsUpdateManyWithWhereWithoutSubjectsInput | teachers_subjectsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: teachers_subjectsScalarWhereInput | teachers_subjectsScalarWhereInput[]
  }

  export type final_gradesUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<final_gradesCreateWithoutSubjectsInput, final_gradesUncheckedCreateWithoutSubjectsInput> | final_gradesCreateWithoutSubjectsInput[] | final_gradesUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSubjectsInput | final_gradesCreateOrConnectWithoutSubjectsInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutSubjectsInput | final_gradesUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: final_gradesCreateManySubjectsInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutSubjectsInput | final_gradesUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutSubjectsInput | final_gradesUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type grades_gradebookUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<grades_gradebookCreateWithoutSubjectsInput, grades_gradebookUncheckedCreateWithoutSubjectsInput> | grades_gradebookCreateWithoutSubjectsInput[] | grades_gradebookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutSubjectsInput | grades_gradebookCreateOrConnectWithoutSubjectsInput[]
    upsert?: grades_gradebookUpsertWithWhereUniqueWithoutSubjectsInput | grades_gradebookUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: grades_gradebookCreateManySubjectsInputEnvelope
    set?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    disconnect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    delete?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    update?: grades_gradebookUpdateWithWhereUniqueWithoutSubjectsInput | grades_gradebookUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: grades_gradebookUpdateManyWithWhereWithoutSubjectsInput | grades_gradebookUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
  }

  export type lessonsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<lessonsCreateWithoutSubjectsInput, lessonsUncheckedCreateWithoutSubjectsInput> | lessonsCreateWithoutSubjectsInput[] | lessonsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutSubjectsInput | lessonsCreateOrConnectWithoutSubjectsInput[]
    upsert?: lessonsUpsertWithWhereUniqueWithoutSubjectsInput | lessonsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: lessonsCreateManySubjectsInputEnvelope
    set?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    disconnect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    delete?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    update?: lessonsUpdateWithWhereUniqueWithoutSubjectsInput | lessonsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: lessonsUpdateManyWithWhereWithoutSubjectsInput | lessonsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
  }

  export type teachers_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<teachers_subjectsCreateWithoutSubjectsInput, teachers_subjectsUncheckedCreateWithoutSubjectsInput> | teachers_subjectsCreateWithoutSubjectsInput[] | teachers_subjectsUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutSubjectsInput | teachers_subjectsCreateOrConnectWithoutSubjectsInput[]
    upsert?: teachers_subjectsUpsertWithWhereUniqueWithoutSubjectsInput | teachers_subjectsUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: teachers_subjectsCreateManySubjectsInputEnvelope
    set?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    disconnect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    delete?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    update?: teachers_subjectsUpdateWithWhereUniqueWithoutSubjectsInput | teachers_subjectsUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: teachers_subjectsUpdateManyWithWhereWithoutSubjectsInput | teachers_subjectsUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: teachers_subjectsScalarWhereInput | teachers_subjectsScalarWhereInput[]
  }

  export type questionsCreateNestedManyWithoutSurveysInput = {
    create?: XOR<questionsCreateWithoutSurveysInput, questionsUncheckedCreateWithoutSurveysInput> | questionsCreateWithoutSurveysInput[] | questionsUncheckedCreateWithoutSurveysInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSurveysInput | questionsCreateOrConnectWithoutSurveysInput[]
    createMany?: questionsCreateManySurveysInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUncheckedCreateNestedManyWithoutSurveysInput = {
    create?: XOR<questionsCreateWithoutSurveysInput, questionsUncheckedCreateWithoutSurveysInput> | questionsCreateWithoutSurveysInput[] | questionsUncheckedCreateWithoutSurveysInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSurveysInput | questionsCreateOrConnectWithoutSurveysInput[]
    createMany?: questionsCreateManySurveysInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutSurveysNestedInput = {
    create?: XOR<questionsCreateWithoutSurveysInput, questionsUncheckedCreateWithoutSurveysInput> | questionsCreateWithoutSurveysInput[] | questionsUncheckedCreateWithoutSurveysInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSurveysInput | questionsCreateOrConnectWithoutSurveysInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutSurveysInput | questionsUpsertWithWhereUniqueWithoutSurveysInput[]
    createMany?: questionsCreateManySurveysInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutSurveysInput | questionsUpdateWithWhereUniqueWithoutSurveysInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutSurveysInput | questionsUpdateManyWithWhereWithoutSurveysInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type questionsUncheckedUpdateManyWithoutSurveysNestedInput = {
    create?: XOR<questionsCreateWithoutSurveysInput, questionsUncheckedCreateWithoutSurveysInput> | questionsCreateWithoutSurveysInput[] | questionsUncheckedCreateWithoutSurveysInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutSurveysInput | questionsCreateOrConnectWithoutSurveysInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutSurveysInput | questionsUpsertWithWhereUniqueWithoutSurveysInput[]
    createMany?: questionsCreateManySurveysInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutSurveysInput | questionsUpdateWithWhereUniqueWithoutSurveysInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutSurveysInput | questionsUpdateManyWithWhereWithoutSurveysInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type classesCreateNestedManyWithoutTeachersInput = {
    create?: XOR<classesCreateWithoutTeachersInput, classesUncheckedCreateWithoutTeachersInput> | classesCreateWithoutTeachersInput[] | classesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutTeachersInput | classesCreateOrConnectWithoutTeachersInput[]
    createMany?: classesCreateManyTeachersInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type examsCreateNestedManyWithoutTeachersInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type final_gradesCreateNestedManyWithoutTeachersInput = {
    create?: XOR<final_gradesCreateWithoutTeachersInput, final_gradesUncheckedCreateWithoutTeachersInput> | final_gradesCreateWithoutTeachersInput[] | final_gradesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutTeachersInput | final_gradesCreateOrConnectWithoutTeachersInput[]
    createMany?: final_gradesCreateManyTeachersInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type grades_gradebookCreateNestedManyWithoutTeachersInput = {
    create?: XOR<grades_gradebookCreateWithoutTeachersInput, grades_gradebookUncheckedCreateWithoutTeachersInput> | grades_gradebookCreateWithoutTeachersInput[] | grades_gradebookUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutTeachersInput | grades_gradebookCreateOrConnectWithoutTeachersInput[]
    createMany?: grades_gradebookCreateManyTeachersInputEnvelope
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
  }

  export type lessonsCreateNestedManyWithoutTeachersInput = {
    create?: XOR<lessonsCreateWithoutTeachersInput, lessonsUncheckedCreateWithoutTeachersInput> | lessonsCreateWithoutTeachersInput[] | lessonsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutTeachersInput | lessonsCreateOrConnectWithoutTeachersInput[]
    createMany?: lessonsCreateManyTeachersInputEnvelope
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
  }

  export type teachers_subjectsCreateNestedManyWithoutTeachersInput = {
    create?: XOR<teachers_subjectsCreateWithoutTeachersInput, teachers_subjectsUncheckedCreateWithoutTeachersInput> | teachers_subjectsCreateWithoutTeachersInput[] | teachers_subjectsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutTeachersInput | teachers_subjectsCreateOrConnectWithoutTeachersInput[]
    createMany?: teachers_subjectsCreateManyTeachersInputEnvelope
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
  }

  export type classesUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<classesCreateWithoutTeachersInput, classesUncheckedCreateWithoutTeachersInput> | classesCreateWithoutTeachersInput[] | classesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutTeachersInput | classesCreateOrConnectWithoutTeachersInput[]
    createMany?: classesCreateManyTeachersInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type examsUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type final_gradesUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<final_gradesCreateWithoutTeachersInput, final_gradesUncheckedCreateWithoutTeachersInput> | final_gradesCreateWithoutTeachersInput[] | final_gradesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutTeachersInput | final_gradesCreateOrConnectWithoutTeachersInput[]
    createMany?: final_gradesCreateManyTeachersInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type grades_gradebookUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<grades_gradebookCreateWithoutTeachersInput, grades_gradebookUncheckedCreateWithoutTeachersInput> | grades_gradebookCreateWithoutTeachersInput[] | grades_gradebookUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutTeachersInput | grades_gradebookCreateOrConnectWithoutTeachersInput[]
    createMany?: grades_gradebookCreateManyTeachersInputEnvelope
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
  }

  export type lessonsUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<lessonsCreateWithoutTeachersInput, lessonsUncheckedCreateWithoutTeachersInput> | lessonsCreateWithoutTeachersInput[] | lessonsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutTeachersInput | lessonsCreateOrConnectWithoutTeachersInput[]
    createMany?: lessonsCreateManyTeachersInputEnvelope
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
  }

  export type teachers_subjectsUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<teachers_subjectsCreateWithoutTeachersInput, teachers_subjectsUncheckedCreateWithoutTeachersInput> | teachers_subjectsCreateWithoutTeachersInput[] | teachers_subjectsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutTeachersInput | teachers_subjectsCreateOrConnectWithoutTeachersInput[]
    createMany?: teachers_subjectsCreateManyTeachersInputEnvelope
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
  }

  export type classesUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<classesCreateWithoutTeachersInput, classesUncheckedCreateWithoutTeachersInput> | classesCreateWithoutTeachersInput[] | classesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutTeachersInput | classesCreateOrConnectWithoutTeachersInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutTeachersInput | classesUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: classesCreateManyTeachersInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutTeachersInput | classesUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: classesUpdateManyWithWhereWithoutTeachersInput | classesUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type examsUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutTeachersInput | examsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutTeachersInput | examsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: examsUpdateManyWithWhereWithoutTeachersInput | examsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type final_gradesUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<final_gradesCreateWithoutTeachersInput, final_gradesUncheckedCreateWithoutTeachersInput> | final_gradesCreateWithoutTeachersInput[] | final_gradesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutTeachersInput | final_gradesCreateOrConnectWithoutTeachersInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutTeachersInput | final_gradesUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: final_gradesCreateManyTeachersInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutTeachersInput | final_gradesUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutTeachersInput | final_gradesUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type grades_gradebookUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<grades_gradebookCreateWithoutTeachersInput, grades_gradebookUncheckedCreateWithoutTeachersInput> | grades_gradebookCreateWithoutTeachersInput[] | grades_gradebookUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutTeachersInput | grades_gradebookCreateOrConnectWithoutTeachersInput[]
    upsert?: grades_gradebookUpsertWithWhereUniqueWithoutTeachersInput | grades_gradebookUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: grades_gradebookCreateManyTeachersInputEnvelope
    set?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    disconnect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    delete?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    update?: grades_gradebookUpdateWithWhereUniqueWithoutTeachersInput | grades_gradebookUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: grades_gradebookUpdateManyWithWhereWithoutTeachersInput | grades_gradebookUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
  }

  export type lessonsUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<lessonsCreateWithoutTeachersInput, lessonsUncheckedCreateWithoutTeachersInput> | lessonsCreateWithoutTeachersInput[] | lessonsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutTeachersInput | lessonsCreateOrConnectWithoutTeachersInput[]
    upsert?: lessonsUpsertWithWhereUniqueWithoutTeachersInput | lessonsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: lessonsCreateManyTeachersInputEnvelope
    set?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    disconnect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    delete?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    update?: lessonsUpdateWithWhereUniqueWithoutTeachersInput | lessonsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: lessonsUpdateManyWithWhereWithoutTeachersInput | lessonsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
  }

  export type teachers_subjectsUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<teachers_subjectsCreateWithoutTeachersInput, teachers_subjectsUncheckedCreateWithoutTeachersInput> | teachers_subjectsCreateWithoutTeachersInput[] | teachers_subjectsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutTeachersInput | teachers_subjectsCreateOrConnectWithoutTeachersInput[]
    upsert?: teachers_subjectsUpsertWithWhereUniqueWithoutTeachersInput | teachers_subjectsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: teachers_subjectsCreateManyTeachersInputEnvelope
    set?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    disconnect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    delete?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    update?: teachers_subjectsUpdateWithWhereUniqueWithoutTeachersInput | teachers_subjectsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: teachers_subjectsUpdateManyWithWhereWithoutTeachersInput | teachers_subjectsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: teachers_subjectsScalarWhereInput | teachers_subjectsScalarWhereInput[]
  }

  export type classesUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<classesCreateWithoutTeachersInput, classesUncheckedCreateWithoutTeachersInput> | classesCreateWithoutTeachersInput[] | classesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: classesCreateOrConnectWithoutTeachersInput | classesCreateOrConnectWithoutTeachersInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutTeachersInput | classesUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: classesCreateManyTeachersInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutTeachersInput | classesUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: classesUpdateManyWithWhereWithoutTeachersInput | classesUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type examsUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutTeachersInput | examsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutTeachersInput | examsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: examsUpdateManyWithWhereWithoutTeachersInput | examsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type final_gradesUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<final_gradesCreateWithoutTeachersInput, final_gradesUncheckedCreateWithoutTeachersInput> | final_gradesCreateWithoutTeachersInput[] | final_gradesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutTeachersInput | final_gradesCreateOrConnectWithoutTeachersInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutTeachersInput | final_gradesUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: final_gradesCreateManyTeachersInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutTeachersInput | final_gradesUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutTeachersInput | final_gradesUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type grades_gradebookUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<grades_gradebookCreateWithoutTeachersInput, grades_gradebookUncheckedCreateWithoutTeachersInput> | grades_gradebookCreateWithoutTeachersInput[] | grades_gradebookUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: grades_gradebookCreateOrConnectWithoutTeachersInput | grades_gradebookCreateOrConnectWithoutTeachersInput[]
    upsert?: grades_gradebookUpsertWithWhereUniqueWithoutTeachersInput | grades_gradebookUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: grades_gradebookCreateManyTeachersInputEnvelope
    set?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    disconnect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    delete?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    connect?: grades_gradebookWhereUniqueInput | grades_gradebookWhereUniqueInput[]
    update?: grades_gradebookUpdateWithWhereUniqueWithoutTeachersInput | grades_gradebookUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: grades_gradebookUpdateManyWithWhereWithoutTeachersInput | grades_gradebookUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
  }

  export type lessonsUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<lessonsCreateWithoutTeachersInput, lessonsUncheckedCreateWithoutTeachersInput> | lessonsCreateWithoutTeachersInput[] | lessonsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lessonsCreateOrConnectWithoutTeachersInput | lessonsCreateOrConnectWithoutTeachersInput[]
    upsert?: lessonsUpsertWithWhereUniqueWithoutTeachersInput | lessonsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: lessonsCreateManyTeachersInputEnvelope
    set?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    disconnect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    delete?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    connect?: lessonsWhereUniqueInput | lessonsWhereUniqueInput[]
    update?: lessonsUpdateWithWhereUniqueWithoutTeachersInput | lessonsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: lessonsUpdateManyWithWhereWithoutTeachersInput | lessonsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
  }

  export type teachers_subjectsUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<teachers_subjectsCreateWithoutTeachersInput, teachers_subjectsUncheckedCreateWithoutTeachersInput> | teachers_subjectsCreateWithoutTeachersInput[] | teachers_subjectsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: teachers_subjectsCreateOrConnectWithoutTeachersInput | teachers_subjectsCreateOrConnectWithoutTeachersInput[]
    upsert?: teachers_subjectsUpsertWithWhereUniqueWithoutTeachersInput | teachers_subjectsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: teachers_subjectsCreateManyTeachersInputEnvelope
    set?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    disconnect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    delete?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    connect?: teachers_subjectsWhereUniqueInput | teachers_subjectsWhereUniqueInput[]
    update?: teachers_subjectsUpdateWithWhereUniqueWithoutTeachersInput | teachers_subjectsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: teachers_subjectsUpdateManyWithWhereWithoutTeachersInput | teachers_subjectsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: teachers_subjectsScalarWhereInput | teachers_subjectsScalarWhereInput[]
  }

  export type teachersCreateNestedOneWithoutTeachers_subjectsInput = {
    create?: XOR<teachersCreateWithoutTeachers_subjectsInput, teachersUncheckedCreateWithoutTeachers_subjectsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutTeachers_subjectsInput
    connect?: teachersWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutTeachers_subjectsInput = {
    create?: XOR<subjectsCreateWithoutTeachers_subjectsInput, subjectsUncheckedCreateWithoutTeachers_subjectsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTeachers_subjectsInput
    connect?: subjectsWhereUniqueInput
  }

  export type teachersUpdateOneRequiredWithoutTeachers_subjectsNestedInput = {
    create?: XOR<teachersCreateWithoutTeachers_subjectsInput, teachersUncheckedCreateWithoutTeachers_subjectsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutTeachers_subjectsInput
    upsert?: teachersUpsertWithoutTeachers_subjectsInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutTeachers_subjectsInput, teachersUpdateWithoutTeachers_subjectsInput>, teachersUncheckedUpdateWithoutTeachers_subjectsInput>
  }

  export type subjectsUpdateOneRequiredWithoutTeachers_subjectsNestedInput = {
    create?: XOR<subjectsCreateWithoutTeachers_subjectsInput, subjectsUncheckedCreateWithoutTeachers_subjectsInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutTeachers_subjectsInput
    upsert?: subjectsUpsertWithoutTeachers_subjectsInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutTeachers_subjectsInput, subjectsUpdateWithoutTeachers_subjectsInput>, subjectsUncheckedUpdateWithoutTeachers_subjectsInput>
  }

  export type messagesCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_sender_type_idTouser_typesInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type problems_gradebookCreateNestedManyWithoutUser_typesInput = {
    create?: XOR<problems_gradebookCreateWithoutUser_typesInput, problems_gradebookUncheckedCreateWithoutUser_typesInput> | problems_gradebookCreateWithoutUser_typesInput[] | problems_gradebookUncheckedCreateWithoutUser_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutUser_typesInput | problems_gradebookCreateOrConnectWithoutUser_typesInput[]
    createMany?: problems_gradebookCreateManyUser_typesInputEnvelope
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_sender_type_idTouser_typesInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type problems_gradebookUncheckedCreateNestedManyWithoutUser_typesInput = {
    create?: XOR<problems_gradebookCreateWithoutUser_typesInput, problems_gradebookUncheckedCreateWithoutUser_typesInput> | problems_gradebookCreateWithoutUser_typesInput[] | problems_gradebookUncheckedCreateWithoutUser_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutUser_typesInput | problems_gradebookCreateOrConnectWithoutUser_typesInput[]
    createMany?: problems_gradebookCreateManyUser_typesInputEnvelope
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
  }

  export type messagesUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesUpsertWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_sender_type_idTouser_typesInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesUpdateWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesUpdateManyWithWhereWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesUpsertWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesUpdateWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesUpdateManyWithWhereWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type problems_gradebookUpdateManyWithoutUser_typesNestedInput = {
    create?: XOR<problems_gradebookCreateWithoutUser_typesInput, problems_gradebookUncheckedCreateWithoutUser_typesInput> | problems_gradebookCreateWithoutUser_typesInput[] | problems_gradebookUncheckedCreateWithoutUser_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutUser_typesInput | problems_gradebookCreateOrConnectWithoutUser_typesInput[]
    upsert?: problems_gradebookUpsertWithWhereUniqueWithoutUser_typesInput | problems_gradebookUpsertWithWhereUniqueWithoutUser_typesInput[]
    createMany?: problems_gradebookCreateManyUser_typesInputEnvelope
    set?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    disconnect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    delete?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    update?: problems_gradebookUpdateWithWhereUniqueWithoutUser_typesInput | problems_gradebookUpdateWithWhereUniqueWithoutUser_typesInput[]
    updateMany?: problems_gradebookUpdateManyWithWhereWithoutUser_typesInput | problems_gradebookUpdateManyWithWhereWithoutUser_typesInput[]
    deleteMany?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesUpsertWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_sender_type_idTouser_typesInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesUpdateWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUser_types_messages_sender_type_idTouser_typesInput | messagesUpdateManyWithWhereWithoutUser_types_messages_sender_type_idTouser_typesInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput = {
    create?: XOR<messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput> | messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[] | messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesUpsertWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    createMany?: messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesUpdateWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUser_types_messages_receiver_type_idTouser_typesInput | messagesUpdateManyWithWhereWithoutUser_types_messages_receiver_type_idTouser_typesInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type problems_gradebookUncheckedUpdateManyWithoutUser_typesNestedInput = {
    create?: XOR<problems_gradebookCreateWithoutUser_typesInput, problems_gradebookUncheckedCreateWithoutUser_typesInput> | problems_gradebookCreateWithoutUser_typesInput[] | problems_gradebookUncheckedCreateWithoutUser_typesInput[]
    connectOrCreate?: problems_gradebookCreateOrConnectWithoutUser_typesInput | problems_gradebookCreateOrConnectWithoutUser_typesInput[]
    upsert?: problems_gradebookUpsertWithWhereUniqueWithoutUser_typesInput | problems_gradebookUpsertWithWhereUniqueWithoutUser_typesInput[]
    createMany?: problems_gradebookCreateManyUser_typesInputEnvelope
    set?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    disconnect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    delete?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    connect?: problems_gradebookWhereUniqueInput | problems_gradebookWhereUniqueInput[]
    update?: problems_gradebookUpdateWithWhereUniqueWithoutUser_typesInput | problems_gradebookUpdateWithWhereUniqueWithoutUser_typesInput[]
    updateMany?: problems_gradebookUpdateManyWithWhereWithoutUser_typesInput | problems_gradebookUpdateManyWithWhereWithoutUser_typesInput[]
    deleteMany?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
  }

  export type classesCreateNestedManyWithoutSchool_yearsInput = {
    create?: XOR<classesCreateWithoutSchool_yearsInput, classesUncheckedCreateWithoutSchool_yearsInput> | classesCreateWithoutSchool_yearsInput[] | classesUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: classesCreateOrConnectWithoutSchool_yearsInput | classesCreateOrConnectWithoutSchool_yearsInput[]
    createMany?: classesCreateManySchool_yearsInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type semestersCreateNestedManyWithoutSchool_yearsInput = {
    create?: XOR<semestersCreateWithoutSchool_yearsInput, semestersUncheckedCreateWithoutSchool_yearsInput> | semestersCreateWithoutSchool_yearsInput[] | semestersUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: semestersCreateOrConnectWithoutSchool_yearsInput | semestersCreateOrConnectWithoutSchool_yearsInput[]
    createMany?: semestersCreateManySchool_yearsInputEnvelope
    connect?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
  }

  export type classesUncheckedCreateNestedManyWithoutSchool_yearsInput = {
    create?: XOR<classesCreateWithoutSchool_yearsInput, classesUncheckedCreateWithoutSchool_yearsInput> | classesCreateWithoutSchool_yearsInput[] | classesUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: classesCreateOrConnectWithoutSchool_yearsInput | classesCreateOrConnectWithoutSchool_yearsInput[]
    createMany?: classesCreateManySchool_yearsInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type semestersUncheckedCreateNestedManyWithoutSchool_yearsInput = {
    create?: XOR<semestersCreateWithoutSchool_yearsInput, semestersUncheckedCreateWithoutSchool_yearsInput> | semestersCreateWithoutSchool_yearsInput[] | semestersUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: semestersCreateOrConnectWithoutSchool_yearsInput | semestersCreateOrConnectWithoutSchool_yearsInput[]
    createMany?: semestersCreateManySchool_yearsInputEnvelope
    connect?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
  }

  export type classesUpdateManyWithoutSchool_yearsNestedInput = {
    create?: XOR<classesCreateWithoutSchool_yearsInput, classesUncheckedCreateWithoutSchool_yearsInput> | classesCreateWithoutSchool_yearsInput[] | classesUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: classesCreateOrConnectWithoutSchool_yearsInput | classesCreateOrConnectWithoutSchool_yearsInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutSchool_yearsInput | classesUpsertWithWhereUniqueWithoutSchool_yearsInput[]
    createMany?: classesCreateManySchool_yearsInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutSchool_yearsInput | classesUpdateWithWhereUniqueWithoutSchool_yearsInput[]
    updateMany?: classesUpdateManyWithWhereWithoutSchool_yearsInput | classesUpdateManyWithWhereWithoutSchool_yearsInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type semestersUpdateManyWithoutSchool_yearsNestedInput = {
    create?: XOR<semestersCreateWithoutSchool_yearsInput, semestersUncheckedCreateWithoutSchool_yearsInput> | semestersCreateWithoutSchool_yearsInput[] | semestersUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: semestersCreateOrConnectWithoutSchool_yearsInput | semestersCreateOrConnectWithoutSchool_yearsInput[]
    upsert?: semestersUpsertWithWhereUniqueWithoutSchool_yearsInput | semestersUpsertWithWhereUniqueWithoutSchool_yearsInput[]
    createMany?: semestersCreateManySchool_yearsInputEnvelope
    set?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    disconnect?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    delete?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    connect?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    update?: semestersUpdateWithWhereUniqueWithoutSchool_yearsInput | semestersUpdateWithWhereUniqueWithoutSchool_yearsInput[]
    updateMany?: semestersUpdateManyWithWhereWithoutSchool_yearsInput | semestersUpdateManyWithWhereWithoutSchool_yearsInput[]
    deleteMany?: semestersScalarWhereInput | semestersScalarWhereInput[]
  }

  export type classesUncheckedUpdateManyWithoutSchool_yearsNestedInput = {
    create?: XOR<classesCreateWithoutSchool_yearsInput, classesUncheckedCreateWithoutSchool_yearsInput> | classesCreateWithoutSchool_yearsInput[] | classesUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: classesCreateOrConnectWithoutSchool_yearsInput | classesCreateOrConnectWithoutSchool_yearsInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutSchool_yearsInput | classesUpsertWithWhereUniqueWithoutSchool_yearsInput[]
    createMany?: classesCreateManySchool_yearsInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutSchool_yearsInput | classesUpdateWithWhereUniqueWithoutSchool_yearsInput[]
    updateMany?: classesUpdateManyWithWhereWithoutSchool_yearsInput | classesUpdateManyWithWhereWithoutSchool_yearsInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type semestersUncheckedUpdateManyWithoutSchool_yearsNestedInput = {
    create?: XOR<semestersCreateWithoutSchool_yearsInput, semestersUncheckedCreateWithoutSchool_yearsInput> | semestersCreateWithoutSchool_yearsInput[] | semestersUncheckedCreateWithoutSchool_yearsInput[]
    connectOrCreate?: semestersCreateOrConnectWithoutSchool_yearsInput | semestersCreateOrConnectWithoutSchool_yearsInput[]
    upsert?: semestersUpsertWithWhereUniqueWithoutSchool_yearsInput | semestersUpsertWithWhereUniqueWithoutSchool_yearsInput[]
    createMany?: semestersCreateManySchool_yearsInputEnvelope
    set?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    disconnect?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    delete?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    connect?: semestersWhereUniqueInput | semestersWhereUniqueInput[]
    update?: semestersUpdateWithWhereUniqueWithoutSchool_yearsInput | semestersUpdateWithWhereUniqueWithoutSchool_yearsInput[]
    updateMany?: semestersUpdateManyWithWhereWithoutSchool_yearsInput | semestersUpdateManyWithWhereWithoutSchool_yearsInput[]
    deleteMany?: semestersScalarWhereInput | semestersScalarWhereInput[]
  }

  export type final_gradesCreateNestedManyWithoutSemestersInput = {
    create?: XOR<final_gradesCreateWithoutSemestersInput, final_gradesUncheckedCreateWithoutSemestersInput> | final_gradesCreateWithoutSemestersInput[] | final_gradesUncheckedCreateWithoutSemestersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSemestersInput | final_gradesCreateOrConnectWithoutSemestersInput[]
    createMany?: final_gradesCreateManySemestersInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type school_yearsCreateNestedOneWithoutSemestersInput = {
    create?: XOR<school_yearsCreateWithoutSemestersInput, school_yearsUncheckedCreateWithoutSemestersInput>
    connectOrCreate?: school_yearsCreateOrConnectWithoutSemestersInput
    connect?: school_yearsWhereUniqueInput
  }

  export type final_gradesUncheckedCreateNestedManyWithoutSemestersInput = {
    create?: XOR<final_gradesCreateWithoutSemestersInput, final_gradesUncheckedCreateWithoutSemestersInput> | final_gradesCreateWithoutSemestersInput[] | final_gradesUncheckedCreateWithoutSemestersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSemestersInput | final_gradesCreateOrConnectWithoutSemestersInput[]
    createMany?: final_gradesCreateManySemestersInputEnvelope
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
  }

  export type final_gradesUpdateManyWithoutSemestersNestedInput = {
    create?: XOR<final_gradesCreateWithoutSemestersInput, final_gradesUncheckedCreateWithoutSemestersInput> | final_gradesCreateWithoutSemestersInput[] | final_gradesUncheckedCreateWithoutSemestersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSemestersInput | final_gradesCreateOrConnectWithoutSemestersInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutSemestersInput | final_gradesUpsertWithWhereUniqueWithoutSemestersInput[]
    createMany?: final_gradesCreateManySemestersInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutSemestersInput | final_gradesUpdateWithWhereUniqueWithoutSemestersInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutSemestersInput | final_gradesUpdateManyWithWhereWithoutSemestersInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type school_yearsUpdateOneRequiredWithoutSemestersNestedInput = {
    create?: XOR<school_yearsCreateWithoutSemestersInput, school_yearsUncheckedCreateWithoutSemestersInput>
    connectOrCreate?: school_yearsCreateOrConnectWithoutSemestersInput
    upsert?: school_yearsUpsertWithoutSemestersInput
    connect?: school_yearsWhereUniqueInput
    update?: XOR<XOR<school_yearsUpdateToOneWithWhereWithoutSemestersInput, school_yearsUpdateWithoutSemestersInput>, school_yearsUncheckedUpdateWithoutSemestersInput>
  }

  export type final_gradesUncheckedUpdateManyWithoutSemestersNestedInput = {
    create?: XOR<final_gradesCreateWithoutSemestersInput, final_gradesUncheckedCreateWithoutSemestersInput> | final_gradesCreateWithoutSemestersInput[] | final_gradesUncheckedCreateWithoutSemestersInput[]
    connectOrCreate?: final_gradesCreateOrConnectWithoutSemestersInput | final_gradesCreateOrConnectWithoutSemestersInput[]
    upsert?: final_gradesUpsertWithWhereUniqueWithoutSemestersInput | final_gradesUpsertWithWhereUniqueWithoutSemestersInput[]
    createMany?: final_gradesCreateManySemestersInputEnvelope
    set?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    disconnect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    delete?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    connect?: final_gradesWhereUniqueInput | final_gradesWhereUniqueInput[]
    update?: final_gradesUpdateWithWhereUniqueWithoutSemestersInput | final_gradesUpdateWithWhereUniqueWithoutSemestersInput[]
    updateMany?: final_gradesUpdateManyWithWhereWithoutSemestersInput | final_gradesUpdateManyWithWhereWithoutSemestersInput[]
    deleteMany?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
  }

  export type classesCreateNestedManyWithoutClass_namesInput = {
    create?: XOR<classesCreateWithoutClass_namesInput, classesUncheckedCreateWithoutClass_namesInput> | classesCreateWithoutClass_namesInput[] | classesUncheckedCreateWithoutClass_namesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutClass_namesInput | classesCreateOrConnectWithoutClass_namesInput[]
    createMany?: classesCreateManyClass_namesInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type classesUncheckedCreateNestedManyWithoutClass_namesInput = {
    create?: XOR<classesCreateWithoutClass_namesInput, classesUncheckedCreateWithoutClass_namesInput> | classesCreateWithoutClass_namesInput[] | classesUncheckedCreateWithoutClass_namesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutClass_namesInput | classesCreateOrConnectWithoutClass_namesInput[]
    createMany?: classesCreateManyClass_namesInputEnvelope
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
  }

  export type classesUpdateManyWithoutClass_namesNestedInput = {
    create?: XOR<classesCreateWithoutClass_namesInput, classesUncheckedCreateWithoutClass_namesInput> | classesCreateWithoutClass_namesInput[] | classesUncheckedCreateWithoutClass_namesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutClass_namesInput | classesCreateOrConnectWithoutClass_namesInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutClass_namesInput | classesUpsertWithWhereUniqueWithoutClass_namesInput[]
    createMany?: classesCreateManyClass_namesInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutClass_namesInput | classesUpdateWithWhereUniqueWithoutClass_namesInput[]
    updateMany?: classesUpdateManyWithWhereWithoutClass_namesInput | classesUpdateManyWithWhereWithoutClass_namesInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type classesUncheckedUpdateManyWithoutClass_namesNestedInput = {
    create?: XOR<classesCreateWithoutClass_namesInput, classesUncheckedCreateWithoutClass_namesInput> | classesCreateWithoutClass_namesInput[] | classesUncheckedCreateWithoutClass_namesInput[]
    connectOrCreate?: classesCreateOrConnectWithoutClass_namesInput | classesCreateOrConnectWithoutClass_namesInput[]
    upsert?: classesUpsertWithWhereUniqueWithoutClass_namesInput | classesUpsertWithWhereUniqueWithoutClass_namesInput[]
    createMany?: classesCreateManyClass_namesInputEnvelope
    set?: classesWhereUniqueInput | classesWhereUniqueInput[]
    disconnect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    delete?: classesWhereUniqueInput | classesWhereUniqueInput[]
    connect?: classesWhereUniqueInput | classesWhereUniqueInput[]
    update?: classesUpdateWithWhereUniqueWithoutClass_namesInput | classesUpdateWithWhereUniqueWithoutClass_namesInput[]
    updateMany?: classesUpdateManyWithWhereWithoutClass_namesInput | classesUpdateManyWithWhereWithoutClass_namesInput[]
    deleteMany?: classesScalarWhereInput | classesScalarWhereInput[]
  }

  export type attemptsCreateNestedManyWithoutExamsInput = {
    create?: XOR<attemptsCreateWithoutExamsInput, attemptsUncheckedCreateWithoutExamsInput> | attemptsCreateWithoutExamsInput[] | attemptsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutExamsInput | attemptsCreateOrConnectWithoutExamsInput[]
    createMany?: attemptsCreateManyExamsInputEnvelope
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
  }

  export type classes_examsCreateNestedManyWithoutExamsInput = {
    create?: XOR<classes_examsCreateWithoutExamsInput, classes_examsUncheckedCreateWithoutExamsInput> | classes_examsCreateWithoutExamsInput[] | classes_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutExamsInput | classes_examsCreateOrConnectWithoutExamsInput[]
    createMany?: classes_examsCreateManyExamsInputEnvelope
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
  }

  export type closed_questionsCreateNestedManyWithoutExamsInput = {
    create?: XOR<closed_questionsCreateWithoutExamsInput, closed_questionsUncheckedCreateWithoutExamsInput> | closed_questionsCreateWithoutExamsInput[] | closed_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: closed_questionsCreateOrConnectWithoutExamsInput | closed_questionsCreateOrConnectWithoutExamsInput[]
    createMany?: closed_questionsCreateManyExamsInputEnvelope
    connect?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
  }

  export type lessonsCreateNestedOneWithoutExamsInput = {
    create?: XOR<lessonsCreateWithoutExamsInput, lessonsUncheckedCreateWithoutExamsInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutExamsInput
    connect?: lessonsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutExamsInput = {
    create?: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutExamsInput
    connect?: teachersWhereUniqueInput
  }

  export type files_repositoryCreateNestedManyWithoutExamsInput = {
    create?: XOR<files_repositoryCreateWithoutExamsInput, files_repositoryUncheckedCreateWithoutExamsInput> | files_repositoryCreateWithoutExamsInput[] | files_repositoryUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: files_repositoryCreateOrConnectWithoutExamsInput | files_repositoryCreateOrConnectWithoutExamsInput[]
    createMany?: files_repositoryCreateManyExamsInputEnvelope
    connect?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
  }

  export type grades_examsCreateNestedManyWithoutExamsInput = {
    create?: XOR<grades_examsCreateWithoutExamsInput, grades_examsUncheckedCreateWithoutExamsInput> | grades_examsCreateWithoutExamsInput[] | grades_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutExamsInput | grades_examsCreateOrConnectWithoutExamsInput[]
    createMany?: grades_examsCreateManyExamsInputEnvelope
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutExamsInput = {
    create?: XOR<notificationsCreateWithoutExamsInput, notificationsUncheckedCreateWithoutExamsInput> | notificationsCreateWithoutExamsInput[] | notificationsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutExamsInput | notificationsCreateOrConnectWithoutExamsInput[]
    createMany?: notificationsCreateManyExamsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type open_questionsCreateNestedManyWithoutExamsInput = {
    create?: XOR<open_questionsCreateWithoutExamsInput, open_questionsUncheckedCreateWithoutExamsInput> | open_questionsCreateWithoutExamsInput[] | open_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: open_questionsCreateOrConnectWithoutExamsInput | open_questionsCreateOrConnectWithoutExamsInput[]
    createMany?: open_questionsCreateManyExamsInputEnvelope
    connect?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
  }

  export type students_examsCreateNestedManyWithoutExamsInput = {
    create?: XOR<students_examsCreateWithoutExamsInput, students_examsUncheckedCreateWithoutExamsInput> | students_examsCreateWithoutExamsInput[] | students_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutExamsInput | students_examsCreateOrConnectWithoutExamsInput[]
    createMany?: students_examsCreateManyExamsInputEnvelope
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
  }

  export type attemptsUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<attemptsCreateWithoutExamsInput, attemptsUncheckedCreateWithoutExamsInput> | attemptsCreateWithoutExamsInput[] | attemptsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutExamsInput | attemptsCreateOrConnectWithoutExamsInput[]
    createMany?: attemptsCreateManyExamsInputEnvelope
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
  }

  export type classes_examsUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<classes_examsCreateWithoutExamsInput, classes_examsUncheckedCreateWithoutExamsInput> | classes_examsCreateWithoutExamsInput[] | classes_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutExamsInput | classes_examsCreateOrConnectWithoutExamsInput[]
    createMany?: classes_examsCreateManyExamsInputEnvelope
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
  }

  export type closed_questionsUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<closed_questionsCreateWithoutExamsInput, closed_questionsUncheckedCreateWithoutExamsInput> | closed_questionsCreateWithoutExamsInput[] | closed_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: closed_questionsCreateOrConnectWithoutExamsInput | closed_questionsCreateOrConnectWithoutExamsInput[]
    createMany?: closed_questionsCreateManyExamsInputEnvelope
    connect?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
  }

  export type files_repositoryUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<files_repositoryCreateWithoutExamsInput, files_repositoryUncheckedCreateWithoutExamsInput> | files_repositoryCreateWithoutExamsInput[] | files_repositoryUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: files_repositoryCreateOrConnectWithoutExamsInput | files_repositoryCreateOrConnectWithoutExamsInput[]
    createMany?: files_repositoryCreateManyExamsInputEnvelope
    connect?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
  }

  export type grades_examsUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<grades_examsCreateWithoutExamsInput, grades_examsUncheckedCreateWithoutExamsInput> | grades_examsCreateWithoutExamsInput[] | grades_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutExamsInput | grades_examsCreateOrConnectWithoutExamsInput[]
    createMany?: grades_examsCreateManyExamsInputEnvelope
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<notificationsCreateWithoutExamsInput, notificationsUncheckedCreateWithoutExamsInput> | notificationsCreateWithoutExamsInput[] | notificationsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutExamsInput | notificationsCreateOrConnectWithoutExamsInput[]
    createMany?: notificationsCreateManyExamsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type open_questionsUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<open_questionsCreateWithoutExamsInput, open_questionsUncheckedCreateWithoutExamsInput> | open_questionsCreateWithoutExamsInput[] | open_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: open_questionsCreateOrConnectWithoutExamsInput | open_questionsCreateOrConnectWithoutExamsInput[]
    createMany?: open_questionsCreateManyExamsInputEnvelope
    connect?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
  }

  export type students_examsUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<students_examsCreateWithoutExamsInput, students_examsUncheckedCreateWithoutExamsInput> | students_examsCreateWithoutExamsInput[] | students_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutExamsInput | students_examsCreateOrConnectWithoutExamsInput[]
    createMany?: students_examsCreateManyExamsInputEnvelope
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type attemptsUpdateManyWithoutExamsNestedInput = {
    create?: XOR<attemptsCreateWithoutExamsInput, attemptsUncheckedCreateWithoutExamsInput> | attemptsCreateWithoutExamsInput[] | attemptsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutExamsInput | attemptsCreateOrConnectWithoutExamsInput[]
    upsert?: attemptsUpsertWithWhereUniqueWithoutExamsInput | attemptsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: attemptsCreateManyExamsInputEnvelope
    set?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    disconnect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    delete?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    update?: attemptsUpdateWithWhereUniqueWithoutExamsInput | attemptsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: attemptsUpdateManyWithWhereWithoutExamsInput | attemptsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: attemptsScalarWhereInput | attemptsScalarWhereInput[]
  }

  export type classes_examsUpdateManyWithoutExamsNestedInput = {
    create?: XOR<classes_examsCreateWithoutExamsInput, classes_examsUncheckedCreateWithoutExamsInput> | classes_examsCreateWithoutExamsInput[] | classes_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutExamsInput | classes_examsCreateOrConnectWithoutExamsInput[]
    upsert?: classes_examsUpsertWithWhereUniqueWithoutExamsInput | classes_examsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: classes_examsCreateManyExamsInputEnvelope
    set?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    disconnect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    delete?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    update?: classes_examsUpdateWithWhereUniqueWithoutExamsInput | classes_examsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: classes_examsUpdateManyWithWhereWithoutExamsInput | classes_examsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: classes_examsScalarWhereInput | classes_examsScalarWhereInput[]
  }

  export type closed_questionsUpdateManyWithoutExamsNestedInput = {
    create?: XOR<closed_questionsCreateWithoutExamsInput, closed_questionsUncheckedCreateWithoutExamsInput> | closed_questionsCreateWithoutExamsInput[] | closed_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: closed_questionsCreateOrConnectWithoutExamsInput | closed_questionsCreateOrConnectWithoutExamsInput[]
    upsert?: closed_questionsUpsertWithWhereUniqueWithoutExamsInput | closed_questionsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: closed_questionsCreateManyExamsInputEnvelope
    set?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    disconnect?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    delete?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    connect?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    update?: closed_questionsUpdateWithWhereUniqueWithoutExamsInput | closed_questionsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: closed_questionsUpdateManyWithWhereWithoutExamsInput | closed_questionsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: closed_questionsScalarWhereInput | closed_questionsScalarWhereInput[]
  }

  export type lessonsUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<lessonsCreateWithoutExamsInput, lessonsUncheckedCreateWithoutExamsInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutExamsInput
    upsert?: lessonsUpsertWithoutExamsInput
    connect?: lessonsWhereUniqueInput
    update?: XOR<XOR<lessonsUpdateToOneWithWhereWithoutExamsInput, lessonsUpdateWithoutExamsInput>, lessonsUncheckedUpdateWithoutExamsInput>
  }

  export type teachersUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutExamsInput
    upsert?: teachersUpsertWithoutExamsInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutExamsInput, teachersUpdateWithoutExamsInput>, teachersUncheckedUpdateWithoutExamsInput>
  }

  export type files_repositoryUpdateManyWithoutExamsNestedInput = {
    create?: XOR<files_repositoryCreateWithoutExamsInput, files_repositoryUncheckedCreateWithoutExamsInput> | files_repositoryCreateWithoutExamsInput[] | files_repositoryUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: files_repositoryCreateOrConnectWithoutExamsInput | files_repositoryCreateOrConnectWithoutExamsInput[]
    upsert?: files_repositoryUpsertWithWhereUniqueWithoutExamsInput | files_repositoryUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: files_repositoryCreateManyExamsInputEnvelope
    set?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    disconnect?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    delete?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    connect?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    update?: files_repositoryUpdateWithWhereUniqueWithoutExamsInput | files_repositoryUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: files_repositoryUpdateManyWithWhereWithoutExamsInput | files_repositoryUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: files_repositoryScalarWhereInput | files_repositoryScalarWhereInput[]
  }

  export type grades_examsUpdateManyWithoutExamsNestedInput = {
    create?: XOR<grades_examsCreateWithoutExamsInput, grades_examsUncheckedCreateWithoutExamsInput> | grades_examsCreateWithoutExamsInput[] | grades_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutExamsInput | grades_examsCreateOrConnectWithoutExamsInput[]
    upsert?: grades_examsUpsertWithWhereUniqueWithoutExamsInput | grades_examsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: grades_examsCreateManyExamsInputEnvelope
    set?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    disconnect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    delete?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    update?: grades_examsUpdateWithWhereUniqueWithoutExamsInput | grades_examsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: grades_examsUpdateManyWithWhereWithoutExamsInput | grades_examsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: grades_examsScalarWhereInput | grades_examsScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutExamsNestedInput = {
    create?: XOR<notificationsCreateWithoutExamsInput, notificationsUncheckedCreateWithoutExamsInput> | notificationsCreateWithoutExamsInput[] | notificationsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutExamsInput | notificationsCreateOrConnectWithoutExamsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutExamsInput | notificationsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: notificationsCreateManyExamsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutExamsInput | notificationsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutExamsInput | notificationsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type open_questionsUpdateManyWithoutExamsNestedInput = {
    create?: XOR<open_questionsCreateWithoutExamsInput, open_questionsUncheckedCreateWithoutExamsInput> | open_questionsCreateWithoutExamsInput[] | open_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: open_questionsCreateOrConnectWithoutExamsInput | open_questionsCreateOrConnectWithoutExamsInput[]
    upsert?: open_questionsUpsertWithWhereUniqueWithoutExamsInput | open_questionsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: open_questionsCreateManyExamsInputEnvelope
    set?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    disconnect?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    delete?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    connect?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    update?: open_questionsUpdateWithWhereUniqueWithoutExamsInput | open_questionsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: open_questionsUpdateManyWithWhereWithoutExamsInput | open_questionsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: open_questionsScalarWhereInput | open_questionsScalarWhereInput[]
  }

  export type students_examsUpdateManyWithoutExamsNestedInput = {
    create?: XOR<students_examsCreateWithoutExamsInput, students_examsUncheckedCreateWithoutExamsInput> | students_examsCreateWithoutExamsInput[] | students_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutExamsInput | students_examsCreateOrConnectWithoutExamsInput[]
    upsert?: students_examsUpsertWithWhereUniqueWithoutExamsInput | students_examsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: students_examsCreateManyExamsInputEnvelope
    set?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    disconnect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    delete?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    update?: students_examsUpdateWithWhereUniqueWithoutExamsInput | students_examsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: students_examsUpdateManyWithWhereWithoutExamsInput | students_examsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: students_examsScalarWhereInput | students_examsScalarWhereInput[]
  }

  export type attemptsUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<attemptsCreateWithoutExamsInput, attemptsUncheckedCreateWithoutExamsInput> | attemptsCreateWithoutExamsInput[] | attemptsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: attemptsCreateOrConnectWithoutExamsInput | attemptsCreateOrConnectWithoutExamsInput[]
    upsert?: attemptsUpsertWithWhereUniqueWithoutExamsInput | attemptsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: attemptsCreateManyExamsInputEnvelope
    set?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    disconnect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    delete?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    connect?: attemptsWhereUniqueInput | attemptsWhereUniqueInput[]
    update?: attemptsUpdateWithWhereUniqueWithoutExamsInput | attemptsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: attemptsUpdateManyWithWhereWithoutExamsInput | attemptsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: attemptsScalarWhereInput | attemptsScalarWhereInput[]
  }

  export type classes_examsUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<classes_examsCreateWithoutExamsInput, classes_examsUncheckedCreateWithoutExamsInput> | classes_examsCreateWithoutExamsInput[] | classes_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: classes_examsCreateOrConnectWithoutExamsInput | classes_examsCreateOrConnectWithoutExamsInput[]
    upsert?: classes_examsUpsertWithWhereUniqueWithoutExamsInput | classes_examsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: classes_examsCreateManyExamsInputEnvelope
    set?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    disconnect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    delete?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    connect?: classes_examsWhereUniqueInput | classes_examsWhereUniqueInput[]
    update?: classes_examsUpdateWithWhereUniqueWithoutExamsInput | classes_examsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: classes_examsUpdateManyWithWhereWithoutExamsInput | classes_examsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: classes_examsScalarWhereInput | classes_examsScalarWhereInput[]
  }

  export type closed_questionsUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<closed_questionsCreateWithoutExamsInput, closed_questionsUncheckedCreateWithoutExamsInput> | closed_questionsCreateWithoutExamsInput[] | closed_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: closed_questionsCreateOrConnectWithoutExamsInput | closed_questionsCreateOrConnectWithoutExamsInput[]
    upsert?: closed_questionsUpsertWithWhereUniqueWithoutExamsInput | closed_questionsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: closed_questionsCreateManyExamsInputEnvelope
    set?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    disconnect?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    delete?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    connect?: closed_questionsWhereUniqueInput | closed_questionsWhereUniqueInput[]
    update?: closed_questionsUpdateWithWhereUniqueWithoutExamsInput | closed_questionsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: closed_questionsUpdateManyWithWhereWithoutExamsInput | closed_questionsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: closed_questionsScalarWhereInput | closed_questionsScalarWhereInput[]
  }

  export type files_repositoryUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<files_repositoryCreateWithoutExamsInput, files_repositoryUncheckedCreateWithoutExamsInput> | files_repositoryCreateWithoutExamsInput[] | files_repositoryUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: files_repositoryCreateOrConnectWithoutExamsInput | files_repositoryCreateOrConnectWithoutExamsInput[]
    upsert?: files_repositoryUpsertWithWhereUniqueWithoutExamsInput | files_repositoryUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: files_repositoryCreateManyExamsInputEnvelope
    set?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    disconnect?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    delete?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    connect?: files_repositoryWhereUniqueInput | files_repositoryWhereUniqueInput[]
    update?: files_repositoryUpdateWithWhereUniqueWithoutExamsInput | files_repositoryUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: files_repositoryUpdateManyWithWhereWithoutExamsInput | files_repositoryUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: files_repositoryScalarWhereInput | files_repositoryScalarWhereInput[]
  }

  export type grades_examsUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<grades_examsCreateWithoutExamsInput, grades_examsUncheckedCreateWithoutExamsInput> | grades_examsCreateWithoutExamsInput[] | grades_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: grades_examsCreateOrConnectWithoutExamsInput | grades_examsCreateOrConnectWithoutExamsInput[]
    upsert?: grades_examsUpsertWithWhereUniqueWithoutExamsInput | grades_examsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: grades_examsCreateManyExamsInputEnvelope
    set?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    disconnect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    delete?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    connect?: grades_examsWhereUniqueInput | grades_examsWhereUniqueInput[]
    update?: grades_examsUpdateWithWhereUniqueWithoutExamsInput | grades_examsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: grades_examsUpdateManyWithWhereWithoutExamsInput | grades_examsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: grades_examsScalarWhereInput | grades_examsScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<notificationsCreateWithoutExamsInput, notificationsUncheckedCreateWithoutExamsInput> | notificationsCreateWithoutExamsInput[] | notificationsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutExamsInput | notificationsCreateOrConnectWithoutExamsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutExamsInput | notificationsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: notificationsCreateManyExamsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutExamsInput | notificationsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutExamsInput | notificationsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type open_questionsUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<open_questionsCreateWithoutExamsInput, open_questionsUncheckedCreateWithoutExamsInput> | open_questionsCreateWithoutExamsInput[] | open_questionsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: open_questionsCreateOrConnectWithoutExamsInput | open_questionsCreateOrConnectWithoutExamsInput[]
    upsert?: open_questionsUpsertWithWhereUniqueWithoutExamsInput | open_questionsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: open_questionsCreateManyExamsInputEnvelope
    set?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    disconnect?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    delete?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    connect?: open_questionsWhereUniqueInput | open_questionsWhereUniqueInput[]
    update?: open_questionsUpdateWithWhereUniqueWithoutExamsInput | open_questionsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: open_questionsUpdateManyWithWhereWithoutExamsInput | open_questionsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: open_questionsScalarWhereInput | open_questionsScalarWhereInput[]
  }

  export type students_examsUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<students_examsCreateWithoutExamsInput, students_examsUncheckedCreateWithoutExamsInput> | students_examsCreateWithoutExamsInput[] | students_examsUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: students_examsCreateOrConnectWithoutExamsInput | students_examsCreateOrConnectWithoutExamsInput[]
    upsert?: students_examsUpsertWithWhereUniqueWithoutExamsInput | students_examsUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: students_examsCreateManyExamsInputEnvelope
    set?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    disconnect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    delete?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    connect?: students_examsWhereUniqueInput | students_examsWhereUniqueInput[]
    update?: students_examsUpdateWithWhereUniqueWithoutExamsInput | students_examsUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: students_examsUpdateManyWithWhereWithoutExamsInput | students_examsUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: students_examsScalarWhereInput | students_examsScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutFinal_gradesInput = {
    create?: XOR<studentsCreateWithoutFinal_gradesInput, studentsUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutFinal_gradesInput
    connect?: studentsWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutFinal_gradesInput = {
    create?: XOR<subjectsCreateWithoutFinal_gradesInput, subjectsUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutFinal_gradesInput
    connect?: subjectsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutFinal_gradesInput = {
    create?: XOR<teachersCreateWithoutFinal_gradesInput, teachersUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: teachersCreateOrConnectWithoutFinal_gradesInput
    connect?: teachersWhereUniqueInput
  }

  export type semestersCreateNestedOneWithoutFinal_gradesInput = {
    create?: XOR<semestersCreateWithoutFinal_gradesInput, semestersUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: semestersCreateOrConnectWithoutFinal_gradesInput
    connect?: semestersWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutFinal_gradesNestedInput = {
    create?: XOR<studentsCreateWithoutFinal_gradesInput, studentsUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutFinal_gradesInput
    upsert?: studentsUpsertWithoutFinal_gradesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutFinal_gradesInput, studentsUpdateWithoutFinal_gradesInput>, studentsUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type subjectsUpdateOneRequiredWithoutFinal_gradesNestedInput = {
    create?: XOR<subjectsCreateWithoutFinal_gradesInput, subjectsUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutFinal_gradesInput
    upsert?: subjectsUpsertWithoutFinal_gradesInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutFinal_gradesInput, subjectsUpdateWithoutFinal_gradesInput>, subjectsUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type teachersUpdateOneRequiredWithoutFinal_gradesNestedInput = {
    create?: XOR<teachersCreateWithoutFinal_gradesInput, teachersUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: teachersCreateOrConnectWithoutFinal_gradesInput
    upsert?: teachersUpsertWithoutFinal_gradesInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutFinal_gradesInput, teachersUpdateWithoutFinal_gradesInput>, teachersUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type semestersUpdateOneRequiredWithoutFinal_gradesNestedInput = {
    create?: XOR<semestersCreateWithoutFinal_gradesInput, semestersUncheckedCreateWithoutFinal_gradesInput>
    connectOrCreate?: semestersCreateOrConnectWithoutFinal_gradesInput
    upsert?: semestersUpsertWithoutFinal_gradesInput
    connect?: semestersWhereUniqueInput
    update?: XOR<XOR<semestersUpdateToOneWithWhereWithoutFinal_gradesInput, semestersUpdateWithoutFinal_gradesInput>, semestersUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type surveysCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<surveysCreateWithoutQuestionsInput, surveysUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: surveysCreateOrConnectWithoutQuestionsInput
    connect?: surveysWhereUniqueInput
  }

  export type questions_typesCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<questions_typesCreateWithoutQuestionsInput, questions_typesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: questions_typesCreateOrConnectWithoutQuestionsInput
    connect?: questions_typesWhereUniqueInput
  }

  export type questions_possible_responsesCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<questions_possible_responsesCreateWithoutQuestionsInput, questions_possible_responsesUncheckedCreateWithoutQuestionsInput> | questions_possible_responsesCreateWithoutQuestionsInput[] | questions_possible_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_possible_responsesCreateOrConnectWithoutQuestionsInput | questions_possible_responsesCreateOrConnectWithoutQuestionsInput[]
    createMany?: questions_possible_responsesCreateManyQuestionsInputEnvelope
    connect?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
  }

  export type questions_responsesCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<questions_responsesCreateWithoutQuestionsInput, questions_responsesUncheckedCreateWithoutQuestionsInput> | questions_responsesCreateWithoutQuestionsInput[] | questions_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutQuestionsInput | questions_responsesCreateOrConnectWithoutQuestionsInput[]
    createMany?: questions_responsesCreateManyQuestionsInputEnvelope
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
  }

  export type questions_possible_responsesUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<questions_possible_responsesCreateWithoutQuestionsInput, questions_possible_responsesUncheckedCreateWithoutQuestionsInput> | questions_possible_responsesCreateWithoutQuestionsInput[] | questions_possible_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_possible_responsesCreateOrConnectWithoutQuestionsInput | questions_possible_responsesCreateOrConnectWithoutQuestionsInput[]
    createMany?: questions_possible_responsesCreateManyQuestionsInputEnvelope
    connect?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
  }

  export type questions_responsesUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<questions_responsesCreateWithoutQuestionsInput, questions_responsesUncheckedCreateWithoutQuestionsInput> | questions_responsesCreateWithoutQuestionsInput[] | questions_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutQuestionsInput | questions_responsesCreateOrConnectWithoutQuestionsInput[]
    createMany?: questions_responsesCreateManyQuestionsInputEnvelope
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
  }

  export type surveysUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<surveysCreateWithoutQuestionsInput, surveysUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: surveysCreateOrConnectWithoutQuestionsInput
    upsert?: surveysUpsertWithoutQuestionsInput
    connect?: surveysWhereUniqueInput
    update?: XOR<XOR<surveysUpdateToOneWithWhereWithoutQuestionsInput, surveysUpdateWithoutQuestionsInput>, surveysUncheckedUpdateWithoutQuestionsInput>
  }

  export type questions_typesUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<questions_typesCreateWithoutQuestionsInput, questions_typesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: questions_typesCreateOrConnectWithoutQuestionsInput
    upsert?: questions_typesUpsertWithoutQuestionsInput
    connect?: questions_typesWhereUniqueInput
    update?: XOR<XOR<questions_typesUpdateToOneWithWhereWithoutQuestionsInput, questions_typesUpdateWithoutQuestionsInput>, questions_typesUncheckedUpdateWithoutQuestionsInput>
  }

  export type questions_possible_responsesUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<questions_possible_responsesCreateWithoutQuestionsInput, questions_possible_responsesUncheckedCreateWithoutQuestionsInput> | questions_possible_responsesCreateWithoutQuestionsInput[] | questions_possible_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_possible_responsesCreateOrConnectWithoutQuestionsInput | questions_possible_responsesCreateOrConnectWithoutQuestionsInput[]
    upsert?: questions_possible_responsesUpsertWithWhereUniqueWithoutQuestionsInput | questions_possible_responsesUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: questions_possible_responsesCreateManyQuestionsInputEnvelope
    set?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    disconnect?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    delete?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    connect?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    update?: questions_possible_responsesUpdateWithWhereUniqueWithoutQuestionsInput | questions_possible_responsesUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: questions_possible_responsesUpdateManyWithWhereWithoutQuestionsInput | questions_possible_responsesUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: questions_possible_responsesScalarWhereInput | questions_possible_responsesScalarWhereInput[]
  }

  export type questions_responsesUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<questions_responsesCreateWithoutQuestionsInput, questions_responsesUncheckedCreateWithoutQuestionsInput> | questions_responsesCreateWithoutQuestionsInput[] | questions_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutQuestionsInput | questions_responsesCreateOrConnectWithoutQuestionsInput[]
    upsert?: questions_responsesUpsertWithWhereUniqueWithoutQuestionsInput | questions_responsesUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: questions_responsesCreateManyQuestionsInputEnvelope
    set?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    disconnect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    delete?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    update?: questions_responsesUpdateWithWhereUniqueWithoutQuestionsInput | questions_responsesUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: questions_responsesUpdateManyWithWhereWithoutQuestionsInput | questions_responsesUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: questions_responsesScalarWhereInput | questions_responsesScalarWhereInput[]
  }

  export type questions_possible_responsesUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<questions_possible_responsesCreateWithoutQuestionsInput, questions_possible_responsesUncheckedCreateWithoutQuestionsInput> | questions_possible_responsesCreateWithoutQuestionsInput[] | questions_possible_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_possible_responsesCreateOrConnectWithoutQuestionsInput | questions_possible_responsesCreateOrConnectWithoutQuestionsInput[]
    upsert?: questions_possible_responsesUpsertWithWhereUniqueWithoutQuestionsInput | questions_possible_responsesUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: questions_possible_responsesCreateManyQuestionsInputEnvelope
    set?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    disconnect?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    delete?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    connect?: questions_possible_responsesWhereUniqueInput | questions_possible_responsesWhereUniqueInput[]
    update?: questions_possible_responsesUpdateWithWhereUniqueWithoutQuestionsInput | questions_possible_responsesUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: questions_possible_responsesUpdateManyWithWhereWithoutQuestionsInput | questions_possible_responsesUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: questions_possible_responsesScalarWhereInput | questions_possible_responsesScalarWhereInput[]
  }

  export type questions_responsesUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<questions_responsesCreateWithoutQuestionsInput, questions_responsesUncheckedCreateWithoutQuestionsInput> | questions_responsesCreateWithoutQuestionsInput[] | questions_responsesUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: questions_responsesCreateOrConnectWithoutQuestionsInput | questions_responsesCreateOrConnectWithoutQuestionsInput[]
    upsert?: questions_responsesUpsertWithWhereUniqueWithoutQuestionsInput | questions_responsesUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: questions_responsesCreateManyQuestionsInputEnvelope
    set?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    disconnect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    delete?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    connect?: questions_responsesWhereUniqueInput | questions_responsesWhereUniqueInput[]
    update?: questions_responsesUpdateWithWhereUniqueWithoutQuestionsInput | questions_responsesUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: questions_responsesUpdateManyWithWhereWithoutQuestionsInput | questions_responsesUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: questions_responsesScalarWhereInput | questions_responsesScalarWhereInput[]
  }

  export type questionsCreateNestedOneWithoutQuestions_possible_responsesInput = {
    create?: XOR<questionsCreateWithoutQuestions_possible_responsesInput, questionsUncheckedCreateWithoutQuestions_possible_responsesInput>
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_possible_responsesInput
    connect?: questionsWhereUniqueInput
  }

  export type questionsUpdateOneRequiredWithoutQuestions_possible_responsesNestedInput = {
    create?: XOR<questionsCreateWithoutQuestions_possible_responsesInput, questionsUncheckedCreateWithoutQuestions_possible_responsesInput>
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_possible_responsesInput
    upsert?: questionsUpsertWithoutQuestions_possible_responsesInput
    connect?: questionsWhereUniqueInput
    update?: XOR<XOR<questionsUpdateToOneWithWhereWithoutQuestions_possible_responsesInput, questionsUpdateWithoutQuestions_possible_responsesInput>, questionsUncheckedUpdateWithoutQuestions_possible_responsesInput>
  }

  export type studentsCreateNestedOneWithoutQuestions_responsesInput = {
    create?: XOR<studentsCreateWithoutQuestions_responsesInput, studentsUncheckedCreateWithoutQuestions_responsesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutQuestions_responsesInput
    connect?: studentsWhereUniqueInput
  }

  export type questionsCreateNestedOneWithoutQuestions_responsesInput = {
    create?: XOR<questionsCreateWithoutQuestions_responsesInput, questionsUncheckedCreateWithoutQuestions_responsesInput>
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_responsesInput
    connect?: questionsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutQuestions_responsesNestedInput = {
    create?: XOR<studentsCreateWithoutQuestions_responsesInput, studentsUncheckedCreateWithoutQuestions_responsesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutQuestions_responsesInput
    upsert?: studentsUpsertWithoutQuestions_responsesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutQuestions_responsesInput, studentsUpdateWithoutQuestions_responsesInput>, studentsUncheckedUpdateWithoutQuestions_responsesInput>
  }

  export type questionsUpdateOneRequiredWithoutQuestions_responsesNestedInput = {
    create?: XOR<questionsCreateWithoutQuestions_responsesInput, questionsUncheckedCreateWithoutQuestions_responsesInput>
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_responsesInput
    upsert?: questionsUpsertWithoutQuestions_responsesInput
    connect?: questionsWhereUniqueInput
    update?: XOR<XOR<questionsUpdateToOneWithWhereWithoutQuestions_responsesInput, questionsUpdateWithoutQuestions_responsesInput>, questionsUncheckedUpdateWithoutQuestions_responsesInput>
  }

  export type questionsCreateNestedManyWithoutQuestions_typesInput = {
    create?: XOR<questionsCreateWithoutQuestions_typesInput, questionsUncheckedCreateWithoutQuestions_typesInput> | questionsCreateWithoutQuestions_typesInput[] | questionsUncheckedCreateWithoutQuestions_typesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_typesInput | questionsCreateOrConnectWithoutQuestions_typesInput[]
    createMany?: questionsCreateManyQuestions_typesInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUncheckedCreateNestedManyWithoutQuestions_typesInput = {
    create?: XOR<questionsCreateWithoutQuestions_typesInput, questionsUncheckedCreateWithoutQuestions_typesInput> | questionsCreateWithoutQuestions_typesInput[] | questionsUncheckedCreateWithoutQuestions_typesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_typesInput | questionsCreateOrConnectWithoutQuestions_typesInput[]
    createMany?: questionsCreateManyQuestions_typesInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutQuestions_typesNestedInput = {
    create?: XOR<questionsCreateWithoutQuestions_typesInput, questionsUncheckedCreateWithoutQuestions_typesInput> | questionsCreateWithoutQuestions_typesInput[] | questionsUncheckedCreateWithoutQuestions_typesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_typesInput | questionsCreateOrConnectWithoutQuestions_typesInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestions_typesInput | questionsUpsertWithWhereUniqueWithoutQuestions_typesInput[]
    createMany?: questionsCreateManyQuestions_typesInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestions_typesInput | questionsUpdateWithWhereUniqueWithoutQuestions_typesInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestions_typesInput | questionsUpdateManyWithWhereWithoutQuestions_typesInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type questionsUncheckedUpdateManyWithoutQuestions_typesNestedInput = {
    create?: XOR<questionsCreateWithoutQuestions_typesInput, questionsUncheckedCreateWithoutQuestions_typesInput> | questionsCreateWithoutQuestions_typesInput[] | questionsUncheckedCreateWithoutQuestions_typesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestions_typesInput | questionsCreateOrConnectWithoutQuestions_typesInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestions_typesInput | questionsUpsertWithWhereUniqueWithoutQuestions_typesInput[]
    createMany?: questionsCreateManyQuestions_typesInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestions_typesInput | questionsUpdateWithWhereUniqueWithoutQuestions_typesInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestions_typesInput | questionsUpdateManyWithWhereWithoutQuestions_typesInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type attemptsCreateNestedOneWithoutAttempt_questionsInput = {
    create?: XOR<attemptsCreateWithoutAttempt_questionsInput, attemptsUncheckedCreateWithoutAttempt_questionsInput>
    connectOrCreate?: attemptsCreateOrConnectWithoutAttempt_questionsInput
    connect?: attemptsWhereUniqueInput
  }

  export type open_questionsCreateNestedOneWithoutAttempt_questionsInput = {
    create?: XOR<open_questionsCreateWithoutAttempt_questionsInput, open_questionsUncheckedCreateWithoutAttempt_questionsInput>
    connectOrCreate?: open_questionsCreateOrConnectWithoutAttempt_questionsInput
    connect?: open_questionsWhereUniqueInput
  }

  export type closed_questionsCreateNestedOneWithoutAttempt_questionsInput = {
    create?: XOR<closed_questionsCreateWithoutAttempt_questionsInput, closed_questionsUncheckedCreateWithoutAttempt_questionsInput>
    connectOrCreate?: closed_questionsCreateOrConnectWithoutAttempt_questionsInput
    connect?: closed_questionsWhereUniqueInput
  }

  export type Enumattempt_questions_question_typeFieldUpdateOperationsInput = {
    set?: $Enums.attempt_questions_question_type
  }

  export type attemptsUpdateOneRequiredWithoutAttempt_questionsNestedInput = {
    create?: XOR<attemptsCreateWithoutAttempt_questionsInput, attemptsUncheckedCreateWithoutAttempt_questionsInput>
    connectOrCreate?: attemptsCreateOrConnectWithoutAttempt_questionsInput
    upsert?: attemptsUpsertWithoutAttempt_questionsInput
    connect?: attemptsWhereUniqueInput
    update?: XOR<XOR<attemptsUpdateToOneWithWhereWithoutAttempt_questionsInput, attemptsUpdateWithoutAttempt_questionsInput>, attemptsUncheckedUpdateWithoutAttempt_questionsInput>
  }

  export type open_questionsUpdateOneWithoutAttempt_questionsNestedInput = {
    create?: XOR<open_questionsCreateWithoutAttempt_questionsInput, open_questionsUncheckedCreateWithoutAttempt_questionsInput>
    connectOrCreate?: open_questionsCreateOrConnectWithoutAttempt_questionsInput
    upsert?: open_questionsUpsertWithoutAttempt_questionsInput
    disconnect?: open_questionsWhereInput | boolean
    delete?: open_questionsWhereInput | boolean
    connect?: open_questionsWhereUniqueInput
    update?: XOR<XOR<open_questionsUpdateToOneWithWhereWithoutAttempt_questionsInput, open_questionsUpdateWithoutAttempt_questionsInput>, open_questionsUncheckedUpdateWithoutAttempt_questionsInput>
  }

  export type closed_questionsUpdateOneWithoutAttempt_questionsNestedInput = {
    create?: XOR<closed_questionsCreateWithoutAttempt_questionsInput, closed_questionsUncheckedCreateWithoutAttempt_questionsInput>
    connectOrCreate?: closed_questionsCreateOrConnectWithoutAttempt_questionsInput
    upsert?: closed_questionsUpsertWithoutAttempt_questionsInput
    disconnect?: closed_questionsWhereInput | boolean
    delete?: closed_questionsWhereInput | boolean
    connect?: closed_questionsWhereUniqueInput
    update?: XOR<XOR<closed_questionsUpdateToOneWithWhereWithoutAttempt_questionsInput, closed_questionsUpdateWithoutAttempt_questionsInput>, closed_questionsUncheckedUpdateWithoutAttempt_questionsInput>
  }

  export type attempt_questionsCreateNestedManyWithoutAttemptsInput = {
    create?: XOR<attempt_questionsCreateWithoutAttemptsInput, attempt_questionsUncheckedCreateWithoutAttemptsInput> | attempt_questionsCreateWithoutAttemptsInput[] | attempt_questionsUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutAttemptsInput | attempt_questionsCreateOrConnectWithoutAttemptsInput[]
    createMany?: attempt_questionsCreateManyAttemptsInputEnvelope
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
  }

  export type studentsCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<studentsCreateWithoutAttemptsInput, studentsUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttemptsInput
    connect?: studentsWhereUniqueInput
  }

  export type examsCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<examsCreateWithoutAttemptsInput, examsUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: examsCreateOrConnectWithoutAttemptsInput
    connect?: examsWhereUniqueInput
  }

  export type student_closed_answersCreateNestedManyWithoutAttemptsInput = {
    create?: XOR<student_closed_answersCreateWithoutAttemptsInput, student_closed_answersUncheckedCreateWithoutAttemptsInput> | student_closed_answersCreateWithoutAttemptsInput[] | student_closed_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutAttemptsInput | student_closed_answersCreateOrConnectWithoutAttemptsInput[]
    createMany?: student_closed_answersCreateManyAttemptsInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type student_open_answersCreateNestedManyWithoutAttemptsInput = {
    create?: XOR<student_open_answersCreateWithoutAttemptsInput, student_open_answersUncheckedCreateWithoutAttemptsInput> | student_open_answersCreateWithoutAttemptsInput[] | student_open_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutAttemptsInput | student_open_answersCreateOrConnectWithoutAttemptsInput[]
    createMany?: student_open_answersCreateManyAttemptsInputEnvelope
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
  }

  export type attempt_questionsUncheckedCreateNestedManyWithoutAttemptsInput = {
    create?: XOR<attempt_questionsCreateWithoutAttemptsInput, attempt_questionsUncheckedCreateWithoutAttemptsInput> | attempt_questionsCreateWithoutAttemptsInput[] | attempt_questionsUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutAttemptsInput | attempt_questionsCreateOrConnectWithoutAttemptsInput[]
    createMany?: attempt_questionsCreateManyAttemptsInputEnvelope
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
  }

  export type student_closed_answersUncheckedCreateNestedManyWithoutAttemptsInput = {
    create?: XOR<student_closed_answersCreateWithoutAttemptsInput, student_closed_answersUncheckedCreateWithoutAttemptsInput> | student_closed_answersCreateWithoutAttemptsInput[] | student_closed_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutAttemptsInput | student_closed_answersCreateOrConnectWithoutAttemptsInput[]
    createMany?: student_closed_answersCreateManyAttemptsInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type student_open_answersUncheckedCreateNestedManyWithoutAttemptsInput = {
    create?: XOR<student_open_answersCreateWithoutAttemptsInput, student_open_answersUncheckedCreateWithoutAttemptsInput> | student_open_answersCreateWithoutAttemptsInput[] | student_open_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutAttemptsInput | student_open_answersCreateOrConnectWithoutAttemptsInput[]
    createMany?: student_open_answersCreateManyAttemptsInputEnvelope
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
  }

  export type attempt_questionsUpdateManyWithoutAttemptsNestedInput = {
    create?: XOR<attempt_questionsCreateWithoutAttemptsInput, attempt_questionsUncheckedCreateWithoutAttemptsInput> | attempt_questionsCreateWithoutAttemptsInput[] | attempt_questionsUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutAttemptsInput | attempt_questionsCreateOrConnectWithoutAttemptsInput[]
    upsert?: attempt_questionsUpsertWithWhereUniqueWithoutAttemptsInput | attempt_questionsUpsertWithWhereUniqueWithoutAttemptsInput[]
    createMany?: attempt_questionsCreateManyAttemptsInputEnvelope
    set?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    disconnect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    delete?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    update?: attempt_questionsUpdateWithWhereUniqueWithoutAttemptsInput | attempt_questionsUpdateWithWhereUniqueWithoutAttemptsInput[]
    updateMany?: attempt_questionsUpdateManyWithWhereWithoutAttemptsInput | attempt_questionsUpdateManyWithWhereWithoutAttemptsInput[]
    deleteMany?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
  }

  export type studentsUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<studentsCreateWithoutAttemptsInput, studentsUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttemptsInput
    upsert?: studentsUpsertWithoutAttemptsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutAttemptsInput, studentsUpdateWithoutAttemptsInput>, studentsUncheckedUpdateWithoutAttemptsInput>
  }

  export type examsUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<examsCreateWithoutAttemptsInput, examsUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: examsCreateOrConnectWithoutAttemptsInput
    upsert?: examsUpsertWithoutAttemptsInput
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutAttemptsInput, examsUpdateWithoutAttemptsInput>, examsUncheckedUpdateWithoutAttemptsInput>
  }

  export type student_closed_answersUpdateManyWithoutAttemptsNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutAttemptsInput, student_closed_answersUncheckedCreateWithoutAttemptsInput> | student_closed_answersCreateWithoutAttemptsInput[] | student_closed_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutAttemptsInput | student_closed_answersCreateOrConnectWithoutAttemptsInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutAttemptsInput | student_closed_answersUpsertWithWhereUniqueWithoutAttemptsInput[]
    createMany?: student_closed_answersCreateManyAttemptsInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutAttemptsInput | student_closed_answersUpdateWithWhereUniqueWithoutAttemptsInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutAttemptsInput | student_closed_answersUpdateManyWithWhereWithoutAttemptsInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type student_open_answersUpdateManyWithoutAttemptsNestedInput = {
    create?: XOR<student_open_answersCreateWithoutAttemptsInput, student_open_answersUncheckedCreateWithoutAttemptsInput> | student_open_answersCreateWithoutAttemptsInput[] | student_open_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutAttemptsInput | student_open_answersCreateOrConnectWithoutAttemptsInput[]
    upsert?: student_open_answersUpsertWithWhereUniqueWithoutAttemptsInput | student_open_answersUpsertWithWhereUniqueWithoutAttemptsInput[]
    createMany?: student_open_answersCreateManyAttemptsInputEnvelope
    set?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    disconnect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    delete?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    update?: student_open_answersUpdateWithWhereUniqueWithoutAttemptsInput | student_open_answersUpdateWithWhereUniqueWithoutAttemptsInput[]
    updateMany?: student_open_answersUpdateManyWithWhereWithoutAttemptsInput | student_open_answersUpdateManyWithWhereWithoutAttemptsInput[]
    deleteMany?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
  }

  export type attempt_questionsUncheckedUpdateManyWithoutAttemptsNestedInput = {
    create?: XOR<attempt_questionsCreateWithoutAttemptsInput, attempt_questionsUncheckedCreateWithoutAttemptsInput> | attempt_questionsCreateWithoutAttemptsInput[] | attempt_questionsUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutAttemptsInput | attempt_questionsCreateOrConnectWithoutAttemptsInput[]
    upsert?: attempt_questionsUpsertWithWhereUniqueWithoutAttemptsInput | attempt_questionsUpsertWithWhereUniqueWithoutAttemptsInput[]
    createMany?: attempt_questionsCreateManyAttemptsInputEnvelope
    set?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    disconnect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    delete?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    update?: attempt_questionsUpdateWithWhereUniqueWithoutAttemptsInput | attempt_questionsUpdateWithWhereUniqueWithoutAttemptsInput[]
    updateMany?: attempt_questionsUpdateManyWithWhereWithoutAttemptsInput | attempt_questionsUpdateManyWithWhereWithoutAttemptsInput[]
    deleteMany?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
  }

  export type student_closed_answersUncheckedUpdateManyWithoutAttemptsNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutAttemptsInput, student_closed_answersUncheckedCreateWithoutAttemptsInput> | student_closed_answersCreateWithoutAttemptsInput[] | student_closed_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutAttemptsInput | student_closed_answersCreateOrConnectWithoutAttemptsInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutAttemptsInput | student_closed_answersUpsertWithWhereUniqueWithoutAttemptsInput[]
    createMany?: student_closed_answersCreateManyAttemptsInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutAttemptsInput | student_closed_answersUpdateWithWhereUniqueWithoutAttemptsInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutAttemptsInput | student_closed_answersUpdateManyWithWhereWithoutAttemptsInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type student_open_answersUncheckedUpdateManyWithoutAttemptsNestedInput = {
    create?: XOR<student_open_answersCreateWithoutAttemptsInput, student_open_answersUncheckedCreateWithoutAttemptsInput> | student_open_answersCreateWithoutAttemptsInput[] | student_open_answersUncheckedCreateWithoutAttemptsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutAttemptsInput | student_open_answersCreateOrConnectWithoutAttemptsInput[]
    upsert?: student_open_answersUpsertWithWhereUniqueWithoutAttemptsInput | student_open_answersUpsertWithWhereUniqueWithoutAttemptsInput[]
    createMany?: student_open_answersCreateManyAttemptsInputEnvelope
    set?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    disconnect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    delete?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    update?: student_open_answersUpdateWithWhereUniqueWithoutAttemptsInput | student_open_answersUpdateWithWhereUniqueWithoutAttemptsInput[]
    updateMany?: student_open_answersUpdateManyWithWhereWithoutAttemptsInput | student_open_answersUpdateManyWithWhereWithoutAttemptsInput[]
    deleteMany?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
  }

  export type classesCreateNestedOneWithoutClasses_examsInput = {
    create?: XOR<classesCreateWithoutClasses_examsInput, classesUncheckedCreateWithoutClasses_examsInput>
    connectOrCreate?: classesCreateOrConnectWithoutClasses_examsInput
    connect?: classesWhereUniqueInput
  }

  export type examsCreateNestedOneWithoutClasses_examsInput = {
    create?: XOR<examsCreateWithoutClasses_examsInput, examsUncheckedCreateWithoutClasses_examsInput>
    connectOrCreate?: examsCreateOrConnectWithoutClasses_examsInput
    connect?: examsWhereUniqueInput
  }

  export type classesUpdateOneRequiredWithoutClasses_examsNestedInput = {
    create?: XOR<classesCreateWithoutClasses_examsInput, classesUncheckedCreateWithoutClasses_examsInput>
    connectOrCreate?: classesCreateOrConnectWithoutClasses_examsInput
    upsert?: classesUpsertWithoutClasses_examsInput
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutClasses_examsInput, classesUpdateWithoutClasses_examsInput>, classesUncheckedUpdateWithoutClasses_examsInput>
  }

  export type examsUpdateOneRequiredWithoutClasses_examsNestedInput = {
    create?: XOR<examsCreateWithoutClasses_examsInput, examsUncheckedCreateWithoutClasses_examsInput>
    connectOrCreate?: examsCreateOrConnectWithoutClasses_examsInput
    upsert?: examsUpsertWithoutClasses_examsInput
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutClasses_examsInput, examsUpdateWithoutClasses_examsInput>, examsUncheckedUpdateWithoutClasses_examsInput>
  }

  export type closed_questionsCreateNestedOneWithoutClosed_answersInput = {
    create?: XOR<closed_questionsCreateWithoutClosed_answersInput, closed_questionsUncheckedCreateWithoutClosed_answersInput>
    connectOrCreate?: closed_questionsCreateOrConnectWithoutClosed_answersInput
    connect?: closed_questionsWhereUniqueInput
  }

  export type student_closed_answersCreateNestedManyWithoutClosed_answersInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_answersInput, student_closed_answersUncheckedCreateWithoutClosed_answersInput> | student_closed_answersCreateWithoutClosed_answersInput[] | student_closed_answersUncheckedCreateWithoutClosed_answersInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_answersInput | student_closed_answersCreateOrConnectWithoutClosed_answersInput[]
    createMany?: student_closed_answersCreateManyClosed_answersInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type student_closed_answersUncheckedCreateNestedManyWithoutClosed_answersInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_answersInput, student_closed_answersUncheckedCreateWithoutClosed_answersInput> | student_closed_answersCreateWithoutClosed_answersInput[] | student_closed_answersUncheckedCreateWithoutClosed_answersInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_answersInput | student_closed_answersCreateOrConnectWithoutClosed_answersInput[]
    createMany?: student_closed_answersCreateManyClosed_answersInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type closed_questionsUpdateOneRequiredWithoutClosed_answersNestedInput = {
    create?: XOR<closed_questionsCreateWithoutClosed_answersInput, closed_questionsUncheckedCreateWithoutClosed_answersInput>
    connectOrCreate?: closed_questionsCreateOrConnectWithoutClosed_answersInput
    upsert?: closed_questionsUpsertWithoutClosed_answersInput
    connect?: closed_questionsWhereUniqueInput
    update?: XOR<XOR<closed_questionsUpdateToOneWithWhereWithoutClosed_answersInput, closed_questionsUpdateWithoutClosed_answersInput>, closed_questionsUncheckedUpdateWithoutClosed_answersInput>
  }

  export type student_closed_answersUpdateManyWithoutClosed_answersNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_answersInput, student_closed_answersUncheckedCreateWithoutClosed_answersInput> | student_closed_answersCreateWithoutClosed_answersInput[] | student_closed_answersUncheckedCreateWithoutClosed_answersInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_answersInput | student_closed_answersCreateOrConnectWithoutClosed_answersInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutClosed_answersInput | student_closed_answersUpsertWithWhereUniqueWithoutClosed_answersInput[]
    createMany?: student_closed_answersCreateManyClosed_answersInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutClosed_answersInput | student_closed_answersUpdateWithWhereUniqueWithoutClosed_answersInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutClosed_answersInput | student_closed_answersUpdateManyWithWhereWithoutClosed_answersInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type student_closed_answersUncheckedUpdateManyWithoutClosed_answersNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_answersInput, student_closed_answersUncheckedCreateWithoutClosed_answersInput> | student_closed_answersCreateWithoutClosed_answersInput[] | student_closed_answersUncheckedCreateWithoutClosed_answersInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_answersInput | student_closed_answersCreateOrConnectWithoutClosed_answersInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutClosed_answersInput | student_closed_answersUpsertWithWhereUniqueWithoutClosed_answersInput[]
    createMany?: student_closed_answersCreateManyClosed_answersInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutClosed_answersInput | student_closed_answersUpdateWithWhereUniqueWithoutClosed_answersInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutClosed_answersInput | student_closed_answersUpdateManyWithWhereWithoutClosed_answersInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type attempt_questionsCreateNestedManyWithoutClosed_questionsInput = {
    create?: XOR<attempt_questionsCreateWithoutClosed_questionsInput, attempt_questionsUncheckedCreateWithoutClosed_questionsInput> | attempt_questionsCreateWithoutClosed_questionsInput[] | attempt_questionsUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutClosed_questionsInput | attempt_questionsCreateOrConnectWithoutClosed_questionsInput[]
    createMany?: attempt_questionsCreateManyClosed_questionsInputEnvelope
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
  }

  export type closed_answersCreateNestedManyWithoutClosed_questionsInput = {
    create?: XOR<closed_answersCreateWithoutClosed_questionsInput, closed_answersUncheckedCreateWithoutClosed_questionsInput> | closed_answersCreateWithoutClosed_questionsInput[] | closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: closed_answersCreateOrConnectWithoutClosed_questionsInput | closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    createMany?: closed_answersCreateManyClosed_questionsInputEnvelope
    connect?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
  }

  export type examsCreateNestedOneWithoutClosed_questionsInput = {
    create?: XOR<examsCreateWithoutClosed_questionsInput, examsUncheckedCreateWithoutClosed_questionsInput>
    connectOrCreate?: examsCreateOrConnectWithoutClosed_questionsInput
    connect?: examsWhereUniqueInput
  }

  export type student_closed_answersCreateNestedManyWithoutClosed_questionsInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_questionsInput, student_closed_answersUncheckedCreateWithoutClosed_questionsInput> | student_closed_answersCreateWithoutClosed_questionsInput[] | student_closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_questionsInput | student_closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    createMany?: student_closed_answersCreateManyClosed_questionsInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type attempt_questionsUncheckedCreateNestedManyWithoutClosed_questionsInput = {
    create?: XOR<attempt_questionsCreateWithoutClosed_questionsInput, attempt_questionsUncheckedCreateWithoutClosed_questionsInput> | attempt_questionsCreateWithoutClosed_questionsInput[] | attempt_questionsUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutClosed_questionsInput | attempt_questionsCreateOrConnectWithoutClosed_questionsInput[]
    createMany?: attempt_questionsCreateManyClosed_questionsInputEnvelope
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
  }

  export type closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput = {
    create?: XOR<closed_answersCreateWithoutClosed_questionsInput, closed_answersUncheckedCreateWithoutClosed_questionsInput> | closed_answersCreateWithoutClosed_questionsInput[] | closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: closed_answersCreateOrConnectWithoutClosed_questionsInput | closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    createMany?: closed_answersCreateManyClosed_questionsInputEnvelope
    connect?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
  }

  export type student_closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_questionsInput, student_closed_answersUncheckedCreateWithoutClosed_questionsInput> | student_closed_answersCreateWithoutClosed_questionsInput[] | student_closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_questionsInput | student_closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    createMany?: student_closed_answersCreateManyClosed_questionsInputEnvelope
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
  }

  export type attempt_questionsUpdateManyWithoutClosed_questionsNestedInput = {
    create?: XOR<attempt_questionsCreateWithoutClosed_questionsInput, attempt_questionsUncheckedCreateWithoutClosed_questionsInput> | attempt_questionsCreateWithoutClosed_questionsInput[] | attempt_questionsUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutClosed_questionsInput | attempt_questionsCreateOrConnectWithoutClosed_questionsInput[]
    upsert?: attempt_questionsUpsertWithWhereUniqueWithoutClosed_questionsInput | attempt_questionsUpsertWithWhereUniqueWithoutClosed_questionsInput[]
    createMany?: attempt_questionsCreateManyClosed_questionsInputEnvelope
    set?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    disconnect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    delete?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    update?: attempt_questionsUpdateWithWhereUniqueWithoutClosed_questionsInput | attempt_questionsUpdateWithWhereUniqueWithoutClosed_questionsInput[]
    updateMany?: attempt_questionsUpdateManyWithWhereWithoutClosed_questionsInput | attempt_questionsUpdateManyWithWhereWithoutClosed_questionsInput[]
    deleteMany?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
  }

  export type closed_answersUpdateManyWithoutClosed_questionsNestedInput = {
    create?: XOR<closed_answersCreateWithoutClosed_questionsInput, closed_answersUncheckedCreateWithoutClosed_questionsInput> | closed_answersCreateWithoutClosed_questionsInput[] | closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: closed_answersCreateOrConnectWithoutClosed_questionsInput | closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    upsert?: closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput | closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput[]
    createMany?: closed_answersCreateManyClosed_questionsInputEnvelope
    set?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    disconnect?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    delete?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    connect?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    update?: closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput | closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput[]
    updateMany?: closed_answersUpdateManyWithWhereWithoutClosed_questionsInput | closed_answersUpdateManyWithWhereWithoutClosed_questionsInput[]
    deleteMany?: closed_answersScalarWhereInput | closed_answersScalarWhereInput[]
  }

  export type examsUpdateOneRequiredWithoutClosed_questionsNestedInput = {
    create?: XOR<examsCreateWithoutClosed_questionsInput, examsUncheckedCreateWithoutClosed_questionsInput>
    connectOrCreate?: examsCreateOrConnectWithoutClosed_questionsInput
    upsert?: examsUpsertWithoutClosed_questionsInput
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutClosed_questionsInput, examsUpdateWithoutClosed_questionsInput>, examsUncheckedUpdateWithoutClosed_questionsInput>
  }

  export type student_closed_answersUpdateManyWithoutClosed_questionsNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_questionsInput, student_closed_answersUncheckedCreateWithoutClosed_questionsInput> | student_closed_answersCreateWithoutClosed_questionsInput[] | student_closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_questionsInput | student_closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput | student_closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput[]
    createMany?: student_closed_answersCreateManyClosed_questionsInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput | student_closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutClosed_questionsInput | student_closed_answersUpdateManyWithWhereWithoutClosed_questionsInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type attempt_questionsUncheckedUpdateManyWithoutClosed_questionsNestedInput = {
    create?: XOR<attempt_questionsCreateWithoutClosed_questionsInput, attempt_questionsUncheckedCreateWithoutClosed_questionsInput> | attempt_questionsCreateWithoutClosed_questionsInput[] | attempt_questionsUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutClosed_questionsInput | attempt_questionsCreateOrConnectWithoutClosed_questionsInput[]
    upsert?: attempt_questionsUpsertWithWhereUniqueWithoutClosed_questionsInput | attempt_questionsUpsertWithWhereUniqueWithoutClosed_questionsInput[]
    createMany?: attempt_questionsCreateManyClosed_questionsInputEnvelope
    set?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    disconnect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    delete?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    update?: attempt_questionsUpdateWithWhereUniqueWithoutClosed_questionsInput | attempt_questionsUpdateWithWhereUniqueWithoutClosed_questionsInput[]
    updateMany?: attempt_questionsUpdateManyWithWhereWithoutClosed_questionsInput | attempt_questionsUpdateManyWithWhereWithoutClosed_questionsInput[]
    deleteMany?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
  }

  export type closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput = {
    create?: XOR<closed_answersCreateWithoutClosed_questionsInput, closed_answersUncheckedCreateWithoutClosed_questionsInput> | closed_answersCreateWithoutClosed_questionsInput[] | closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: closed_answersCreateOrConnectWithoutClosed_questionsInput | closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    upsert?: closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput | closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput[]
    createMany?: closed_answersCreateManyClosed_questionsInputEnvelope
    set?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    disconnect?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    delete?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    connect?: closed_answersWhereUniqueInput | closed_answersWhereUniqueInput[]
    update?: closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput | closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput[]
    updateMany?: closed_answersUpdateManyWithWhereWithoutClosed_questionsInput | closed_answersUpdateManyWithWhereWithoutClosed_questionsInput[]
    deleteMany?: closed_answersScalarWhereInput | closed_answersScalarWhereInput[]
  }

  export type student_closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput = {
    create?: XOR<student_closed_answersCreateWithoutClosed_questionsInput, student_closed_answersUncheckedCreateWithoutClosed_questionsInput> | student_closed_answersCreateWithoutClosed_questionsInput[] | student_closed_answersUncheckedCreateWithoutClosed_questionsInput[]
    connectOrCreate?: student_closed_answersCreateOrConnectWithoutClosed_questionsInput | student_closed_answersCreateOrConnectWithoutClosed_questionsInput[]
    upsert?: student_closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput | student_closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput[]
    createMany?: student_closed_answersCreateManyClosed_questionsInputEnvelope
    set?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    disconnect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    delete?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    connect?: student_closed_answersWhereUniqueInput | student_closed_answersWhereUniqueInput[]
    update?: student_closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput | student_closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput[]
    updateMany?: student_closed_answersUpdateManyWithWhereWithoutClosed_questionsInput | student_closed_answersUpdateManyWithWhereWithoutClosed_questionsInput[]
    deleteMany?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
  }

  export type examsCreateNestedOneWithoutFiles_repositoryInput = {
    create?: XOR<examsCreateWithoutFiles_repositoryInput, examsUncheckedCreateWithoutFiles_repositoryInput>
    connectOrCreate?: examsCreateOrConnectWithoutFiles_repositoryInput
    connect?: examsWhereUniqueInput
  }

  export type examsUpdateOneRequiredWithoutFiles_repositoryNestedInput = {
    create?: XOR<examsCreateWithoutFiles_repositoryInput, examsUncheckedCreateWithoutFiles_repositoryInput>
    connectOrCreate?: examsCreateOrConnectWithoutFiles_repositoryInput
    upsert?: examsUpsertWithoutFiles_repositoryInput
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutFiles_repositoryInput, examsUpdateWithoutFiles_repositoryInput>, examsUncheckedUpdateWithoutFiles_repositoryInput>
  }

  export type lessonsCreateNestedOneWithoutGradebook_examsInput = {
    create?: XOR<lessonsCreateWithoutGradebook_examsInput, lessonsUncheckedCreateWithoutGradebook_examsInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutGradebook_examsInput
    connect?: lessonsWhereUniqueInput
  }

  export type lessonsUpdateOneRequiredWithoutGradebook_examsNestedInput = {
    create?: XOR<lessonsCreateWithoutGradebook_examsInput, lessonsUncheckedCreateWithoutGradebook_examsInput>
    connectOrCreate?: lessonsCreateOrConnectWithoutGradebook_examsInput
    upsert?: lessonsUpsertWithoutGradebook_examsInput
    connect?: lessonsWhereUniqueInput
    update?: XOR<XOR<lessonsUpdateToOneWithWhereWithoutGradebook_examsInput, lessonsUpdateWithoutGradebook_examsInput>, lessonsUncheckedUpdateWithoutGradebook_examsInput>
  }

  export type studentsCreateNestedOneWithoutGrades_examsInput = {
    create?: XOR<studentsCreateWithoutGrades_examsInput, studentsUncheckedCreateWithoutGrades_examsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutGrades_examsInput
    connect?: studentsWhereUniqueInput
  }

  export type examsCreateNestedOneWithoutGrades_examsInput = {
    create?: XOR<examsCreateWithoutGrades_examsInput, examsUncheckedCreateWithoutGrades_examsInput>
    connectOrCreate?: examsCreateOrConnectWithoutGrades_examsInput
    connect?: examsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutGrades_examsNestedInput = {
    create?: XOR<studentsCreateWithoutGrades_examsInput, studentsUncheckedCreateWithoutGrades_examsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutGrades_examsInput
    upsert?: studentsUpsertWithoutGrades_examsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutGrades_examsInput, studentsUpdateWithoutGrades_examsInput>, studentsUncheckedUpdateWithoutGrades_examsInput>
  }

  export type examsUpdateOneRequiredWithoutGrades_examsNestedInput = {
    create?: XOR<examsCreateWithoutGrades_examsInput, examsUncheckedCreateWithoutGrades_examsInput>
    connectOrCreate?: examsCreateOrConnectWithoutGrades_examsInput
    upsert?: examsUpsertWithoutGrades_examsInput
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutGrades_examsInput, examsUpdateWithoutGrades_examsInput>, examsUncheckedUpdateWithoutGrades_examsInput>
  }

  export type studentsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<studentsCreateWithoutNotificationsInput, studentsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutNotificationsInput
    connect?: studentsWhereUniqueInput
  }

  export type examsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<examsCreateWithoutNotificationsInput, examsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: examsCreateOrConnectWithoutNotificationsInput
    connect?: examsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<studentsCreateWithoutNotificationsInput, studentsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutNotificationsInput
    upsert?: studentsUpsertWithoutNotificationsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutNotificationsInput, studentsUpdateWithoutNotificationsInput>, studentsUncheckedUpdateWithoutNotificationsInput>
  }

  export type examsUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<examsCreateWithoutNotificationsInput, examsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: examsCreateOrConnectWithoutNotificationsInput
    upsert?: examsUpsertWithoutNotificationsInput
    disconnect?: examsWhereInput | boolean
    delete?: examsWhereInput | boolean
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutNotificationsInput, examsUpdateWithoutNotificationsInput>, examsUncheckedUpdateWithoutNotificationsInput>
  }

  export type open_questionsCreateNestedOneWithoutOpen_answersInput = {
    create?: XOR<open_questionsCreateWithoutOpen_answersInput, open_questionsUncheckedCreateWithoutOpen_answersInput>
    connectOrCreate?: open_questionsCreateOrConnectWithoutOpen_answersInput
    connect?: open_questionsWhereUniqueInput
  }

  export type open_questionsUpdateOneRequiredWithoutOpen_answersNestedInput = {
    create?: XOR<open_questionsCreateWithoutOpen_answersInput, open_questionsUncheckedCreateWithoutOpen_answersInput>
    connectOrCreate?: open_questionsCreateOrConnectWithoutOpen_answersInput
    upsert?: open_questionsUpsertWithoutOpen_answersInput
    connect?: open_questionsWhereUniqueInput
    update?: XOR<XOR<open_questionsUpdateToOneWithWhereWithoutOpen_answersInput, open_questionsUpdateWithoutOpen_answersInput>, open_questionsUncheckedUpdateWithoutOpen_answersInput>
  }

  export type attempt_questionsCreateNestedManyWithoutOpen_questionsInput = {
    create?: XOR<attempt_questionsCreateWithoutOpen_questionsInput, attempt_questionsUncheckedCreateWithoutOpen_questionsInput> | attempt_questionsCreateWithoutOpen_questionsInput[] | attempt_questionsUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutOpen_questionsInput | attempt_questionsCreateOrConnectWithoutOpen_questionsInput[]
    createMany?: attempt_questionsCreateManyOpen_questionsInputEnvelope
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
  }

  export type open_answersCreateNestedManyWithoutOpen_questionsInput = {
    create?: XOR<open_answersCreateWithoutOpen_questionsInput, open_answersUncheckedCreateWithoutOpen_questionsInput> | open_answersCreateWithoutOpen_questionsInput[] | open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: open_answersCreateOrConnectWithoutOpen_questionsInput | open_answersCreateOrConnectWithoutOpen_questionsInput[]
    createMany?: open_answersCreateManyOpen_questionsInputEnvelope
    connect?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
  }

  export type examsCreateNestedOneWithoutOpen_questionsInput = {
    create?: XOR<examsCreateWithoutOpen_questionsInput, examsUncheckedCreateWithoutOpen_questionsInput>
    connectOrCreate?: examsCreateOrConnectWithoutOpen_questionsInput
    connect?: examsWhereUniqueInput
  }

  export type student_open_answersCreateNestedManyWithoutOpen_questionsInput = {
    create?: XOR<student_open_answersCreateWithoutOpen_questionsInput, student_open_answersUncheckedCreateWithoutOpen_questionsInput> | student_open_answersCreateWithoutOpen_questionsInput[] | student_open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutOpen_questionsInput | student_open_answersCreateOrConnectWithoutOpen_questionsInput[]
    createMany?: student_open_answersCreateManyOpen_questionsInputEnvelope
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
  }

  export type attempt_questionsUncheckedCreateNestedManyWithoutOpen_questionsInput = {
    create?: XOR<attempt_questionsCreateWithoutOpen_questionsInput, attempt_questionsUncheckedCreateWithoutOpen_questionsInput> | attempt_questionsCreateWithoutOpen_questionsInput[] | attempt_questionsUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutOpen_questionsInput | attempt_questionsCreateOrConnectWithoutOpen_questionsInput[]
    createMany?: attempt_questionsCreateManyOpen_questionsInputEnvelope
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
  }

  export type open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput = {
    create?: XOR<open_answersCreateWithoutOpen_questionsInput, open_answersUncheckedCreateWithoutOpen_questionsInput> | open_answersCreateWithoutOpen_questionsInput[] | open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: open_answersCreateOrConnectWithoutOpen_questionsInput | open_answersCreateOrConnectWithoutOpen_questionsInput[]
    createMany?: open_answersCreateManyOpen_questionsInputEnvelope
    connect?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
  }

  export type student_open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput = {
    create?: XOR<student_open_answersCreateWithoutOpen_questionsInput, student_open_answersUncheckedCreateWithoutOpen_questionsInput> | student_open_answersCreateWithoutOpen_questionsInput[] | student_open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutOpen_questionsInput | student_open_answersCreateOrConnectWithoutOpen_questionsInput[]
    createMany?: student_open_answersCreateManyOpen_questionsInputEnvelope
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
  }

  export type attempt_questionsUpdateManyWithoutOpen_questionsNestedInput = {
    create?: XOR<attempt_questionsCreateWithoutOpen_questionsInput, attempt_questionsUncheckedCreateWithoutOpen_questionsInput> | attempt_questionsCreateWithoutOpen_questionsInput[] | attempt_questionsUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutOpen_questionsInput | attempt_questionsCreateOrConnectWithoutOpen_questionsInput[]
    upsert?: attempt_questionsUpsertWithWhereUniqueWithoutOpen_questionsInput | attempt_questionsUpsertWithWhereUniqueWithoutOpen_questionsInput[]
    createMany?: attempt_questionsCreateManyOpen_questionsInputEnvelope
    set?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    disconnect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    delete?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    update?: attempt_questionsUpdateWithWhereUniqueWithoutOpen_questionsInput | attempt_questionsUpdateWithWhereUniqueWithoutOpen_questionsInput[]
    updateMany?: attempt_questionsUpdateManyWithWhereWithoutOpen_questionsInput | attempt_questionsUpdateManyWithWhereWithoutOpen_questionsInput[]
    deleteMany?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
  }

  export type open_answersUpdateManyWithoutOpen_questionsNestedInput = {
    create?: XOR<open_answersCreateWithoutOpen_questionsInput, open_answersUncheckedCreateWithoutOpen_questionsInput> | open_answersCreateWithoutOpen_questionsInput[] | open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: open_answersCreateOrConnectWithoutOpen_questionsInput | open_answersCreateOrConnectWithoutOpen_questionsInput[]
    upsert?: open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput | open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput[]
    createMany?: open_answersCreateManyOpen_questionsInputEnvelope
    set?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    disconnect?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    delete?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    connect?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    update?: open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput | open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput[]
    updateMany?: open_answersUpdateManyWithWhereWithoutOpen_questionsInput | open_answersUpdateManyWithWhereWithoutOpen_questionsInput[]
    deleteMany?: open_answersScalarWhereInput | open_answersScalarWhereInput[]
  }

  export type examsUpdateOneRequiredWithoutOpen_questionsNestedInput = {
    create?: XOR<examsCreateWithoutOpen_questionsInput, examsUncheckedCreateWithoutOpen_questionsInput>
    connectOrCreate?: examsCreateOrConnectWithoutOpen_questionsInput
    upsert?: examsUpsertWithoutOpen_questionsInput
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutOpen_questionsInput, examsUpdateWithoutOpen_questionsInput>, examsUncheckedUpdateWithoutOpen_questionsInput>
  }

  export type student_open_answersUpdateManyWithoutOpen_questionsNestedInput = {
    create?: XOR<student_open_answersCreateWithoutOpen_questionsInput, student_open_answersUncheckedCreateWithoutOpen_questionsInput> | student_open_answersCreateWithoutOpen_questionsInput[] | student_open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutOpen_questionsInput | student_open_answersCreateOrConnectWithoutOpen_questionsInput[]
    upsert?: student_open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput | student_open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput[]
    createMany?: student_open_answersCreateManyOpen_questionsInputEnvelope
    set?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    disconnect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    delete?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    update?: student_open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput | student_open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput[]
    updateMany?: student_open_answersUpdateManyWithWhereWithoutOpen_questionsInput | student_open_answersUpdateManyWithWhereWithoutOpen_questionsInput[]
    deleteMany?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
  }

  export type attempt_questionsUncheckedUpdateManyWithoutOpen_questionsNestedInput = {
    create?: XOR<attempt_questionsCreateWithoutOpen_questionsInput, attempt_questionsUncheckedCreateWithoutOpen_questionsInput> | attempt_questionsCreateWithoutOpen_questionsInput[] | attempt_questionsUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: attempt_questionsCreateOrConnectWithoutOpen_questionsInput | attempt_questionsCreateOrConnectWithoutOpen_questionsInput[]
    upsert?: attempt_questionsUpsertWithWhereUniqueWithoutOpen_questionsInput | attempt_questionsUpsertWithWhereUniqueWithoutOpen_questionsInput[]
    createMany?: attempt_questionsCreateManyOpen_questionsInputEnvelope
    set?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    disconnect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    delete?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    connect?: attempt_questionsWhereUniqueInput | attempt_questionsWhereUniqueInput[]
    update?: attempt_questionsUpdateWithWhereUniqueWithoutOpen_questionsInput | attempt_questionsUpdateWithWhereUniqueWithoutOpen_questionsInput[]
    updateMany?: attempt_questionsUpdateManyWithWhereWithoutOpen_questionsInput | attempt_questionsUpdateManyWithWhereWithoutOpen_questionsInput[]
    deleteMany?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
  }

  export type open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput = {
    create?: XOR<open_answersCreateWithoutOpen_questionsInput, open_answersUncheckedCreateWithoutOpen_questionsInput> | open_answersCreateWithoutOpen_questionsInput[] | open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: open_answersCreateOrConnectWithoutOpen_questionsInput | open_answersCreateOrConnectWithoutOpen_questionsInput[]
    upsert?: open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput | open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput[]
    createMany?: open_answersCreateManyOpen_questionsInputEnvelope
    set?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    disconnect?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    delete?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    connect?: open_answersWhereUniqueInput | open_answersWhereUniqueInput[]
    update?: open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput | open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput[]
    updateMany?: open_answersUpdateManyWithWhereWithoutOpen_questionsInput | open_answersUpdateManyWithWhereWithoutOpen_questionsInput[]
    deleteMany?: open_answersScalarWhereInput | open_answersScalarWhereInput[]
  }

  export type student_open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput = {
    create?: XOR<student_open_answersCreateWithoutOpen_questionsInput, student_open_answersUncheckedCreateWithoutOpen_questionsInput> | student_open_answersCreateWithoutOpen_questionsInput[] | student_open_answersUncheckedCreateWithoutOpen_questionsInput[]
    connectOrCreate?: student_open_answersCreateOrConnectWithoutOpen_questionsInput | student_open_answersCreateOrConnectWithoutOpen_questionsInput[]
    upsert?: student_open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput | student_open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput[]
    createMany?: student_open_answersCreateManyOpen_questionsInputEnvelope
    set?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    disconnect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    delete?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    connect?: student_open_answersWhereUniqueInput | student_open_answersWhereUniqueInput[]
    update?: student_open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput | student_open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput[]
    updateMany?: student_open_answersUpdateManyWithWhereWithoutOpen_questionsInput | student_open_answersUpdateManyWithWhereWithoutOpen_questionsInput[]
    deleteMany?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutStudent_closed_answersInput = {
    create?: XOR<studentsCreateWithoutStudent_closed_answersInput, studentsUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_closed_answersInput
    connect?: studentsWhereUniqueInput
  }

  export type closed_questionsCreateNestedOneWithoutStudent_closed_answersInput = {
    create?: XOR<closed_questionsCreateWithoutStudent_closed_answersInput, closed_questionsUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: closed_questionsCreateOrConnectWithoutStudent_closed_answersInput
    connect?: closed_questionsWhereUniqueInput
  }

  export type closed_answersCreateNestedOneWithoutStudent_closed_answersInput = {
    create?: XOR<closed_answersCreateWithoutStudent_closed_answersInput, closed_answersUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: closed_answersCreateOrConnectWithoutStudent_closed_answersInput
    connect?: closed_answersWhereUniqueInput
  }

  export type attemptsCreateNestedOneWithoutStudent_closed_answersInput = {
    create?: XOR<attemptsCreateWithoutStudent_closed_answersInput, attemptsUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: attemptsCreateOrConnectWithoutStudent_closed_answersInput
    connect?: attemptsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutStudent_closed_answersNestedInput = {
    create?: XOR<studentsCreateWithoutStudent_closed_answersInput, studentsUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_closed_answersInput
    upsert?: studentsUpsertWithoutStudent_closed_answersInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudent_closed_answersInput, studentsUpdateWithoutStudent_closed_answersInput>, studentsUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type closed_questionsUpdateOneRequiredWithoutStudent_closed_answersNestedInput = {
    create?: XOR<closed_questionsCreateWithoutStudent_closed_answersInput, closed_questionsUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: closed_questionsCreateOrConnectWithoutStudent_closed_answersInput
    upsert?: closed_questionsUpsertWithoutStudent_closed_answersInput
    connect?: closed_questionsWhereUniqueInput
    update?: XOR<XOR<closed_questionsUpdateToOneWithWhereWithoutStudent_closed_answersInput, closed_questionsUpdateWithoutStudent_closed_answersInput>, closed_questionsUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type closed_answersUpdateOneRequiredWithoutStudent_closed_answersNestedInput = {
    create?: XOR<closed_answersCreateWithoutStudent_closed_answersInput, closed_answersUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: closed_answersCreateOrConnectWithoutStudent_closed_answersInput
    upsert?: closed_answersUpsertWithoutStudent_closed_answersInput
    connect?: closed_answersWhereUniqueInput
    update?: XOR<XOR<closed_answersUpdateToOneWithWhereWithoutStudent_closed_answersInput, closed_answersUpdateWithoutStudent_closed_answersInput>, closed_answersUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type attemptsUpdateOneRequiredWithoutStudent_closed_answersNestedInput = {
    create?: XOR<attemptsCreateWithoutStudent_closed_answersInput, attemptsUncheckedCreateWithoutStudent_closed_answersInput>
    connectOrCreate?: attemptsCreateOrConnectWithoutStudent_closed_answersInput
    upsert?: attemptsUpsertWithoutStudent_closed_answersInput
    connect?: attemptsWhereUniqueInput
    update?: XOR<XOR<attemptsUpdateToOneWithWhereWithoutStudent_closed_answersInput, attemptsUpdateWithoutStudent_closed_answersInput>, attemptsUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type open_questionsCreateNestedOneWithoutStudent_open_answersInput = {
    create?: XOR<open_questionsCreateWithoutStudent_open_answersInput, open_questionsUncheckedCreateWithoutStudent_open_answersInput>
    connectOrCreate?: open_questionsCreateOrConnectWithoutStudent_open_answersInput
    connect?: open_questionsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutStudent_open_answersInput = {
    create?: XOR<studentsCreateWithoutStudent_open_answersInput, studentsUncheckedCreateWithoutStudent_open_answersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_open_answersInput
    connect?: studentsWhereUniqueInput
  }

  export type attemptsCreateNestedOneWithoutStudent_open_answersInput = {
    create?: XOR<attemptsCreateWithoutStudent_open_answersInput, attemptsUncheckedCreateWithoutStudent_open_answersInput>
    connectOrCreate?: attemptsCreateOrConnectWithoutStudent_open_answersInput
    connect?: attemptsWhereUniqueInput
  }

  export type open_questionsUpdateOneRequiredWithoutStudent_open_answersNestedInput = {
    create?: XOR<open_questionsCreateWithoutStudent_open_answersInput, open_questionsUncheckedCreateWithoutStudent_open_answersInput>
    connectOrCreate?: open_questionsCreateOrConnectWithoutStudent_open_answersInput
    upsert?: open_questionsUpsertWithoutStudent_open_answersInput
    connect?: open_questionsWhereUniqueInput
    update?: XOR<XOR<open_questionsUpdateToOneWithWhereWithoutStudent_open_answersInput, open_questionsUpdateWithoutStudent_open_answersInput>, open_questionsUncheckedUpdateWithoutStudent_open_answersInput>
  }

  export type studentsUpdateOneRequiredWithoutStudent_open_answersNestedInput = {
    create?: XOR<studentsCreateWithoutStudent_open_answersInput, studentsUncheckedCreateWithoutStudent_open_answersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_open_answersInput
    upsert?: studentsUpsertWithoutStudent_open_answersInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudent_open_answersInput, studentsUpdateWithoutStudent_open_answersInput>, studentsUncheckedUpdateWithoutStudent_open_answersInput>
  }

  export type attemptsUpdateOneRequiredWithoutStudent_open_answersNestedInput = {
    create?: XOR<attemptsCreateWithoutStudent_open_answersInput, attemptsUncheckedCreateWithoutStudent_open_answersInput>
    connectOrCreate?: attemptsCreateOrConnectWithoutStudent_open_answersInput
    upsert?: attemptsUpsertWithoutStudent_open_answersInput
    connect?: attemptsWhereUniqueInput
    update?: XOR<XOR<attemptsUpdateToOneWithWhereWithoutStudent_open_answersInput, attemptsUpdateWithoutStudent_open_answersInput>, attemptsUncheckedUpdateWithoutStudent_open_answersInput>
  }

  export type studentsCreateNestedOneWithoutStudents_examsInput = {
    create?: XOR<studentsCreateWithoutStudents_examsInput, studentsUncheckedCreateWithoutStudents_examsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudents_examsInput
    connect?: studentsWhereUniqueInput
  }

  export type examsCreateNestedOneWithoutStudents_examsInput = {
    create?: XOR<examsCreateWithoutStudents_examsInput, examsUncheckedCreateWithoutStudents_examsInput>
    connectOrCreate?: examsCreateOrConnectWithoutStudents_examsInput
    connect?: examsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutStudents_examsNestedInput = {
    create?: XOR<studentsCreateWithoutStudents_examsInput, studentsUncheckedCreateWithoutStudents_examsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudents_examsInput
    upsert?: studentsUpsertWithoutStudents_examsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudents_examsInput, studentsUpdateWithoutStudents_examsInput>, studentsUncheckedUpdateWithoutStudents_examsInput>
  }

  export type examsUpdateOneRequiredWithoutStudents_examsNestedInput = {
    create?: XOR<examsCreateWithoutStudents_examsInput, examsUncheckedCreateWithoutStudents_examsInput>
    connectOrCreate?: examsCreateOrConnectWithoutStudents_examsInput
    upsert?: examsUpsertWithoutStudents_examsInput
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutStudents_examsInput, examsUpdateWithoutStudents_examsInput>, examsUncheckedUpdateWithoutStudents_examsInput>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumattempt_questions_question_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.attempt_questions_question_type | Enumattempt_questions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.attempt_questions_question_type[]
    notIn?: $Enums.attempt_questions_question_type[]
    not?: NestedEnumattempt_questions_question_typeFilter<$PrismaModel> | $Enums.attempt_questions_question_type
  }

  export type NestedEnumattempt_questions_question_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attempt_questions_question_type | Enumattempt_questions_question_typeFieldRefInput<$PrismaModel>
    in?: $Enums.attempt_questions_question_type[]
    notIn?: $Enums.attempt_questions_question_type[]
    not?: NestedEnumattempt_questions_question_typeWithAggregatesFilter<$PrismaModel> | $Enums.attempt_questions_question_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumattempt_questions_question_typeFilter<$PrismaModel>
    _max?: NestedEnumattempt_questions_question_typeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type studentsCreateWithoutAttendancesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutAttendancesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutAttendancesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
  }

  export type lessonsCreateWithoutAttendancesInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    exams?: examsCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksCreateNestedOneWithoutLessonsInput
    teachers: teachersCreateNestedOneWithoutLessonsInput
    classes: classesCreateNestedOneWithoutLessonsInput
    subjects: subjectsCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateWithoutAttendancesInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
    subject_id: Uint8Array
    exams?: examsUncheckedCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksUncheckedCreateNestedOneWithoutLessonsInput
  }

  export type lessonsCreateOrConnectWithoutAttendancesInput = {
    where: lessonsWhereUniqueInput
    create: XOR<lessonsCreateWithoutAttendancesInput, lessonsUncheckedCreateWithoutAttendancesInput>
  }

  export type studentsUpsertWithoutAttendancesInput = {
    update: XOR<studentsUpdateWithoutAttendancesInput, studentsUncheckedUpdateWithoutAttendancesInput>
    create: XOR<studentsCreateWithoutAttendancesInput, studentsUncheckedCreateWithoutAttendancesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutAttendancesInput, studentsUncheckedUpdateWithoutAttendancesInput>
  }

  export type studentsUpdateWithoutAttendancesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutAttendancesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type lessonsUpsertWithoutAttendancesInput = {
    update: XOR<lessonsUpdateWithoutAttendancesInput, lessonsUncheckedUpdateWithoutAttendancesInput>
    create: XOR<lessonsCreateWithoutAttendancesInput, lessonsUncheckedCreateWithoutAttendancesInput>
    where?: lessonsWhereInput
  }

  export type lessonsUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: lessonsWhereInput
    data: XOR<lessonsUpdateWithoutAttendancesInput, lessonsUncheckedUpdateWithoutAttendancesInput>
  }

  export type lessonsUpdateWithoutAttendancesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: examsUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUpdateOneWithoutLessonsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLessonsNestedInput
    classes?: classesUpdateOneRequiredWithoutLessonsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateWithoutAttendancesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exams?: examsUncheckedUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUncheckedUpdateOneWithoutLessonsNestedInput
  }

  export type badges_categoriesCreateWithoutBadgesInput = {
    id?: Uint8Array
    name: string
  }

  export type badges_categoriesUncheckedCreateWithoutBadgesInput = {
    id?: Uint8Array
    name: string
  }

  export type badges_categoriesCreateOrConnectWithoutBadgesInput = {
    where: badges_categoriesWhereUniqueInput
    create: XOR<badges_categoriesCreateWithoutBadgesInput, badges_categoriesUncheckedCreateWithoutBadgesInput>
  }

  export type badges_historyCreateWithoutBadgesInput = {
    id?: Uint8Array
    date_awarded: Date | string
    students: studentsCreateNestedOneWithoutBadges_historyInput
  }

  export type badges_historyUncheckedCreateWithoutBadgesInput = {
    id?: Uint8Array
    date_awarded: Date | string
    student_id: Uint8Array
  }

  export type badges_historyCreateOrConnectWithoutBadgesInput = {
    where: badges_historyWhereUniqueInput
    create: XOR<badges_historyCreateWithoutBadgesInput, badges_historyUncheckedCreateWithoutBadgesInput>
  }

  export type badges_historyCreateManyBadgesInputEnvelope = {
    data: badges_historyCreateManyBadgesInput | badges_historyCreateManyBadgesInput[]
    skipDuplicates?: boolean
  }

  export type badges_categoriesUpsertWithoutBadgesInput = {
    update: XOR<badges_categoriesUpdateWithoutBadgesInput, badges_categoriesUncheckedUpdateWithoutBadgesInput>
    create: XOR<badges_categoriesCreateWithoutBadgesInput, badges_categoriesUncheckedCreateWithoutBadgesInput>
    where?: badges_categoriesWhereInput
  }

  export type badges_categoriesUpdateToOneWithWhereWithoutBadgesInput = {
    where?: badges_categoriesWhereInput
    data: XOR<badges_categoriesUpdateWithoutBadgesInput, badges_categoriesUncheckedUpdateWithoutBadgesInput>
  }

  export type badges_categoriesUpdateWithoutBadgesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type badges_categoriesUncheckedUpdateWithoutBadgesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type badges_historyUpsertWithWhereUniqueWithoutBadgesInput = {
    where: badges_historyWhereUniqueInput
    update: XOR<badges_historyUpdateWithoutBadgesInput, badges_historyUncheckedUpdateWithoutBadgesInput>
    create: XOR<badges_historyCreateWithoutBadgesInput, badges_historyUncheckedCreateWithoutBadgesInput>
  }

  export type badges_historyUpdateWithWhereUniqueWithoutBadgesInput = {
    where: badges_historyWhereUniqueInput
    data: XOR<badges_historyUpdateWithoutBadgesInput, badges_historyUncheckedUpdateWithoutBadgesInput>
  }

  export type badges_historyUpdateManyWithWhereWithoutBadgesInput = {
    where: badges_historyScalarWhereInput
    data: XOR<badges_historyUpdateManyMutationInput, badges_historyUncheckedUpdateManyWithoutBadgesInput>
  }

  export type badges_historyScalarWhereInput = {
    AND?: badges_historyScalarWhereInput | badges_historyScalarWhereInput[]
    OR?: badges_historyScalarWhereInput[]
    NOT?: badges_historyScalarWhereInput | badges_historyScalarWhereInput[]
    id?: BytesFilter<"badges_history"> | Uint8Array
    date_awarded?: DateTimeFilter<"badges_history"> | Date | string
    student_id?: BytesFilter<"badges_history"> | Uint8Array
    badge_id?: BytesFilter<"badges_history"> | Uint8Array
  }

  export type badgesCreateWithoutBadges_categoriesInput = {
    id?: Uint8Array
    name: string
    description: string
    badges_history?: badges_historyCreateNestedManyWithoutBadgesInput
  }

  export type badgesUncheckedCreateWithoutBadges_categoriesInput = {
    id?: Uint8Array
    name: string
    description: string
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutBadgesInput
  }

  export type badgesCreateOrConnectWithoutBadges_categoriesInput = {
    where: badgesWhereUniqueInput
    create: XOR<badgesCreateWithoutBadges_categoriesInput, badgesUncheckedCreateWithoutBadges_categoriesInput>
  }

  export type badgesCreateManyBadges_categoriesInputEnvelope = {
    data: badgesCreateManyBadges_categoriesInput | badgesCreateManyBadges_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type badgesUpsertWithWhereUniqueWithoutBadges_categoriesInput = {
    where: badgesWhereUniqueInput
    update: XOR<badgesUpdateWithoutBadges_categoriesInput, badgesUncheckedUpdateWithoutBadges_categoriesInput>
    create: XOR<badgesCreateWithoutBadges_categoriesInput, badgesUncheckedCreateWithoutBadges_categoriesInput>
  }

  export type badgesUpdateWithWhereUniqueWithoutBadges_categoriesInput = {
    where: badgesWhereUniqueInput
    data: XOR<badgesUpdateWithoutBadges_categoriesInput, badgesUncheckedUpdateWithoutBadges_categoriesInput>
  }

  export type badgesUpdateManyWithWhereWithoutBadges_categoriesInput = {
    where: badgesScalarWhereInput
    data: XOR<badgesUpdateManyMutationInput, badgesUncheckedUpdateManyWithoutBadges_categoriesInput>
  }

  export type badgesScalarWhereInput = {
    AND?: badgesScalarWhereInput | badgesScalarWhereInput[]
    OR?: badgesScalarWhereInput[]
    NOT?: badgesScalarWhereInput | badgesScalarWhereInput[]
    id?: BytesFilter<"badges"> | Uint8Array
    name?: StringFilter<"badges"> | string
    description?: StringFilter<"badges"> | string
    category_id?: BytesFilter<"badges"> | Uint8Array
  }

  export type studentsCreateWithoutBadges_historyInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutBadges_historyInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutBadges_historyInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutBadges_historyInput, studentsUncheckedCreateWithoutBadges_historyInput>
  }

  export type badgesCreateWithoutBadges_historyInput = {
    id?: Uint8Array
    name: string
    description: string
    badges_categories: badges_categoriesCreateNestedOneWithoutBadgesInput
  }

  export type badgesUncheckedCreateWithoutBadges_historyInput = {
    id?: Uint8Array
    name: string
    description: string
    category_id: Uint8Array
  }

  export type badgesCreateOrConnectWithoutBadges_historyInput = {
    where: badgesWhereUniqueInput
    create: XOR<badgesCreateWithoutBadges_historyInput, badgesUncheckedCreateWithoutBadges_historyInput>
  }

  export type studentsUpsertWithoutBadges_historyInput = {
    update: XOR<studentsUpdateWithoutBadges_historyInput, studentsUncheckedUpdateWithoutBadges_historyInput>
    create: XOR<studentsCreateWithoutBadges_historyInput, studentsUncheckedCreateWithoutBadges_historyInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutBadges_historyInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutBadges_historyInput, studentsUncheckedUpdateWithoutBadges_historyInput>
  }

  export type studentsUpdateWithoutBadges_historyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutBadges_historyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type badgesUpsertWithoutBadges_historyInput = {
    update: XOR<badgesUpdateWithoutBadges_historyInput, badgesUncheckedUpdateWithoutBadges_historyInput>
    create: XOR<badgesCreateWithoutBadges_historyInput, badgesUncheckedCreateWithoutBadges_historyInput>
    where?: badgesWhereInput
  }

  export type badgesUpdateToOneWithWhereWithoutBadges_historyInput = {
    where?: badgesWhereInput
    data: XOR<badgesUpdateWithoutBadges_historyInput, badgesUncheckedUpdateWithoutBadges_historyInput>
  }

  export type badgesUpdateWithoutBadges_historyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badges_categories?: badges_categoriesUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateWithoutBadges_historyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type class_namesCreateWithoutClassesInput = {
    id?: Uint8Array
    name: string
  }

  export type class_namesUncheckedCreateWithoutClassesInput = {
    id?: Uint8Array
    name: string
  }

  export type class_namesCreateOrConnectWithoutClassesInput = {
    where: class_namesWhereUniqueInput
    create: XOR<class_namesCreateWithoutClassesInput, class_namesUncheckedCreateWithoutClassesInput>
  }

  export type school_yearsCreateWithoutClassesInput = {
    id?: Uint8Array
    name: string
    start_date: Date | string
    end_date: Date | string
    semesters?: semestersCreateNestedManyWithoutSchool_yearsInput
  }

  export type school_yearsUncheckedCreateWithoutClassesInput = {
    id?: Uint8Array
    name: string
    start_date: Date | string
    end_date: Date | string
    semesters?: semestersUncheckedCreateNestedManyWithoutSchool_yearsInput
  }

  export type school_yearsCreateOrConnectWithoutClassesInput = {
    where: school_yearsWhereUniqueInput
    create: XOR<school_yearsCreateWithoutClassesInput, school_yearsUncheckedCreateWithoutClassesInput>
  }

  export type teachersCreateWithoutClassesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    exams?: examsCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutTeachersInput
    lessons?: lessonsCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutClassesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutTeachersInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutClassesInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutClassesInput, teachersUncheckedCreateWithoutClassesInput>
  }

  export type classes_examsCreateWithoutClassesInput = {
    exams: examsCreateNestedOneWithoutClasses_examsInput
  }

  export type classes_examsUncheckedCreateWithoutClassesInput = {
    exam_id: Uint8Array
  }

  export type classes_examsCreateOrConnectWithoutClassesInput = {
    where: classes_examsWhereUniqueInput
    create: XOR<classes_examsCreateWithoutClassesInput, classes_examsUncheckedCreateWithoutClassesInput>
  }

  export type classes_examsCreateManyClassesInputEnvelope = {
    data: classes_examsCreateManyClassesInput | classes_examsCreateManyClassesInput[]
    skipDuplicates?: boolean
  }

  export type lessonsCreateWithoutClassesInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    attendances?: attendancesCreateNestedManyWithoutLessonsInput
    exams?: examsCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksCreateNestedOneWithoutLessonsInput
    teachers: teachersCreateNestedOneWithoutLessonsInput
    subjects: subjectsCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateWithoutClassesInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    subject_id: Uint8Array
    attendances?: attendancesUncheckedCreateNestedManyWithoutLessonsInput
    exams?: examsUncheckedCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksUncheckedCreateNestedOneWithoutLessonsInput
  }

  export type lessonsCreateOrConnectWithoutClassesInput = {
    where: lessonsWhereUniqueInput
    create: XOR<lessonsCreateWithoutClassesInput, lessonsUncheckedCreateWithoutClassesInput>
  }

  export type lessonsCreateManyClassesInputEnvelope = {
    data: lessonsCreateManyClassesInput | lessonsCreateManyClassesInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutClassesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutClassesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutClassesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutClassesInput, studentsUncheckedCreateWithoutClassesInput>
  }

  export type studentsCreateManyClassesInputEnvelope = {
    data: studentsCreateManyClassesInput | studentsCreateManyClassesInput[]
    skipDuplicates?: boolean
  }

  export type class_namesUpsertWithoutClassesInput = {
    update: XOR<class_namesUpdateWithoutClassesInput, class_namesUncheckedUpdateWithoutClassesInput>
    create: XOR<class_namesCreateWithoutClassesInput, class_namesUncheckedCreateWithoutClassesInput>
    where?: class_namesWhereInput
  }

  export type class_namesUpdateToOneWithWhereWithoutClassesInput = {
    where?: class_namesWhereInput
    data: XOR<class_namesUpdateWithoutClassesInput, class_namesUncheckedUpdateWithoutClassesInput>
  }

  export type class_namesUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type class_namesUncheckedUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type school_yearsUpsertWithoutClassesInput = {
    update: XOR<school_yearsUpdateWithoutClassesInput, school_yearsUncheckedUpdateWithoutClassesInput>
    create: XOR<school_yearsCreateWithoutClassesInput, school_yearsUncheckedCreateWithoutClassesInput>
    where?: school_yearsWhereInput
  }

  export type school_yearsUpdateToOneWithWhereWithoutClassesInput = {
    where?: school_yearsWhereInput
    data: XOR<school_yearsUpdateWithoutClassesInput, school_yearsUncheckedUpdateWithoutClassesInput>
  }

  export type school_yearsUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesters?: semestersUpdateManyWithoutSchool_yearsNestedInput
  }

  export type school_yearsUncheckedUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesters?: semestersUncheckedUpdateManyWithoutSchool_yearsNestedInput
  }

  export type teachersUpsertWithoutClassesInput = {
    update: XOR<teachersUpdateWithoutClassesInput, teachersUncheckedUpdateWithoutClassesInput>
    create: XOR<teachersCreateWithoutClassesInput, teachersUncheckedCreateWithoutClassesInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutClassesInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutClassesInput, teachersUncheckedUpdateWithoutClassesInput>
  }

  export type teachersUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exams?: examsUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type classes_examsUpsertWithWhereUniqueWithoutClassesInput = {
    where: classes_examsWhereUniqueInput
    update: XOR<classes_examsUpdateWithoutClassesInput, classes_examsUncheckedUpdateWithoutClassesInput>
    create: XOR<classes_examsCreateWithoutClassesInput, classes_examsUncheckedCreateWithoutClassesInput>
  }

  export type classes_examsUpdateWithWhereUniqueWithoutClassesInput = {
    where: classes_examsWhereUniqueInput
    data: XOR<classes_examsUpdateWithoutClassesInput, classes_examsUncheckedUpdateWithoutClassesInput>
  }

  export type classes_examsUpdateManyWithWhereWithoutClassesInput = {
    where: classes_examsScalarWhereInput
    data: XOR<classes_examsUpdateManyMutationInput, classes_examsUncheckedUpdateManyWithoutClassesInput>
  }

  export type classes_examsScalarWhereInput = {
    AND?: classes_examsScalarWhereInput | classes_examsScalarWhereInput[]
    OR?: classes_examsScalarWhereInput[]
    NOT?: classes_examsScalarWhereInput | classes_examsScalarWhereInput[]
    class_id?: BytesFilter<"classes_exams"> | Uint8Array
    exam_id?: BytesFilter<"classes_exams"> | Uint8Array
  }

  export type lessonsUpsertWithWhereUniqueWithoutClassesInput = {
    where: lessonsWhereUniqueInput
    update: XOR<lessonsUpdateWithoutClassesInput, lessonsUncheckedUpdateWithoutClassesInput>
    create: XOR<lessonsCreateWithoutClassesInput, lessonsUncheckedCreateWithoutClassesInput>
  }

  export type lessonsUpdateWithWhereUniqueWithoutClassesInput = {
    where: lessonsWhereUniqueInput
    data: XOR<lessonsUpdateWithoutClassesInput, lessonsUncheckedUpdateWithoutClassesInput>
  }

  export type lessonsUpdateManyWithWhereWithoutClassesInput = {
    where: lessonsScalarWhereInput
    data: XOR<lessonsUpdateManyMutationInput, lessonsUncheckedUpdateManyWithoutClassesInput>
  }

  export type lessonsScalarWhereInput = {
    AND?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
    OR?: lessonsScalarWhereInput[]
    NOT?: lessonsScalarWhereInput | lessonsScalarWhereInput[]
    id?: BytesFilter<"lessons"> | Uint8Array
    description?: StringNullableFilter<"lessons"> | string | null
    date?: DateTimeFilter<"lessons"> | Date | string
    start_time?: DateTimeFilter<"lessons"> | Date | string
    end_time?: DateTimeFilter<"lessons"> | Date | string
    teacher_id?: BytesFilter<"lessons"> | Uint8Array
    class_id?: BytesFilter<"lessons"> | Uint8Array
    subject_id?: BytesFilter<"lessons"> | Uint8Array
  }

  export type studentsUpsertWithWhereUniqueWithoutClassesInput = {
    where: studentsWhereUniqueInput
    update: XOR<studentsUpdateWithoutClassesInput, studentsUncheckedUpdateWithoutClassesInput>
    create: XOR<studentsCreateWithoutClassesInput, studentsUncheckedCreateWithoutClassesInput>
  }

  export type studentsUpdateWithWhereUniqueWithoutClassesInput = {
    where: studentsWhereUniqueInput
    data: XOR<studentsUpdateWithoutClassesInput, studentsUncheckedUpdateWithoutClassesInput>
  }

  export type studentsUpdateManyWithWhereWithoutClassesInput = {
    where: studentsScalarWhereInput
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyWithoutClassesInput>
  }

  export type studentsScalarWhereInput = {
    AND?: studentsScalarWhereInput | studentsScalarWhereInput[]
    OR?: studentsScalarWhereInput[]
    NOT?: studentsScalarWhereInput | studentsScalarWhereInput[]
    id?: BytesFilter<"students"> | Uint8Array
    pesel?: StringFilter<"students"> | string
    email?: StringFilter<"students"> | string
    phone_number?: StringFilter<"students"> | string
    password?: StringFilter<"students"> | string
    first_name?: StringFilter<"students"> | string
    last_name?: StringFilter<"students"> | string
    reset_password_token?: StringNullableFilter<"students"> | string | null
    reset_password_expires?: DateTimeNullableFilter<"students"> | Date | string | null
    class_id?: BytesNullableFilter<"students"> | Uint8Array | null
  }

  export type school_eventsCreateWithoutEvent_typesInput = {
    id?: Uint8Array
    name: string
    location: string
    description: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
  }

  export type school_eventsUncheckedCreateWithoutEvent_typesInput = {
    id?: Uint8Array
    name: string
    location: string
    description: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
  }

  export type school_eventsCreateOrConnectWithoutEvent_typesInput = {
    where: school_eventsWhereUniqueInput
    create: XOR<school_eventsCreateWithoutEvent_typesInput, school_eventsUncheckedCreateWithoutEvent_typesInput>
  }

  export type school_eventsCreateManyEvent_typesInputEnvelope = {
    data: school_eventsCreateManyEvent_typesInput | school_eventsCreateManyEvent_typesInput[]
    skipDuplicates?: boolean
  }

  export type school_eventsUpsertWithWhereUniqueWithoutEvent_typesInput = {
    where: school_eventsWhereUniqueInput
    update: XOR<school_eventsUpdateWithoutEvent_typesInput, school_eventsUncheckedUpdateWithoutEvent_typesInput>
    create: XOR<school_eventsCreateWithoutEvent_typesInput, school_eventsUncheckedCreateWithoutEvent_typesInput>
  }

  export type school_eventsUpdateWithWhereUniqueWithoutEvent_typesInput = {
    where: school_eventsWhereUniqueInput
    data: XOR<school_eventsUpdateWithoutEvent_typesInput, school_eventsUncheckedUpdateWithoutEvent_typesInput>
  }

  export type school_eventsUpdateManyWithWhereWithoutEvent_typesInput = {
    where: school_eventsScalarWhereInput
    data: XOR<school_eventsUpdateManyMutationInput, school_eventsUncheckedUpdateManyWithoutEvent_typesInput>
  }

  export type school_eventsScalarWhereInput = {
    AND?: school_eventsScalarWhereInput | school_eventsScalarWhereInput[]
    OR?: school_eventsScalarWhereInput[]
    NOT?: school_eventsScalarWhereInput | school_eventsScalarWhereInput[]
    id?: BytesFilter<"school_events"> | Uint8Array
    name?: StringFilter<"school_events"> | string
    location?: StringFilter<"school_events"> | string
    description?: StringFilter<"school_events"> | string
    date?: DateTimeFilter<"school_events"> | Date | string
    start_time?: DateTimeFilter<"school_events"> | Date | string
    end_time?: DateTimeFilter<"school_events"> | Date | string
    event_type_id?: BytesFilter<"school_events"> | Uint8Array
  }

  export type studentsCreateWithoutGrades_gradebookInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutGrades_gradebookInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutGrades_gradebookInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutGrades_gradebookInput, studentsUncheckedCreateWithoutGrades_gradebookInput>
  }

  export type subjectsCreateWithoutGrades_gradebookInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutGrades_gradebookInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutGrades_gradebookInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutGrades_gradebookInput, subjectsUncheckedCreateWithoutGrades_gradebookInput>
  }

  export type teachersCreateWithoutGrades_gradebookInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesCreateNestedManyWithoutTeachersInput
    lessons?: lessonsCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutGrades_gradebookInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutTeachersInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutGrades_gradebookInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutGrades_gradebookInput, teachersUncheckedCreateWithoutGrades_gradebookInput>
  }

  export type studentsUpsertWithoutGrades_gradebookInput = {
    update: XOR<studentsUpdateWithoutGrades_gradebookInput, studentsUncheckedUpdateWithoutGrades_gradebookInput>
    create: XOR<studentsCreateWithoutGrades_gradebookInput, studentsUncheckedCreateWithoutGrades_gradebookInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutGrades_gradebookInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutGrades_gradebookInput, studentsUncheckedUpdateWithoutGrades_gradebookInput>
  }

  export type studentsUpdateWithoutGrades_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutGrades_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type subjectsUpsertWithoutGrades_gradebookInput = {
    update: XOR<subjectsUpdateWithoutGrades_gradebookInput, subjectsUncheckedUpdateWithoutGrades_gradebookInput>
    create: XOR<subjectsCreateWithoutGrades_gradebookInput, subjectsUncheckedCreateWithoutGrades_gradebookInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutGrades_gradebookInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutGrades_gradebookInput, subjectsUncheckedUpdateWithoutGrades_gradebookInput>
  }

  export type subjectsUpdateWithoutGrades_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutGrades_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUncheckedUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type teachersUpsertWithoutGrades_gradebookInput = {
    update: XOR<teachersUpdateWithoutGrades_gradebookInput, teachersUncheckedUpdateWithoutGrades_gradebookInput>
    create: XOR<teachersCreateWithoutGrades_gradebookInput, teachersUncheckedCreateWithoutGrades_gradebookInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutGrades_gradebookInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutGrades_gradebookInput, teachersUncheckedUpdateWithoutGrades_gradebookInput>
  }

  export type teachersUpdateWithoutGrades_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutGrades_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type lessonsCreateWithoutHomeworksInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    attendances?: attendancesCreateNestedManyWithoutLessonsInput
    exams?: examsCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsCreateNestedManyWithoutLessonsInput
    teachers: teachersCreateNestedOneWithoutLessonsInput
    classes: classesCreateNestedOneWithoutLessonsInput
    subjects: subjectsCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateWithoutHomeworksInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
    subject_id: Uint8Array
    attendances?: attendancesUncheckedCreateNestedManyWithoutLessonsInput
    exams?: examsUncheckedCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type lessonsCreateOrConnectWithoutHomeworksInput = {
    where: lessonsWhereUniqueInput
    create: XOR<lessonsCreateWithoutHomeworksInput, lessonsUncheckedCreateWithoutHomeworksInput>
  }

  export type lessonsUpsertWithoutHomeworksInput = {
    update: XOR<lessonsUpdateWithoutHomeworksInput, lessonsUncheckedUpdateWithoutHomeworksInput>
    create: XOR<lessonsCreateWithoutHomeworksInput, lessonsUncheckedCreateWithoutHomeworksInput>
    where?: lessonsWhereInput
  }

  export type lessonsUpdateToOneWithWhereWithoutHomeworksInput = {
    where?: lessonsWhereInput
    data: XOR<lessonsUpdateWithoutHomeworksInput, lessonsUncheckedUpdateWithoutHomeworksInput>
  }

  export type lessonsUpdateWithoutHomeworksInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: attendancesUpdateManyWithoutLessonsNestedInput
    exams?: examsUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUpdateManyWithoutLessonsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLessonsNestedInput
    classes?: classesUpdateOneRequiredWithoutLessonsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateWithoutHomeworksInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attendances?: attendancesUncheckedUpdateManyWithoutLessonsNestedInput
    exams?: examsUncheckedUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type attendancesCreateWithoutLessonsInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    students: studentsCreateNestedOneWithoutAttendancesInput
  }

  export type attendancesUncheckedCreateWithoutLessonsInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    student_id: Uint8Array
  }

  export type attendancesCreateOrConnectWithoutLessonsInput = {
    where: attendancesWhereUniqueInput
    create: XOR<attendancesCreateWithoutLessonsInput, attendancesUncheckedCreateWithoutLessonsInput>
  }

  export type attendancesCreateManyLessonsInputEnvelope = {
    data: attendancesCreateManyLessonsInput | attendancesCreateManyLessonsInput[]
    skipDuplicates?: boolean
  }

  export type examsCreateWithoutLessonsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutLessonsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutLessonsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutLessonsInput, examsUncheckedCreateWithoutLessonsInput>
  }

  export type examsCreateManyLessonsInputEnvelope = {
    data: examsCreateManyLessonsInput | examsCreateManyLessonsInput[]
    skipDuplicates?: boolean
  }

  export type gradebook_examsCreateWithoutLessonsInput = {
    id?: Uint8Array
    topic: string
    scope: string
  }

  export type gradebook_examsUncheckedCreateWithoutLessonsInput = {
    id?: Uint8Array
    topic: string
    scope: string
  }

  export type gradebook_examsCreateOrConnectWithoutLessonsInput = {
    where: gradebook_examsWhereUniqueInput
    create: XOR<gradebook_examsCreateWithoutLessonsInput, gradebook_examsUncheckedCreateWithoutLessonsInput>
  }

  export type gradebook_examsCreateManyLessonsInputEnvelope = {
    data: gradebook_examsCreateManyLessonsInput | gradebook_examsCreateManyLessonsInput[]
    skipDuplicates?: boolean
  }

  export type homeworksCreateWithoutLessonsInput = {
    id?: Uint8Array
    description: string
    deadline: Date | string
  }

  export type homeworksUncheckedCreateWithoutLessonsInput = {
    id?: Uint8Array
    description: string
    deadline: Date | string
  }

  export type homeworksCreateOrConnectWithoutLessonsInput = {
    where: homeworksWhereUniqueInput
    create: XOR<homeworksCreateWithoutLessonsInput, homeworksUncheckedCreateWithoutLessonsInput>
  }

  export type teachersCreateWithoutLessonsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutLessonsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutLessonsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutLessonsInput, teachersUncheckedCreateWithoutLessonsInput>
  }

  export type classesCreateWithoutLessonsInput = {
    id?: Uint8Array
    class_names: class_namesCreateNestedOneWithoutClassesInput
    school_years: school_yearsCreateNestedOneWithoutClassesInput
    teachers?: teachersCreateNestedOneWithoutClassesInput
    classes_exams?: classes_examsCreateNestedManyWithoutClassesInput
    students?: studentsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutLessonsInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
    teacher_id?: Uint8Array | null
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutClassesInput
    students?: studentsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutLessonsInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutLessonsInput, classesUncheckedCreateWithoutLessonsInput>
  }

  export type subjectsCreateWithoutLessonsInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesCreateNestedManyWithoutSubjectsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutLessonsInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutSubjectsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutLessonsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutLessonsInput, subjectsUncheckedCreateWithoutLessonsInput>
  }

  export type attendancesUpsertWithWhereUniqueWithoutLessonsInput = {
    where: attendancesWhereUniqueInput
    update: XOR<attendancesUpdateWithoutLessonsInput, attendancesUncheckedUpdateWithoutLessonsInput>
    create: XOR<attendancesCreateWithoutLessonsInput, attendancesUncheckedCreateWithoutLessonsInput>
  }

  export type attendancesUpdateWithWhereUniqueWithoutLessonsInput = {
    where: attendancesWhereUniqueInput
    data: XOR<attendancesUpdateWithoutLessonsInput, attendancesUncheckedUpdateWithoutLessonsInput>
  }

  export type attendancesUpdateManyWithWhereWithoutLessonsInput = {
    where: attendancesScalarWhereInput
    data: XOR<attendancesUpdateManyMutationInput, attendancesUncheckedUpdateManyWithoutLessonsInput>
  }

  export type attendancesScalarWhereInput = {
    AND?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
    OR?: attendancesScalarWhereInput[]
    NOT?: attendancesScalarWhereInput | attendancesScalarWhereInput[]
    id?: BytesFilter<"attendances"> | Uint8Array
    date_time?: DateTimeFilter<"attendances"> | Date | string
    was_present?: BoolFilter<"attendances"> | boolean
    was_late?: BoolFilter<"attendances"> | boolean
    was_excused?: BoolFilter<"attendances"> | boolean
    student_id?: BytesFilter<"attendances"> | Uint8Array
    lesson_id?: BytesFilter<"attendances"> | Uint8Array
  }

  export type examsUpsertWithWhereUniqueWithoutLessonsInput = {
    where: examsWhereUniqueInput
    update: XOR<examsUpdateWithoutLessonsInput, examsUncheckedUpdateWithoutLessonsInput>
    create: XOR<examsCreateWithoutLessonsInput, examsUncheckedCreateWithoutLessonsInput>
  }

  export type examsUpdateWithWhereUniqueWithoutLessonsInput = {
    where: examsWhereUniqueInput
    data: XOR<examsUpdateWithoutLessonsInput, examsUncheckedUpdateWithoutLessonsInput>
  }

  export type examsUpdateManyWithWhereWithoutLessonsInput = {
    where: examsScalarWhereInput
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyWithoutLessonsInput>
  }

  export type examsScalarWhereInput = {
    AND?: examsScalarWhereInput | examsScalarWhereInput[]
    OR?: examsScalarWhereInput[]
    NOT?: examsScalarWhereInput | examsScalarWhereInput[]
    id?: BytesFilter<"exams"> | Uint8Array
    lesson_id?: BytesFilter<"exams"> | Uint8Array
    title?: StringNullableFilter<"exams"> | string | null
    topic?: StringNullableFilter<"exams"> | string | null
    scope?: StringNullableFilter<"exams"> | string | null
    start_date_time?: DateTimeFilter<"exams"> | Date | string
    end_date_time?: DateTimeFilter<"exams"> | Date | string
    visibility?: BoolFilter<"exams"> | boolean
    number_of_questions?: IntNullableFilter<"exams"> | number | null
    duration?: IntFilter<"exams"> | number
    teacher_id?: BytesFilter<"exams"> | Uint8Array
    description?: StringNullableFilter<"exams"> | string | null
    number_of_tries?: IntNullableFilter<"exams"> | number | null
    multiple_tries?: BoolFilter<"exams"> | boolean
    time_limit_for_each_question?: BoolFilter<"exams"> | boolean
    randomise_questions?: BoolFilter<"exams"> | boolean
    end_test_after_leaving_window?: BoolFilter<"exams"> | boolean
    block_copying_pasting?: BoolFilter<"exams"> | boolean
    randomise_answers?: BoolFilter<"exams"> | boolean
    latest_attempt_counts?: BoolFilter<"exams"> | boolean
    best_attempt_counts?: BoolFilter<"exams"> | boolean
    hide_results?: BoolFilter<"exams"> | boolean
    display_points_per_question?: BoolFilter<"exams"> | boolean
    show_correct_answers?: BoolFilter<"exams"> | boolean
    allow_navigation?: BoolFilter<"exams"> | boolean
    allow_review?: BoolFilter<"exams"> | boolean
  }

  export type gradebook_examsUpsertWithWhereUniqueWithoutLessonsInput = {
    where: gradebook_examsWhereUniqueInput
    update: XOR<gradebook_examsUpdateWithoutLessonsInput, gradebook_examsUncheckedUpdateWithoutLessonsInput>
    create: XOR<gradebook_examsCreateWithoutLessonsInput, gradebook_examsUncheckedCreateWithoutLessonsInput>
  }

  export type gradebook_examsUpdateWithWhereUniqueWithoutLessonsInput = {
    where: gradebook_examsWhereUniqueInput
    data: XOR<gradebook_examsUpdateWithoutLessonsInput, gradebook_examsUncheckedUpdateWithoutLessonsInput>
  }

  export type gradebook_examsUpdateManyWithWhereWithoutLessonsInput = {
    where: gradebook_examsScalarWhereInput
    data: XOR<gradebook_examsUpdateManyMutationInput, gradebook_examsUncheckedUpdateManyWithoutLessonsInput>
  }

  export type gradebook_examsScalarWhereInput = {
    AND?: gradebook_examsScalarWhereInput | gradebook_examsScalarWhereInput[]
    OR?: gradebook_examsScalarWhereInput[]
    NOT?: gradebook_examsScalarWhereInput | gradebook_examsScalarWhereInput[]
    id?: BytesFilter<"gradebook_exams"> | Uint8Array
    topic?: StringFilter<"gradebook_exams"> | string
    scope?: StringFilter<"gradebook_exams"> | string
    lesson_id?: BytesFilter<"gradebook_exams"> | Uint8Array
  }

  export type homeworksUpsertWithoutLessonsInput = {
    update: XOR<homeworksUpdateWithoutLessonsInput, homeworksUncheckedUpdateWithoutLessonsInput>
    create: XOR<homeworksCreateWithoutLessonsInput, homeworksUncheckedCreateWithoutLessonsInput>
    where?: homeworksWhereInput
  }

  export type homeworksUpdateToOneWithWhereWithoutLessonsInput = {
    where?: homeworksWhereInput
    data: XOR<homeworksUpdateWithoutLessonsInput, homeworksUncheckedUpdateWithoutLessonsInput>
  }

  export type homeworksUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type homeworksUncheckedUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teachersUpsertWithoutLessonsInput = {
    update: XOR<teachersUpdateWithoutLessonsInput, teachersUncheckedUpdateWithoutLessonsInput>
    create: XOR<teachersCreateWithoutLessonsInput, teachersUncheckedCreateWithoutLessonsInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutLessonsInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutLessonsInput, teachersUncheckedUpdateWithoutLessonsInput>
  }

  export type teachersUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type classesUpsertWithoutLessonsInput = {
    update: XOR<classesUpdateWithoutLessonsInput, classesUncheckedUpdateWithoutLessonsInput>
    create: XOR<classesCreateWithoutLessonsInput, classesUncheckedCreateWithoutLessonsInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutLessonsInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutLessonsInput, classesUncheckedUpdateWithoutLessonsInput>
  }

  export type classesUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_names?: class_namesUpdateOneRequiredWithoutClassesNestedInput
    school_years?: school_yearsUpdateOneRequiredWithoutClassesNestedInput
    teachers?: teachersUpdateOneWithoutClassesNestedInput
    classes_exams?: classes_examsUpdateManyWithoutClassesNestedInput
    students?: studentsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    classes_exams?: classes_examsUncheckedUpdateManyWithoutClassesNestedInput
    students?: studentsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type subjectsUpsertWithoutLessonsInput = {
    update: XOR<subjectsUpdateWithoutLessonsInput, subjectsUncheckedUpdateWithoutLessonsInput>
    create: XOR<subjectsCreateWithoutLessonsInput, subjectsUncheckedCreateWithoutLessonsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutLessonsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutLessonsInput, subjectsUncheckedUpdateWithoutLessonsInput>
  }

  export type subjectsUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUpdateManyWithoutSubjectsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUncheckedUpdateManyWithoutSubjectsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type user_typesCreateWithoutMessages_messages_sender_type_idTouser_typesInput = {
    id?: Uint8Array
    name: string
    messages_messages_receiver_type_idTouser_types?: messagesCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput
    problems_gradebook?: problems_gradebookCreateNestedManyWithoutUser_typesInput
  }

  export type user_typesUncheckedCreateWithoutMessages_messages_sender_type_idTouser_typesInput = {
    id?: Uint8Array
    name: string
    messages_messages_receiver_type_idTouser_types?: messagesUncheckedCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput
    problems_gradebook?: problems_gradebookUncheckedCreateNestedManyWithoutUser_typesInput
  }

  export type user_typesCreateOrConnectWithoutMessages_messages_sender_type_idTouser_typesInput = {
    where: user_typesWhereUniqueInput
    create: XOR<user_typesCreateWithoutMessages_messages_sender_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_sender_type_idTouser_typesInput>
  }

  export type user_typesCreateWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    id?: Uint8Array
    name: string
    messages_messages_sender_type_idTouser_types?: messagesCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput
    problems_gradebook?: problems_gradebookCreateNestedManyWithoutUser_typesInput
  }

  export type user_typesUncheckedCreateWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    id?: Uint8Array
    name: string
    messages_messages_sender_type_idTouser_types?: messagesUncheckedCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput
    problems_gradebook?: problems_gradebookUncheckedCreateNestedManyWithoutUser_typesInput
  }

  export type user_typesCreateOrConnectWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    where: user_typesWhereUniqueInput
    create: XOR<user_typesCreateWithoutMessages_messages_receiver_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_receiver_type_idTouser_typesInput>
  }

  export type user_typesUpsertWithoutMessages_messages_sender_type_idTouser_typesInput = {
    update: XOR<user_typesUpdateWithoutMessages_messages_sender_type_idTouser_typesInput, user_typesUncheckedUpdateWithoutMessages_messages_sender_type_idTouser_typesInput>
    create: XOR<user_typesCreateWithoutMessages_messages_sender_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_sender_type_idTouser_typesInput>
    where?: user_typesWhereInput
  }

  export type user_typesUpdateToOneWithWhereWithoutMessages_messages_sender_type_idTouser_typesInput = {
    where?: user_typesWhereInput
    data: XOR<user_typesUpdateWithoutMessages_messages_sender_type_idTouser_typesInput, user_typesUncheckedUpdateWithoutMessages_messages_sender_type_idTouser_typesInput>
  }

  export type user_typesUpdateWithoutMessages_messages_sender_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_receiver_type_idTouser_types?: messagesUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput
    problems_gradebook?: problems_gradebookUpdateManyWithoutUser_typesNestedInput
  }

  export type user_typesUncheckedUpdateWithoutMessages_messages_sender_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_receiver_type_idTouser_types?: messagesUncheckedUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput
    problems_gradebook?: problems_gradebookUncheckedUpdateManyWithoutUser_typesNestedInput
  }

  export type user_typesUpsertWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    update: XOR<user_typesUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput, user_typesUncheckedUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput>
    create: XOR<user_typesCreateWithoutMessages_messages_receiver_type_idTouser_typesInput, user_typesUncheckedCreateWithoutMessages_messages_receiver_type_idTouser_typesInput>
    where?: user_typesWhereInput
  }

  export type user_typesUpdateToOneWithWhereWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    where?: user_typesWhereInput
    data: XOR<user_typesUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput, user_typesUncheckedUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput>
  }

  export type user_typesUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_sender_type_idTouser_types?: messagesUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput
    problems_gradebook?: problems_gradebookUpdateManyWithoutUser_typesNestedInput
  }

  export type user_typesUncheckedUpdateWithoutMessages_messages_receiver_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_sender_type_idTouser_types?: messagesUncheckedUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput
    problems_gradebook?: problems_gradebookUncheckedUpdateManyWithoutUser_typesNestedInput
  }

  export type students_parentsCreateWithoutParentsInput = {
    students: studentsCreateNestedOneWithoutStudents_parentsInput
  }

  export type students_parentsUncheckedCreateWithoutParentsInput = {
    student_id: Uint8Array
  }

  export type students_parentsCreateOrConnectWithoutParentsInput = {
    where: students_parentsWhereUniqueInput
    create: XOR<students_parentsCreateWithoutParentsInput, students_parentsUncheckedCreateWithoutParentsInput>
  }

  export type students_parentsCreateManyParentsInputEnvelope = {
    data: students_parentsCreateManyParentsInput | students_parentsCreateManyParentsInput[]
    skipDuplicates?: boolean
  }

  export type students_parentsUpsertWithWhereUniqueWithoutParentsInput = {
    where: students_parentsWhereUniqueInput
    update: XOR<students_parentsUpdateWithoutParentsInput, students_parentsUncheckedUpdateWithoutParentsInput>
    create: XOR<students_parentsCreateWithoutParentsInput, students_parentsUncheckedCreateWithoutParentsInput>
  }

  export type students_parentsUpdateWithWhereUniqueWithoutParentsInput = {
    where: students_parentsWhereUniqueInput
    data: XOR<students_parentsUpdateWithoutParentsInput, students_parentsUncheckedUpdateWithoutParentsInput>
  }

  export type students_parentsUpdateManyWithWhereWithoutParentsInput = {
    where: students_parentsScalarWhereInput
    data: XOR<students_parentsUpdateManyMutationInput, students_parentsUncheckedUpdateManyWithoutParentsInput>
  }

  export type students_parentsScalarWhereInput = {
    AND?: students_parentsScalarWhereInput | students_parentsScalarWhereInput[]
    OR?: students_parentsScalarWhereInput[]
    NOT?: students_parentsScalarWhereInput | students_parentsScalarWhereInput[]
    student_id?: BytesFilter<"students_parents"> | Uint8Array
    parent_id?: BytesFilter<"students_parents"> | Uint8Array
  }

  export type problems_gradebookCreateWithoutProblem_typesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    reporter_id: Uint8Array
    user_types: user_typesCreateNestedOneWithoutProblems_gradebookInput
    statuses: statusesCreateNestedOneWithoutProblems_gradebookInput
  }

  export type problems_gradebookUncheckedCreateWithoutProblem_typesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    reporter_id: Uint8Array
    user_type_id: Uint8Array
    status_id: Uint8Array
  }

  export type problems_gradebookCreateOrConnectWithoutProblem_typesInput = {
    where: problems_gradebookWhereUniqueInput
    create: XOR<problems_gradebookCreateWithoutProblem_typesInput, problems_gradebookUncheckedCreateWithoutProblem_typesInput>
  }

  export type problems_gradebookCreateManyProblem_typesInputEnvelope = {
    data: problems_gradebookCreateManyProblem_typesInput | problems_gradebookCreateManyProblem_typesInput[]
    skipDuplicates?: boolean
  }

  export type problems_gradebookUpsertWithWhereUniqueWithoutProblem_typesInput = {
    where: problems_gradebookWhereUniqueInput
    update: XOR<problems_gradebookUpdateWithoutProblem_typesInput, problems_gradebookUncheckedUpdateWithoutProblem_typesInput>
    create: XOR<problems_gradebookCreateWithoutProblem_typesInput, problems_gradebookUncheckedCreateWithoutProblem_typesInput>
  }

  export type problems_gradebookUpdateWithWhereUniqueWithoutProblem_typesInput = {
    where: problems_gradebookWhereUniqueInput
    data: XOR<problems_gradebookUpdateWithoutProblem_typesInput, problems_gradebookUncheckedUpdateWithoutProblem_typesInput>
  }

  export type problems_gradebookUpdateManyWithWhereWithoutProblem_typesInput = {
    where: problems_gradebookScalarWhereInput
    data: XOR<problems_gradebookUpdateManyMutationInput, problems_gradebookUncheckedUpdateManyWithoutProblem_typesInput>
  }

  export type problems_gradebookScalarWhereInput = {
    AND?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
    OR?: problems_gradebookScalarWhereInput[]
    NOT?: problems_gradebookScalarWhereInput | problems_gradebookScalarWhereInput[]
    id?: BytesFilter<"problems_gradebook"> | Uint8Array
    description?: StringFilter<"problems_gradebook"> | string
    reported_time?: DateTimeFilter<"problems_gradebook"> | Date | string
    problem_type_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    reporter_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    user_type_id?: BytesFilter<"problems_gradebook"> | Uint8Array
    status_id?: BytesFilter<"problems_gradebook"> | Uint8Array
  }

  export type problem_typesCreateWithoutProblems_gradebookInput = {
    id?: Uint8Array
    name: string
  }

  export type problem_typesUncheckedCreateWithoutProblems_gradebookInput = {
    id?: Uint8Array
    name: string
  }

  export type problem_typesCreateOrConnectWithoutProblems_gradebookInput = {
    where: problem_typesWhereUniqueInput
    create: XOR<problem_typesCreateWithoutProblems_gradebookInput, problem_typesUncheckedCreateWithoutProblems_gradebookInput>
  }

  export type user_typesCreateWithoutProblems_gradebookInput = {
    id?: Uint8Array
    name: string
    messages_messages_sender_type_idTouser_types?: messagesCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput
    messages_messages_receiver_type_idTouser_types?: messagesCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput
  }

  export type user_typesUncheckedCreateWithoutProblems_gradebookInput = {
    id?: Uint8Array
    name: string
    messages_messages_sender_type_idTouser_types?: messagesUncheckedCreateNestedManyWithoutUser_types_messages_sender_type_idTouser_typesInput
    messages_messages_receiver_type_idTouser_types?: messagesUncheckedCreateNestedManyWithoutUser_types_messages_receiver_type_idTouser_typesInput
  }

  export type user_typesCreateOrConnectWithoutProblems_gradebookInput = {
    where: user_typesWhereUniqueInput
    create: XOR<user_typesCreateWithoutProblems_gradebookInput, user_typesUncheckedCreateWithoutProblems_gradebookInput>
  }

  export type statusesCreateWithoutProblems_gradebookInput = {
    id?: Uint8Array
    name: string
  }

  export type statusesUncheckedCreateWithoutProblems_gradebookInput = {
    id?: Uint8Array
    name: string
  }

  export type statusesCreateOrConnectWithoutProblems_gradebookInput = {
    where: statusesWhereUniqueInput
    create: XOR<statusesCreateWithoutProblems_gradebookInput, statusesUncheckedCreateWithoutProblems_gradebookInput>
  }

  export type problem_typesUpsertWithoutProblems_gradebookInput = {
    update: XOR<problem_typesUpdateWithoutProblems_gradebookInput, problem_typesUncheckedUpdateWithoutProblems_gradebookInput>
    create: XOR<problem_typesCreateWithoutProblems_gradebookInput, problem_typesUncheckedCreateWithoutProblems_gradebookInput>
    where?: problem_typesWhereInput
  }

  export type problem_typesUpdateToOneWithWhereWithoutProblems_gradebookInput = {
    where?: problem_typesWhereInput
    data: XOR<problem_typesUpdateWithoutProblems_gradebookInput, problem_typesUncheckedUpdateWithoutProblems_gradebookInput>
  }

  export type problem_typesUpdateWithoutProblems_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type problem_typesUncheckedUpdateWithoutProblems_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type user_typesUpsertWithoutProblems_gradebookInput = {
    update: XOR<user_typesUpdateWithoutProblems_gradebookInput, user_typesUncheckedUpdateWithoutProblems_gradebookInput>
    create: XOR<user_typesCreateWithoutProblems_gradebookInput, user_typesUncheckedCreateWithoutProblems_gradebookInput>
    where?: user_typesWhereInput
  }

  export type user_typesUpdateToOneWithWhereWithoutProblems_gradebookInput = {
    where?: user_typesWhereInput
    data: XOR<user_typesUpdateWithoutProblems_gradebookInput, user_typesUncheckedUpdateWithoutProblems_gradebookInput>
  }

  export type user_typesUpdateWithoutProblems_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_sender_type_idTouser_types?: messagesUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput
    messages_messages_receiver_type_idTouser_types?: messagesUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput
  }

  export type user_typesUncheckedUpdateWithoutProblems_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    messages_messages_sender_type_idTouser_types?: messagesUncheckedUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesNestedInput
    messages_messages_receiver_type_idTouser_types?: messagesUncheckedUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesNestedInput
  }

  export type statusesUpsertWithoutProblems_gradebookInput = {
    update: XOR<statusesUpdateWithoutProblems_gradebookInput, statusesUncheckedUpdateWithoutProblems_gradebookInput>
    create: XOR<statusesCreateWithoutProblems_gradebookInput, statusesUncheckedCreateWithoutProblems_gradebookInput>
    where?: statusesWhereInput
  }

  export type statusesUpdateToOneWithWhereWithoutProblems_gradebookInput = {
    where?: statusesWhereInput
    data: XOR<statusesUpdateWithoutProblems_gradebookInput, statusesUncheckedUpdateWithoutProblems_gradebookInput>
  }

  export type statusesUpdateWithoutProblems_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type statusesUncheckedUpdateWithoutProblems_gradebookInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_typesCreateWithoutSchool_eventsInput = {
    id?: Uint8Array
    name: string
  }

  export type event_typesUncheckedCreateWithoutSchool_eventsInput = {
    id?: Uint8Array
    name: string
  }

  export type event_typesCreateOrConnectWithoutSchool_eventsInput = {
    where: event_typesWhereUniqueInput
    create: XOR<event_typesCreateWithoutSchool_eventsInput, event_typesUncheckedCreateWithoutSchool_eventsInput>
  }

  export type event_typesUpsertWithoutSchool_eventsInput = {
    update: XOR<event_typesUpdateWithoutSchool_eventsInput, event_typesUncheckedUpdateWithoutSchool_eventsInput>
    create: XOR<event_typesCreateWithoutSchool_eventsInput, event_typesUncheckedCreateWithoutSchool_eventsInput>
    where?: event_typesWhereInput
  }

  export type event_typesUpdateToOneWithWhereWithoutSchool_eventsInput = {
    where?: event_typesWhereInput
    data: XOR<event_typesUpdateWithoutSchool_eventsInput, event_typesUncheckedUpdateWithoutSchool_eventsInput>
  }

  export type event_typesUpdateWithoutSchool_eventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type event_typesUncheckedUpdateWithoutSchool_eventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type problems_gradebookCreateWithoutStatusesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    reporter_id: Uint8Array
    problem_types: problem_typesCreateNestedOneWithoutProblems_gradebookInput
    user_types: user_typesCreateNestedOneWithoutProblems_gradebookInput
  }

  export type problems_gradebookUncheckedCreateWithoutStatusesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    problem_type_id: Uint8Array
    reporter_id: Uint8Array
    user_type_id: Uint8Array
  }

  export type problems_gradebookCreateOrConnectWithoutStatusesInput = {
    where: problems_gradebookWhereUniqueInput
    create: XOR<problems_gradebookCreateWithoutStatusesInput, problems_gradebookUncheckedCreateWithoutStatusesInput>
  }

  export type problems_gradebookCreateManyStatusesInputEnvelope = {
    data: problems_gradebookCreateManyStatusesInput | problems_gradebookCreateManyStatusesInput[]
    skipDuplicates?: boolean
  }

  export type problems_gradebookUpsertWithWhereUniqueWithoutStatusesInput = {
    where: problems_gradebookWhereUniqueInput
    update: XOR<problems_gradebookUpdateWithoutStatusesInput, problems_gradebookUncheckedUpdateWithoutStatusesInput>
    create: XOR<problems_gradebookCreateWithoutStatusesInput, problems_gradebookUncheckedCreateWithoutStatusesInput>
  }

  export type problems_gradebookUpdateWithWhereUniqueWithoutStatusesInput = {
    where: problems_gradebookWhereUniqueInput
    data: XOR<problems_gradebookUpdateWithoutStatusesInput, problems_gradebookUncheckedUpdateWithoutStatusesInput>
  }

  export type problems_gradebookUpdateManyWithWhereWithoutStatusesInput = {
    where: problems_gradebookScalarWhereInput
    data: XOR<problems_gradebookUpdateManyMutationInput, problems_gradebookUncheckedUpdateManyWithoutStatusesInput>
  }

  export type attemptsCreateWithoutStudentsInput = {
    id?: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsCreateNestedManyWithoutAttemptsInput
    exams: examsCreateNestedOneWithoutAttemptsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutAttemptsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsCreateOrConnectWithoutStudentsInput = {
    where: attemptsWhereUniqueInput
    create: XOR<attemptsCreateWithoutStudentsInput, attemptsUncheckedCreateWithoutStudentsInput>
  }

  export type attemptsCreateManyStudentsInputEnvelope = {
    data: attemptsCreateManyStudentsInput | attemptsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type attendancesCreateWithoutStudentsInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    lessons: lessonsCreateNestedOneWithoutAttendancesInput
  }

  export type attendancesUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    lesson_id: Uint8Array
  }

  export type attendancesCreateOrConnectWithoutStudentsInput = {
    where: attendancesWhereUniqueInput
    create: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput>
  }

  export type attendancesCreateManyStudentsInputEnvelope = {
    data: attendancesCreateManyStudentsInput | attendancesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type badges_historyCreateWithoutStudentsInput = {
    id?: Uint8Array
    date_awarded: Date | string
    badges: badgesCreateNestedOneWithoutBadges_historyInput
  }

  export type badges_historyUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    date_awarded: Date | string
    badge_id: Uint8Array
  }

  export type badges_historyCreateOrConnectWithoutStudentsInput = {
    where: badges_historyWhereUniqueInput
    create: XOR<badges_historyCreateWithoutStudentsInput, badges_historyUncheckedCreateWithoutStudentsInput>
  }

  export type badges_historyCreateManyStudentsInputEnvelope = {
    data: badges_historyCreateManyStudentsInput | badges_historyCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type final_gradesCreateWithoutStudentsInput = {
    id?: Uint8Array
    grade: number
    subjects: subjectsCreateNestedOneWithoutFinal_gradesInput
    teachers: teachersCreateNestedOneWithoutFinal_gradesInput
    semesters: semestersCreateNestedOneWithoutFinal_gradesInput
  }

  export type final_gradesUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    grade: number
    subject_id: Uint8Array
    teacher_id: Uint8Array
    semester_id: Uint8Array
  }

  export type final_gradesCreateOrConnectWithoutStudentsInput = {
    where: final_gradesWhereUniqueInput
    create: XOR<final_gradesCreateWithoutStudentsInput, final_gradesUncheckedCreateWithoutStudentsInput>
  }

  export type final_gradesCreateManyStudentsInputEnvelope = {
    data: final_gradesCreateManyStudentsInput | final_gradesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type grades_examsCreateWithoutStudentsInput = {
    id?: Uint8Array
    attempt_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
    exams: examsCreateNestedOneWithoutGrades_examsInput
  }

  export type grades_examsUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    attempt_id: Uint8Array
    exam_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
  }

  export type grades_examsCreateOrConnectWithoutStudentsInput = {
    where: grades_examsWhereUniqueInput
    create: XOR<grades_examsCreateWithoutStudentsInput, grades_examsUncheckedCreateWithoutStudentsInput>
  }

  export type grades_examsCreateManyStudentsInputEnvelope = {
    data: grades_examsCreateManyStudentsInput | grades_examsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type grades_gradebookCreateWithoutStudentsInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    subjects: subjectsCreateNestedOneWithoutGrades_gradebookInput
    teachers: teachersCreateNestedOneWithoutGrades_gradebookInput
  }

  export type grades_gradebookUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    subject_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type grades_gradebookCreateOrConnectWithoutStudentsInput = {
    where: grades_gradebookWhereUniqueInput
    create: XOR<grades_gradebookCreateWithoutStudentsInput, grades_gradebookUncheckedCreateWithoutStudentsInput>
  }

  export type grades_gradebookCreateManyStudentsInputEnvelope = {
    data: grades_gradebookCreateManyStudentsInput | grades_gradebookCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutStudentsInput = {
    id?: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
    exams?: examsCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
    exam_id?: Uint8Array | null
  }

  export type notificationsCreateOrConnectWithoutStudentsInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutStudentsInput, notificationsUncheckedCreateWithoutStudentsInput>
  }

  export type notificationsCreateManyStudentsInputEnvelope = {
    data: notificationsCreateManyStudentsInput | notificationsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type questions_responsesCreateWithoutStudentsInput = {
    id?: Uint8Array
    content: string
    questions: questionsCreateNestedOneWithoutQuestions_responsesInput
  }

  export type questions_responsesUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    content: string
    question_id: Uint8Array
  }

  export type questions_responsesCreateOrConnectWithoutStudentsInput = {
    where: questions_responsesWhereUniqueInput
    create: XOR<questions_responsesCreateWithoutStudentsInput, questions_responsesUncheckedCreateWithoutStudentsInput>
  }

  export type questions_responsesCreateManyStudentsInputEnvelope = {
    data: questions_responsesCreateManyStudentsInput | questions_responsesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type student_closed_answersCreateWithoutStudentsInput = {
    id?: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
    closed_questions: closed_questionsCreateNestedOneWithoutStudent_closed_answersInput
    closed_answers: closed_answersCreateNestedOneWithoutStudent_closed_answersInput
    attempts: attemptsCreateNestedOneWithoutStudent_closed_answersInput
  }

  export type student_closed_answersUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    closed_question_id: Uint8Array
    closed_answer_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_closed_answersCreateOrConnectWithoutStudentsInput = {
    where: student_closed_answersWhereUniqueInput
    create: XOR<student_closed_answersCreateWithoutStudentsInput, student_closed_answersUncheckedCreateWithoutStudentsInput>
  }

  export type student_closed_answersCreateManyStudentsInputEnvelope = {
    data: student_closed_answersCreateManyStudentsInput | student_closed_answersCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type student_open_answersCreateWithoutStudentsInput = {
    id?: Uint8Array
    score?: number | null
    date_time?: Date | string | null
    description?: string | null
    open_questions: open_questionsCreateNestedOneWithoutStudent_open_answersInput
    attempts: attemptsCreateNestedOneWithoutStudent_open_answersInput
  }

  export type student_open_answersUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    score?: number | null
    attempt_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type student_open_answersCreateOrConnectWithoutStudentsInput = {
    where: student_open_answersWhereUniqueInput
    create: XOR<student_open_answersCreateWithoutStudentsInput, student_open_answersUncheckedCreateWithoutStudentsInput>
  }

  export type student_open_answersCreateManyStudentsInputEnvelope = {
    data: student_open_answersCreateManyStudentsInput | student_open_answersCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type classesCreateWithoutStudentsInput = {
    id?: Uint8Array
    class_names: class_namesCreateNestedOneWithoutClassesInput
    school_years: school_yearsCreateNestedOneWithoutClassesInput
    teachers?: teachersCreateNestedOneWithoutClassesInput
    classes_exams?: classes_examsCreateNestedManyWithoutClassesInput
    lessons?: lessonsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutStudentsInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
    teacher_id?: Uint8Array | null
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutClassesInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutStudentsInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutStudentsInput, classesUncheckedCreateWithoutStudentsInput>
  }

  export type students_examsCreateWithoutStudentsInput = {
    exams: examsCreateNestedOneWithoutStudents_examsInput
  }

  export type students_examsUncheckedCreateWithoutStudentsInput = {
    exam_id: Uint8Array
  }

  export type students_examsCreateOrConnectWithoutStudentsInput = {
    where: students_examsWhereUniqueInput
    create: XOR<students_examsCreateWithoutStudentsInput, students_examsUncheckedCreateWithoutStudentsInput>
  }

  export type students_examsCreateManyStudentsInputEnvelope = {
    data: students_examsCreateManyStudentsInput | students_examsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type students_parentsCreateWithoutStudentsInput = {
    parents: parentsCreateNestedOneWithoutStudents_parentsInput
  }

  export type students_parentsUncheckedCreateWithoutStudentsInput = {
    parent_id: Uint8Array
  }

  export type students_parentsCreateOrConnectWithoutStudentsInput = {
    where: students_parentsWhereUniqueInput
    create: XOR<students_parentsCreateWithoutStudentsInput, students_parentsUncheckedCreateWithoutStudentsInput>
  }

  export type students_parentsCreateManyStudentsInputEnvelope = {
    data: students_parentsCreateManyStudentsInput | students_parentsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type attemptsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: attemptsWhereUniqueInput
    update: XOR<attemptsUpdateWithoutStudentsInput, attemptsUncheckedUpdateWithoutStudentsInput>
    create: XOR<attemptsCreateWithoutStudentsInput, attemptsUncheckedCreateWithoutStudentsInput>
  }

  export type attemptsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: attemptsWhereUniqueInput
    data: XOR<attemptsUpdateWithoutStudentsInput, attemptsUncheckedUpdateWithoutStudentsInput>
  }

  export type attemptsUpdateManyWithWhereWithoutStudentsInput = {
    where: attemptsScalarWhereInput
    data: XOR<attemptsUpdateManyMutationInput, attemptsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type attemptsScalarWhereInput = {
    AND?: attemptsScalarWhereInput | attemptsScalarWhereInput[]
    OR?: attemptsScalarWhereInput[]
    NOT?: attemptsScalarWhereInput | attemptsScalarWhereInput[]
    id?: BytesFilter<"attempts"> | Uint8Array
    student_id?: BytesFilter<"attempts"> | Uint8Array
    exam_id?: BytesFilter<"attempts"> | Uint8Array
    attempt_number?: IntFilter<"attempts"> | number
    total_score?: IntNullableFilter<"attempts"> | number | null
    max_score?: IntNullableFilter<"attempts"> | number | null
    graded?: BoolFilter<"attempts"> | boolean
    start_time?: DateTimeFilter<"attempts"> | Date | string
    end_time?: DateTimeNullableFilter<"attempts"> | Date | string | null
  }

  export type attendancesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: attendancesWhereUniqueInput
    update: XOR<attendancesUpdateWithoutStudentsInput, attendancesUncheckedUpdateWithoutStudentsInput>
    create: XOR<attendancesCreateWithoutStudentsInput, attendancesUncheckedCreateWithoutStudentsInput>
  }

  export type attendancesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: attendancesWhereUniqueInput
    data: XOR<attendancesUpdateWithoutStudentsInput, attendancesUncheckedUpdateWithoutStudentsInput>
  }

  export type attendancesUpdateManyWithWhereWithoutStudentsInput = {
    where: attendancesScalarWhereInput
    data: XOR<attendancesUpdateManyMutationInput, attendancesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type badges_historyUpsertWithWhereUniqueWithoutStudentsInput = {
    where: badges_historyWhereUniqueInput
    update: XOR<badges_historyUpdateWithoutStudentsInput, badges_historyUncheckedUpdateWithoutStudentsInput>
    create: XOR<badges_historyCreateWithoutStudentsInput, badges_historyUncheckedCreateWithoutStudentsInput>
  }

  export type badges_historyUpdateWithWhereUniqueWithoutStudentsInput = {
    where: badges_historyWhereUniqueInput
    data: XOR<badges_historyUpdateWithoutStudentsInput, badges_historyUncheckedUpdateWithoutStudentsInput>
  }

  export type badges_historyUpdateManyWithWhereWithoutStudentsInput = {
    where: badges_historyScalarWhereInput
    data: XOR<badges_historyUpdateManyMutationInput, badges_historyUncheckedUpdateManyWithoutStudentsInput>
  }

  export type final_gradesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: final_gradesWhereUniqueInput
    update: XOR<final_gradesUpdateWithoutStudentsInput, final_gradesUncheckedUpdateWithoutStudentsInput>
    create: XOR<final_gradesCreateWithoutStudentsInput, final_gradesUncheckedCreateWithoutStudentsInput>
  }

  export type final_gradesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: final_gradesWhereUniqueInput
    data: XOR<final_gradesUpdateWithoutStudentsInput, final_gradesUncheckedUpdateWithoutStudentsInput>
  }

  export type final_gradesUpdateManyWithWhereWithoutStudentsInput = {
    where: final_gradesScalarWhereInput
    data: XOR<final_gradesUpdateManyMutationInput, final_gradesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type final_gradesScalarWhereInput = {
    AND?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
    OR?: final_gradesScalarWhereInput[]
    NOT?: final_gradesScalarWhereInput | final_gradesScalarWhereInput[]
    id?: BytesFilter<"final_grades"> | Uint8Array
    grade?: IntFilter<"final_grades"> | number
    student_id?: BytesFilter<"final_grades"> | Uint8Array
    subject_id?: BytesFilter<"final_grades"> | Uint8Array
    teacher_id?: BytesFilter<"final_grades"> | Uint8Array
    semester_id?: BytesFilter<"final_grades"> | Uint8Array
  }

  export type grades_examsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: grades_examsWhereUniqueInput
    update: XOR<grades_examsUpdateWithoutStudentsInput, grades_examsUncheckedUpdateWithoutStudentsInput>
    create: XOR<grades_examsCreateWithoutStudentsInput, grades_examsUncheckedCreateWithoutStudentsInput>
  }

  export type grades_examsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: grades_examsWhereUniqueInput
    data: XOR<grades_examsUpdateWithoutStudentsInput, grades_examsUncheckedUpdateWithoutStudentsInput>
  }

  export type grades_examsUpdateManyWithWhereWithoutStudentsInput = {
    where: grades_examsScalarWhereInput
    data: XOR<grades_examsUpdateManyMutationInput, grades_examsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type grades_examsScalarWhereInput = {
    AND?: grades_examsScalarWhereInput | grades_examsScalarWhereInput[]
    OR?: grades_examsScalarWhereInput[]
    NOT?: grades_examsScalarWhereInput | grades_examsScalarWhereInput[]
    id?: BytesFilter<"grades_exams"> | Uint8Array
    student_id?: BytesFilter<"grades_exams"> | Uint8Array
    attempt_id?: BytesFilter<"grades_exams"> | Uint8Array
    exam_id?: BytesFilter<"grades_exams"> | Uint8Array
    description?: StringFilter<"grades_exams"> | string
    grade?: StringFilter<"grades_exams"> | string
    date_given?: DateTimeFilter<"grades_exams"> | Date | string
  }

  export type grades_gradebookUpsertWithWhereUniqueWithoutStudentsInput = {
    where: grades_gradebookWhereUniqueInput
    update: XOR<grades_gradebookUpdateWithoutStudentsInput, grades_gradebookUncheckedUpdateWithoutStudentsInput>
    create: XOR<grades_gradebookCreateWithoutStudentsInput, grades_gradebookUncheckedCreateWithoutStudentsInput>
  }

  export type grades_gradebookUpdateWithWhereUniqueWithoutStudentsInput = {
    where: grades_gradebookWhereUniqueInput
    data: XOR<grades_gradebookUpdateWithoutStudentsInput, grades_gradebookUncheckedUpdateWithoutStudentsInput>
  }

  export type grades_gradebookUpdateManyWithWhereWithoutStudentsInput = {
    where: grades_gradebookScalarWhereInput
    data: XOR<grades_gradebookUpdateManyMutationInput, grades_gradebookUncheckedUpdateManyWithoutStudentsInput>
  }

  export type grades_gradebookScalarWhereInput = {
    AND?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
    OR?: grades_gradebookScalarWhereInput[]
    NOT?: grades_gradebookScalarWhereInput | grades_gradebookScalarWhereInput[]
    id?: BytesFilter<"grades_gradebook"> | Uint8Array
    description?: StringFilter<"grades_gradebook"> | string
    grade?: IntFilter<"grades_gradebook"> | number
    weight?: IntFilter<"grades_gradebook"> | number
    date_given?: DateTimeFilter<"grades_gradebook"> | Date | string
    student_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    subject_id?: BytesFilter<"grades_gradebook"> | Uint8Array
    teacher_id?: BytesFilter<"grades_gradebook"> | Uint8Array
  }

  export type notificationsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutStudentsInput, notificationsUncheckedUpdateWithoutStudentsInput>
    create: XOR<notificationsCreateWithoutStudentsInput, notificationsUncheckedCreateWithoutStudentsInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutStudentsInput, notificationsUncheckedUpdateWithoutStudentsInput>
  }

  export type notificationsUpdateManyWithWhereWithoutStudentsInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: BytesFilter<"notifications"> | Uint8Array
    student_id?: BytesFilter<"notifications"> | Uint8Array
    description?: StringFilter<"notifications"> | string
    notification_date?: DateTimeFilter<"notifications"> | Date | string
    is_read?: BoolFilter<"notifications"> | boolean
    exam_id?: BytesNullableFilter<"notifications"> | Uint8Array | null
  }

  export type questions_responsesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: questions_responsesWhereUniqueInput
    update: XOR<questions_responsesUpdateWithoutStudentsInput, questions_responsesUncheckedUpdateWithoutStudentsInput>
    create: XOR<questions_responsesCreateWithoutStudentsInput, questions_responsesUncheckedCreateWithoutStudentsInput>
  }

  export type questions_responsesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: questions_responsesWhereUniqueInput
    data: XOR<questions_responsesUpdateWithoutStudentsInput, questions_responsesUncheckedUpdateWithoutStudentsInput>
  }

  export type questions_responsesUpdateManyWithWhereWithoutStudentsInput = {
    where: questions_responsesScalarWhereInput
    data: XOR<questions_responsesUpdateManyMutationInput, questions_responsesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type questions_responsesScalarWhereInput = {
    AND?: questions_responsesScalarWhereInput | questions_responsesScalarWhereInput[]
    OR?: questions_responsesScalarWhereInput[]
    NOT?: questions_responsesScalarWhereInput | questions_responsesScalarWhereInput[]
    id?: BytesFilter<"questions_responses"> | Uint8Array
    content?: StringFilter<"questions_responses"> | string
    student_id?: BytesFilter<"questions_responses"> | Uint8Array
    question_id?: BytesFilter<"questions_responses"> | Uint8Array
  }

  export type student_closed_answersUpsertWithWhereUniqueWithoutStudentsInput = {
    where: student_closed_answersWhereUniqueInput
    update: XOR<student_closed_answersUpdateWithoutStudentsInput, student_closed_answersUncheckedUpdateWithoutStudentsInput>
    create: XOR<student_closed_answersCreateWithoutStudentsInput, student_closed_answersUncheckedCreateWithoutStudentsInput>
  }

  export type student_closed_answersUpdateWithWhereUniqueWithoutStudentsInput = {
    where: student_closed_answersWhereUniqueInput
    data: XOR<student_closed_answersUpdateWithoutStudentsInput, student_closed_answersUncheckedUpdateWithoutStudentsInput>
  }

  export type student_closed_answersUpdateManyWithWhereWithoutStudentsInput = {
    where: student_closed_answersScalarWhereInput
    data: XOR<student_closed_answersUpdateManyMutationInput, student_closed_answersUncheckedUpdateManyWithoutStudentsInput>
  }

  export type student_closed_answersScalarWhereInput = {
    AND?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
    OR?: student_closed_answersScalarWhereInput[]
    NOT?: student_closed_answersScalarWhereInput | student_closed_answersScalarWhereInput[]
    id?: BytesFilter<"student_closed_answers"> | Uint8Array
    student_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    closed_question_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    closed_answer_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    attempt_id?: BytesFilter<"student_closed_answers"> | Uint8Array
    correctness?: BoolNullableFilter<"student_closed_answers"> | boolean | null
    date_time?: DateTimeNullableFilter<"student_closed_answers"> | Date | string | null
  }

  export type student_open_answersUpsertWithWhereUniqueWithoutStudentsInput = {
    where: student_open_answersWhereUniqueInput
    update: XOR<student_open_answersUpdateWithoutStudentsInput, student_open_answersUncheckedUpdateWithoutStudentsInput>
    create: XOR<student_open_answersCreateWithoutStudentsInput, student_open_answersUncheckedCreateWithoutStudentsInput>
  }

  export type student_open_answersUpdateWithWhereUniqueWithoutStudentsInput = {
    where: student_open_answersWhereUniqueInput
    data: XOR<student_open_answersUpdateWithoutStudentsInput, student_open_answersUncheckedUpdateWithoutStudentsInput>
  }

  export type student_open_answersUpdateManyWithWhereWithoutStudentsInput = {
    where: student_open_answersScalarWhereInput
    data: XOR<student_open_answersUpdateManyMutationInput, student_open_answersUncheckedUpdateManyWithoutStudentsInput>
  }

  export type student_open_answersScalarWhereInput = {
    AND?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
    OR?: student_open_answersScalarWhereInput[]
    NOT?: student_open_answersScalarWhereInput | student_open_answersScalarWhereInput[]
    id?: BytesFilter<"student_open_answers"> | Uint8Array
    open_question_id?: BytesFilter<"student_open_answers"> | Uint8Array
    score?: IntNullableFilter<"student_open_answers"> | number | null
    student_id?: BytesFilter<"student_open_answers"> | Uint8Array
    attempt_id?: BytesFilter<"student_open_answers"> | Uint8Array
    date_time?: DateTimeNullableFilter<"student_open_answers"> | Date | string | null
    description?: StringNullableFilter<"student_open_answers"> | string | null
  }

  export type classesUpsertWithoutStudentsInput = {
    update: XOR<classesUpdateWithoutStudentsInput, classesUncheckedUpdateWithoutStudentsInput>
    create: XOR<classesCreateWithoutStudentsInput, classesUncheckedCreateWithoutStudentsInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutStudentsInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutStudentsInput, classesUncheckedUpdateWithoutStudentsInput>
  }

  export type classesUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_names?: class_namesUpdateOneRequiredWithoutClassesNestedInput
    school_years?: school_yearsUpdateOneRequiredWithoutClassesNestedInput
    teachers?: teachersUpdateOneWithoutClassesNestedInput
    classes_exams?: classes_examsUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    classes_exams?: classes_examsUncheckedUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type students_examsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: students_examsWhereUniqueInput
    update: XOR<students_examsUpdateWithoutStudentsInput, students_examsUncheckedUpdateWithoutStudentsInput>
    create: XOR<students_examsCreateWithoutStudentsInput, students_examsUncheckedCreateWithoutStudentsInput>
  }

  export type students_examsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: students_examsWhereUniqueInput
    data: XOR<students_examsUpdateWithoutStudentsInput, students_examsUncheckedUpdateWithoutStudentsInput>
  }

  export type students_examsUpdateManyWithWhereWithoutStudentsInput = {
    where: students_examsScalarWhereInput
    data: XOR<students_examsUpdateManyMutationInput, students_examsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type students_examsScalarWhereInput = {
    AND?: students_examsScalarWhereInput | students_examsScalarWhereInput[]
    OR?: students_examsScalarWhereInput[]
    NOT?: students_examsScalarWhereInput | students_examsScalarWhereInput[]
    students_id?: BytesFilter<"students_exams"> | Uint8Array
    exam_id?: BytesFilter<"students_exams"> | Uint8Array
  }

  export type students_parentsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: students_parentsWhereUniqueInput
    update: XOR<students_parentsUpdateWithoutStudentsInput, students_parentsUncheckedUpdateWithoutStudentsInput>
    create: XOR<students_parentsCreateWithoutStudentsInput, students_parentsUncheckedCreateWithoutStudentsInput>
  }

  export type students_parentsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: students_parentsWhereUniqueInput
    data: XOR<students_parentsUpdateWithoutStudentsInput, students_parentsUncheckedUpdateWithoutStudentsInput>
  }

  export type students_parentsUpdateManyWithWhereWithoutStudentsInput = {
    where: students_parentsScalarWhereInput
    data: XOR<students_parentsUpdateManyMutationInput, students_parentsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type studentsCreateWithoutStudents_parentsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudents_parentsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudents_parentsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudents_parentsInput, studentsUncheckedCreateWithoutStudents_parentsInput>
  }

  export type parentsCreateWithoutStudents_parentsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type parentsUncheckedCreateWithoutStudents_parentsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type parentsCreateOrConnectWithoutStudents_parentsInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutStudents_parentsInput, parentsUncheckedCreateWithoutStudents_parentsInput>
  }

  export type studentsUpsertWithoutStudents_parentsInput = {
    update: XOR<studentsUpdateWithoutStudents_parentsInput, studentsUncheckedUpdateWithoutStudents_parentsInput>
    create: XOR<studentsCreateWithoutStudents_parentsInput, studentsUncheckedCreateWithoutStudents_parentsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudents_parentsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudents_parentsInput, studentsUncheckedUpdateWithoutStudents_parentsInput>
  }

  export type studentsUpdateWithoutStudents_parentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudents_parentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type parentsUpsertWithoutStudents_parentsInput = {
    update: XOR<parentsUpdateWithoutStudents_parentsInput, parentsUncheckedUpdateWithoutStudents_parentsInput>
    create: XOR<parentsCreateWithoutStudents_parentsInput, parentsUncheckedCreateWithoutStudents_parentsInput>
    where?: parentsWhereInput
  }

  export type parentsUpdateToOneWithWhereWithoutStudents_parentsInput = {
    where?: parentsWhereInput
    data: XOR<parentsUpdateWithoutStudents_parentsInput, parentsUncheckedUpdateWithoutStudents_parentsInput>
  }

  export type parentsUpdateWithoutStudents_parentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parentsUncheckedUpdateWithoutStudents_parentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type final_gradesCreateWithoutSubjectsInput = {
    id?: Uint8Array
    grade: number
    students: studentsCreateNestedOneWithoutFinal_gradesInput
    teachers: teachersCreateNestedOneWithoutFinal_gradesInput
    semesters: semestersCreateNestedOneWithoutFinal_gradesInput
  }

  export type final_gradesUncheckedCreateWithoutSubjectsInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    teacher_id: Uint8Array
    semester_id: Uint8Array
  }

  export type final_gradesCreateOrConnectWithoutSubjectsInput = {
    where: final_gradesWhereUniqueInput
    create: XOR<final_gradesCreateWithoutSubjectsInput, final_gradesUncheckedCreateWithoutSubjectsInput>
  }

  export type final_gradesCreateManySubjectsInputEnvelope = {
    data: final_gradesCreateManySubjectsInput | final_gradesCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type grades_gradebookCreateWithoutSubjectsInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    students: studentsCreateNestedOneWithoutGrades_gradebookInput
    teachers: teachersCreateNestedOneWithoutGrades_gradebookInput
  }

  export type grades_gradebookUncheckedCreateWithoutSubjectsInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    student_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type grades_gradebookCreateOrConnectWithoutSubjectsInput = {
    where: grades_gradebookWhereUniqueInput
    create: XOR<grades_gradebookCreateWithoutSubjectsInput, grades_gradebookUncheckedCreateWithoutSubjectsInput>
  }

  export type grades_gradebookCreateManySubjectsInputEnvelope = {
    data: grades_gradebookCreateManySubjectsInput | grades_gradebookCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type lessonsCreateWithoutSubjectsInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    attendances?: attendancesCreateNestedManyWithoutLessonsInput
    exams?: examsCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksCreateNestedOneWithoutLessonsInput
    teachers: teachersCreateNestedOneWithoutLessonsInput
    classes: classesCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateWithoutSubjectsInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
    attendances?: attendancesUncheckedCreateNestedManyWithoutLessonsInput
    exams?: examsUncheckedCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksUncheckedCreateNestedOneWithoutLessonsInput
  }

  export type lessonsCreateOrConnectWithoutSubjectsInput = {
    where: lessonsWhereUniqueInput
    create: XOR<lessonsCreateWithoutSubjectsInput, lessonsUncheckedCreateWithoutSubjectsInput>
  }

  export type lessonsCreateManySubjectsInputEnvelope = {
    data: lessonsCreateManySubjectsInput | lessonsCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type teachers_subjectsCreateWithoutSubjectsInput = {
    teachers: teachersCreateNestedOneWithoutTeachers_subjectsInput
  }

  export type teachers_subjectsUncheckedCreateWithoutSubjectsInput = {
    teacher_id: Uint8Array
  }

  export type teachers_subjectsCreateOrConnectWithoutSubjectsInput = {
    where: teachers_subjectsWhereUniqueInput
    create: XOR<teachers_subjectsCreateWithoutSubjectsInput, teachers_subjectsUncheckedCreateWithoutSubjectsInput>
  }

  export type teachers_subjectsCreateManySubjectsInputEnvelope = {
    data: teachers_subjectsCreateManySubjectsInput | teachers_subjectsCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type final_gradesUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: final_gradesWhereUniqueInput
    update: XOR<final_gradesUpdateWithoutSubjectsInput, final_gradesUncheckedUpdateWithoutSubjectsInput>
    create: XOR<final_gradesCreateWithoutSubjectsInput, final_gradesUncheckedCreateWithoutSubjectsInput>
  }

  export type final_gradesUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: final_gradesWhereUniqueInput
    data: XOR<final_gradesUpdateWithoutSubjectsInput, final_gradesUncheckedUpdateWithoutSubjectsInput>
  }

  export type final_gradesUpdateManyWithWhereWithoutSubjectsInput = {
    where: final_gradesScalarWhereInput
    data: XOR<final_gradesUpdateManyMutationInput, final_gradesUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type grades_gradebookUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: grades_gradebookWhereUniqueInput
    update: XOR<grades_gradebookUpdateWithoutSubjectsInput, grades_gradebookUncheckedUpdateWithoutSubjectsInput>
    create: XOR<grades_gradebookCreateWithoutSubjectsInput, grades_gradebookUncheckedCreateWithoutSubjectsInput>
  }

  export type grades_gradebookUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: grades_gradebookWhereUniqueInput
    data: XOR<grades_gradebookUpdateWithoutSubjectsInput, grades_gradebookUncheckedUpdateWithoutSubjectsInput>
  }

  export type grades_gradebookUpdateManyWithWhereWithoutSubjectsInput = {
    where: grades_gradebookScalarWhereInput
    data: XOR<grades_gradebookUpdateManyMutationInput, grades_gradebookUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type lessonsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: lessonsWhereUniqueInput
    update: XOR<lessonsUpdateWithoutSubjectsInput, lessonsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<lessonsCreateWithoutSubjectsInput, lessonsUncheckedCreateWithoutSubjectsInput>
  }

  export type lessonsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: lessonsWhereUniqueInput
    data: XOR<lessonsUpdateWithoutSubjectsInput, lessonsUncheckedUpdateWithoutSubjectsInput>
  }

  export type lessonsUpdateManyWithWhereWithoutSubjectsInput = {
    where: lessonsScalarWhereInput
    data: XOR<lessonsUpdateManyMutationInput, lessonsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type teachers_subjectsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: teachers_subjectsWhereUniqueInput
    update: XOR<teachers_subjectsUpdateWithoutSubjectsInput, teachers_subjectsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<teachers_subjectsCreateWithoutSubjectsInput, teachers_subjectsUncheckedCreateWithoutSubjectsInput>
  }

  export type teachers_subjectsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: teachers_subjectsWhereUniqueInput
    data: XOR<teachers_subjectsUpdateWithoutSubjectsInput, teachers_subjectsUncheckedUpdateWithoutSubjectsInput>
  }

  export type teachers_subjectsUpdateManyWithWhereWithoutSubjectsInput = {
    where: teachers_subjectsScalarWhereInput
    data: XOR<teachers_subjectsUpdateManyMutationInput, teachers_subjectsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type teachers_subjectsScalarWhereInput = {
    AND?: teachers_subjectsScalarWhereInput | teachers_subjectsScalarWhereInput[]
    OR?: teachers_subjectsScalarWhereInput[]
    NOT?: teachers_subjectsScalarWhereInput | teachers_subjectsScalarWhereInput[]
    teacher_id?: BytesFilter<"teachers_subjects"> | Uint8Array
    subject_id?: BytesFilter<"teachers_subjects"> | Uint8Array
  }

  export type questionsCreateWithoutSurveysInput = {
    id?: Uint8Array
    content: string
    questions_types: questions_typesCreateNestedOneWithoutQuestionsInput
    questions_possible_responses?: questions_possible_responsesCreateNestedManyWithoutQuestionsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutSurveysInput = {
    id?: Uint8Array
    content: string
    question_type_id: Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedCreateNestedManyWithoutQuestionsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutSurveysInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutSurveysInput, questionsUncheckedCreateWithoutSurveysInput>
  }

  export type questionsCreateManySurveysInputEnvelope = {
    data: questionsCreateManySurveysInput | questionsCreateManySurveysInput[]
    skipDuplicates?: boolean
  }

  export type questionsUpsertWithWhereUniqueWithoutSurveysInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutSurveysInput, questionsUncheckedUpdateWithoutSurveysInput>
    create: XOR<questionsCreateWithoutSurveysInput, questionsUncheckedCreateWithoutSurveysInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutSurveysInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutSurveysInput, questionsUncheckedUpdateWithoutSurveysInput>
  }

  export type questionsUpdateManyWithWhereWithoutSurveysInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutSurveysInput>
  }

  export type questionsScalarWhereInput = {
    AND?: questionsScalarWhereInput | questionsScalarWhereInput[]
    OR?: questionsScalarWhereInput[]
    NOT?: questionsScalarWhereInput | questionsScalarWhereInput[]
    id?: BytesFilter<"questions"> | Uint8Array
    content?: StringFilter<"questions"> | string
    survey_id?: BytesFilter<"questions"> | Uint8Array
    question_type_id?: BytesFilter<"questions"> | Uint8Array
  }

  export type classesCreateWithoutTeachersInput = {
    id?: Uint8Array
    class_names: class_namesCreateNestedOneWithoutClassesInput
    school_years: school_yearsCreateNestedOneWithoutClassesInput
    classes_exams?: classes_examsCreateNestedManyWithoutClassesInput
    lessons?: lessonsCreateNestedManyWithoutClassesInput
    students?: studentsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutTeachersInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutClassesInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutClassesInput
    students?: studentsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutTeachersInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutTeachersInput, classesUncheckedCreateWithoutTeachersInput>
  }

  export type classesCreateManyTeachersInputEnvelope = {
    data: classesCreateManyTeachersInput | classesCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type examsCreateWithoutTeachersInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutTeachersInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutTeachersInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput>
  }

  export type examsCreateManyTeachersInputEnvelope = {
    data: examsCreateManyTeachersInput | examsCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type final_gradesCreateWithoutTeachersInput = {
    id?: Uint8Array
    grade: number
    students: studentsCreateNestedOneWithoutFinal_gradesInput
    subjects: subjectsCreateNestedOneWithoutFinal_gradesInput
    semesters: semestersCreateNestedOneWithoutFinal_gradesInput
  }

  export type final_gradesUncheckedCreateWithoutTeachersInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    subject_id: Uint8Array
    semester_id: Uint8Array
  }

  export type final_gradesCreateOrConnectWithoutTeachersInput = {
    where: final_gradesWhereUniqueInput
    create: XOR<final_gradesCreateWithoutTeachersInput, final_gradesUncheckedCreateWithoutTeachersInput>
  }

  export type final_gradesCreateManyTeachersInputEnvelope = {
    data: final_gradesCreateManyTeachersInput | final_gradesCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type grades_gradebookCreateWithoutTeachersInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    students: studentsCreateNestedOneWithoutGrades_gradebookInput
    subjects: subjectsCreateNestedOneWithoutGrades_gradebookInput
  }

  export type grades_gradebookUncheckedCreateWithoutTeachersInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    student_id: Uint8Array
    subject_id: Uint8Array
  }

  export type grades_gradebookCreateOrConnectWithoutTeachersInput = {
    where: grades_gradebookWhereUniqueInput
    create: XOR<grades_gradebookCreateWithoutTeachersInput, grades_gradebookUncheckedCreateWithoutTeachersInput>
  }

  export type grades_gradebookCreateManyTeachersInputEnvelope = {
    data: grades_gradebookCreateManyTeachersInput | grades_gradebookCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type lessonsCreateWithoutTeachersInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    attendances?: attendancesCreateNestedManyWithoutLessonsInput
    exams?: examsCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksCreateNestedOneWithoutLessonsInput
    classes: classesCreateNestedOneWithoutLessonsInput
    subjects: subjectsCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateWithoutTeachersInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    class_id: Uint8Array
    subject_id: Uint8Array
    attendances?: attendancesUncheckedCreateNestedManyWithoutLessonsInput
    exams?: examsUncheckedCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksUncheckedCreateNestedOneWithoutLessonsInput
  }

  export type lessonsCreateOrConnectWithoutTeachersInput = {
    where: lessonsWhereUniqueInput
    create: XOR<lessonsCreateWithoutTeachersInput, lessonsUncheckedCreateWithoutTeachersInput>
  }

  export type lessonsCreateManyTeachersInputEnvelope = {
    data: lessonsCreateManyTeachersInput | lessonsCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type teachers_subjectsCreateWithoutTeachersInput = {
    subjects: subjectsCreateNestedOneWithoutTeachers_subjectsInput
  }

  export type teachers_subjectsUncheckedCreateWithoutTeachersInput = {
    subject_id: Uint8Array
  }

  export type teachers_subjectsCreateOrConnectWithoutTeachersInput = {
    where: teachers_subjectsWhereUniqueInput
    create: XOR<teachers_subjectsCreateWithoutTeachersInput, teachers_subjectsUncheckedCreateWithoutTeachersInput>
  }

  export type teachers_subjectsCreateManyTeachersInputEnvelope = {
    data: teachers_subjectsCreateManyTeachersInput | teachers_subjectsCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutTeachersInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutTeachersInput, classesUncheckedUpdateWithoutTeachersInput>
    create: XOR<classesCreateWithoutTeachersInput, classesUncheckedCreateWithoutTeachersInput>
  }

  export type classesUpdateWithWhereUniqueWithoutTeachersInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutTeachersInput, classesUncheckedUpdateWithoutTeachersInput>
  }

  export type classesUpdateManyWithWhereWithoutTeachersInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutTeachersInput>
  }

  export type classesScalarWhereInput = {
    AND?: classesScalarWhereInput | classesScalarWhereInput[]
    OR?: classesScalarWhereInput[]
    NOT?: classesScalarWhereInput | classesScalarWhereInput[]
    id?: BytesFilter<"classes"> | Uint8Array
    class_name_id?: BytesFilter<"classes"> | Uint8Array
    school_year_id?: BytesFilter<"classes"> | Uint8Array
    teacher_id?: BytesNullableFilter<"classes"> | Uint8Array | null
  }

  export type examsUpsertWithWhereUniqueWithoutTeachersInput = {
    where: examsWhereUniqueInput
    update: XOR<examsUpdateWithoutTeachersInput, examsUncheckedUpdateWithoutTeachersInput>
    create: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput>
  }

  export type examsUpdateWithWhereUniqueWithoutTeachersInput = {
    where: examsWhereUniqueInput
    data: XOR<examsUpdateWithoutTeachersInput, examsUncheckedUpdateWithoutTeachersInput>
  }

  export type examsUpdateManyWithWhereWithoutTeachersInput = {
    where: examsScalarWhereInput
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyWithoutTeachersInput>
  }

  export type final_gradesUpsertWithWhereUniqueWithoutTeachersInput = {
    where: final_gradesWhereUniqueInput
    update: XOR<final_gradesUpdateWithoutTeachersInput, final_gradesUncheckedUpdateWithoutTeachersInput>
    create: XOR<final_gradesCreateWithoutTeachersInput, final_gradesUncheckedCreateWithoutTeachersInput>
  }

  export type final_gradesUpdateWithWhereUniqueWithoutTeachersInput = {
    where: final_gradesWhereUniqueInput
    data: XOR<final_gradesUpdateWithoutTeachersInput, final_gradesUncheckedUpdateWithoutTeachersInput>
  }

  export type final_gradesUpdateManyWithWhereWithoutTeachersInput = {
    where: final_gradesScalarWhereInput
    data: XOR<final_gradesUpdateManyMutationInput, final_gradesUncheckedUpdateManyWithoutTeachersInput>
  }

  export type grades_gradebookUpsertWithWhereUniqueWithoutTeachersInput = {
    where: grades_gradebookWhereUniqueInput
    update: XOR<grades_gradebookUpdateWithoutTeachersInput, grades_gradebookUncheckedUpdateWithoutTeachersInput>
    create: XOR<grades_gradebookCreateWithoutTeachersInput, grades_gradebookUncheckedCreateWithoutTeachersInput>
  }

  export type grades_gradebookUpdateWithWhereUniqueWithoutTeachersInput = {
    where: grades_gradebookWhereUniqueInput
    data: XOR<grades_gradebookUpdateWithoutTeachersInput, grades_gradebookUncheckedUpdateWithoutTeachersInput>
  }

  export type grades_gradebookUpdateManyWithWhereWithoutTeachersInput = {
    where: grades_gradebookScalarWhereInput
    data: XOR<grades_gradebookUpdateManyMutationInput, grades_gradebookUncheckedUpdateManyWithoutTeachersInput>
  }

  export type lessonsUpsertWithWhereUniqueWithoutTeachersInput = {
    where: lessonsWhereUniqueInput
    update: XOR<lessonsUpdateWithoutTeachersInput, lessonsUncheckedUpdateWithoutTeachersInput>
    create: XOR<lessonsCreateWithoutTeachersInput, lessonsUncheckedCreateWithoutTeachersInput>
  }

  export type lessonsUpdateWithWhereUniqueWithoutTeachersInput = {
    where: lessonsWhereUniqueInput
    data: XOR<lessonsUpdateWithoutTeachersInput, lessonsUncheckedUpdateWithoutTeachersInput>
  }

  export type lessonsUpdateManyWithWhereWithoutTeachersInput = {
    where: lessonsScalarWhereInput
    data: XOR<lessonsUpdateManyMutationInput, lessonsUncheckedUpdateManyWithoutTeachersInput>
  }

  export type teachers_subjectsUpsertWithWhereUniqueWithoutTeachersInput = {
    where: teachers_subjectsWhereUniqueInput
    update: XOR<teachers_subjectsUpdateWithoutTeachersInput, teachers_subjectsUncheckedUpdateWithoutTeachersInput>
    create: XOR<teachers_subjectsCreateWithoutTeachersInput, teachers_subjectsUncheckedCreateWithoutTeachersInput>
  }

  export type teachers_subjectsUpdateWithWhereUniqueWithoutTeachersInput = {
    where: teachers_subjectsWhereUniqueInput
    data: XOR<teachers_subjectsUpdateWithoutTeachersInput, teachers_subjectsUncheckedUpdateWithoutTeachersInput>
  }

  export type teachers_subjectsUpdateManyWithWhereWithoutTeachersInput = {
    where: teachers_subjectsScalarWhereInput
    data: XOR<teachers_subjectsUpdateManyMutationInput, teachers_subjectsUncheckedUpdateManyWithoutTeachersInput>
  }

  export type teachersCreateWithoutTeachers_subjectsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutTeachersInput
    lessons?: lessonsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutTeachers_subjectsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutTeachersInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutTeachers_subjectsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutTeachers_subjectsInput, teachersUncheckedCreateWithoutTeachers_subjectsInput>
  }

  export type subjectsCreateWithoutTeachers_subjectsInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesCreateNestedManyWithoutSubjectsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutTeachers_subjectsInput = {
    id?: Uint8Array
    name: string
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutSubjectsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutTeachers_subjectsInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutTeachers_subjectsInput, subjectsUncheckedCreateWithoutTeachers_subjectsInput>
  }

  export type teachersUpsertWithoutTeachers_subjectsInput = {
    update: XOR<teachersUpdateWithoutTeachers_subjectsInput, teachersUncheckedUpdateWithoutTeachers_subjectsInput>
    create: XOR<teachersCreateWithoutTeachers_subjectsInput, teachersUncheckedCreateWithoutTeachers_subjectsInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutTeachers_subjectsInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutTeachers_subjectsInput, teachersUncheckedUpdateWithoutTeachers_subjectsInput>
  }

  export type teachersUpdateWithoutTeachers_subjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutTeachers_subjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type subjectsUpsertWithoutTeachers_subjectsInput = {
    update: XOR<subjectsUpdateWithoutTeachers_subjectsInput, subjectsUncheckedUpdateWithoutTeachers_subjectsInput>
    create: XOR<subjectsCreateWithoutTeachers_subjectsInput, subjectsUncheckedCreateWithoutTeachers_subjectsInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutTeachers_subjectsInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutTeachers_subjectsInput, subjectsUncheckedUpdateWithoutTeachers_subjectsInput>
  }

  export type subjectsUpdateWithoutTeachers_subjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUpdateManyWithoutSubjectsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutTeachers_subjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    final_grades?: final_gradesUncheckedUpdateManyWithoutSubjectsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    receiver_id: Uint8Array
    user_types_messages_receiver_type_idTouser_types: user_typesCreateNestedOneWithoutMessages_messages_receiver_type_idTouser_typesInput
  }

  export type messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    receiver_id: Uint8Array
    receiver_type_id: Uint8Array
  }

  export type messagesCreateOrConnectWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput>
  }

  export type messagesCreateManyUser_types_messages_sender_type_idTouser_typesInputEnvelope = {
    data: messagesCreateManyUser_types_messages_sender_type_idTouser_typesInput | messagesCreateManyUser_types_messages_sender_type_idTouser_typesInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    receiver_id: Uint8Array
    user_types_messages_sender_type_idTouser_types: user_typesCreateNestedOneWithoutMessages_messages_sender_type_idTouser_typesInput
  }

  export type messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    sender_type_id: Uint8Array
    receiver_id: Uint8Array
  }

  export type messagesCreateOrConnectWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput>
  }

  export type messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInputEnvelope = {
    data: messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInput | messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInput[]
    skipDuplicates?: boolean
  }

  export type problems_gradebookCreateWithoutUser_typesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    reporter_id: Uint8Array
    problem_types: problem_typesCreateNestedOneWithoutProblems_gradebookInput
    statuses: statusesCreateNestedOneWithoutProblems_gradebookInput
  }

  export type problems_gradebookUncheckedCreateWithoutUser_typesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    problem_type_id: Uint8Array
    reporter_id: Uint8Array
    status_id: Uint8Array
  }

  export type problems_gradebookCreateOrConnectWithoutUser_typesInput = {
    where: problems_gradebookWhereUniqueInput
    create: XOR<problems_gradebookCreateWithoutUser_typesInput, problems_gradebookUncheckedCreateWithoutUser_typesInput>
  }

  export type problems_gradebookCreateManyUser_typesInputEnvelope = {
    data: problems_gradebookCreateManyUser_typesInput | problems_gradebookCreateManyUser_typesInput[]
    skipDuplicates?: boolean
  }

  export type messagesUpsertWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedUpdateWithoutUser_types_messages_sender_type_idTouser_typesInput>
    create: XOR<messagesCreateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_sender_type_idTouser_typesInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUser_types_messages_sender_type_idTouser_typesInput, messagesUncheckedUpdateWithoutUser_types_messages_sender_type_idTouser_typesInput>
  }

  export type messagesUpdateManyWithWhereWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesInput>
  }

  export type messagesScalarWhereInput = {
    AND?: messagesScalarWhereInput | messagesScalarWhereInput[]
    OR?: messagesScalarWhereInput[]
    NOT?: messagesScalarWhereInput | messagesScalarWhereInput[]
    id?: BytesFilter<"messages"> | Uint8Array
    subject?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    date_time?: DateTimeFilter<"messages"> | Date | string
    was_read?: BoolFilter<"messages"> | boolean
    sender_id?: BytesFilter<"messages"> | Uint8Array
    sender_type_id?: BytesFilter<"messages"> | Uint8Array
    receiver_id?: BytesFilter<"messages"> | Uint8Array
    receiver_type_id?: BytesFilter<"messages"> | Uint8Array
  }

  export type messagesUpsertWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedUpdateWithoutUser_types_messages_receiver_type_idTouser_typesInput>
    create: XOR<messagesCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedCreateWithoutUser_types_messages_receiver_type_idTouser_typesInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUser_types_messages_receiver_type_idTouser_typesInput, messagesUncheckedUpdateWithoutUser_types_messages_receiver_type_idTouser_typesInput>
  }

  export type messagesUpdateManyWithWhereWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesInput>
  }

  export type problems_gradebookUpsertWithWhereUniqueWithoutUser_typesInput = {
    where: problems_gradebookWhereUniqueInput
    update: XOR<problems_gradebookUpdateWithoutUser_typesInput, problems_gradebookUncheckedUpdateWithoutUser_typesInput>
    create: XOR<problems_gradebookCreateWithoutUser_typesInput, problems_gradebookUncheckedCreateWithoutUser_typesInput>
  }

  export type problems_gradebookUpdateWithWhereUniqueWithoutUser_typesInput = {
    where: problems_gradebookWhereUniqueInput
    data: XOR<problems_gradebookUpdateWithoutUser_typesInput, problems_gradebookUncheckedUpdateWithoutUser_typesInput>
  }

  export type problems_gradebookUpdateManyWithWhereWithoutUser_typesInput = {
    where: problems_gradebookScalarWhereInput
    data: XOR<problems_gradebookUpdateManyMutationInput, problems_gradebookUncheckedUpdateManyWithoutUser_typesInput>
  }

  export type classesCreateWithoutSchool_yearsInput = {
    id?: Uint8Array
    class_names: class_namesCreateNestedOneWithoutClassesInput
    teachers?: teachersCreateNestedOneWithoutClassesInput
    classes_exams?: classes_examsCreateNestedManyWithoutClassesInput
    lessons?: lessonsCreateNestedManyWithoutClassesInput
    students?: studentsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutSchool_yearsInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    teacher_id?: Uint8Array | null
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutClassesInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutClassesInput
    students?: studentsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutSchool_yearsInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutSchool_yearsInput, classesUncheckedCreateWithoutSchool_yearsInput>
  }

  export type classesCreateManySchool_yearsInputEnvelope = {
    data: classesCreateManySchool_yearsInput | classesCreateManySchool_yearsInput[]
    skipDuplicates?: boolean
  }

  export type semestersCreateWithoutSchool_yearsInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
    final_grades?: final_gradesCreateNestedManyWithoutSemestersInput
  }

  export type semestersUncheckedCreateWithoutSchool_yearsInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutSemestersInput
  }

  export type semestersCreateOrConnectWithoutSchool_yearsInput = {
    where: semestersWhereUniqueInput
    create: XOR<semestersCreateWithoutSchool_yearsInput, semestersUncheckedCreateWithoutSchool_yearsInput>
  }

  export type semestersCreateManySchool_yearsInputEnvelope = {
    data: semestersCreateManySchool_yearsInput | semestersCreateManySchool_yearsInput[]
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutSchool_yearsInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutSchool_yearsInput, classesUncheckedUpdateWithoutSchool_yearsInput>
    create: XOR<classesCreateWithoutSchool_yearsInput, classesUncheckedCreateWithoutSchool_yearsInput>
  }

  export type classesUpdateWithWhereUniqueWithoutSchool_yearsInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutSchool_yearsInput, classesUncheckedUpdateWithoutSchool_yearsInput>
  }

  export type classesUpdateManyWithWhereWithoutSchool_yearsInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutSchool_yearsInput>
  }

  export type semestersUpsertWithWhereUniqueWithoutSchool_yearsInput = {
    where: semestersWhereUniqueInput
    update: XOR<semestersUpdateWithoutSchool_yearsInput, semestersUncheckedUpdateWithoutSchool_yearsInput>
    create: XOR<semestersCreateWithoutSchool_yearsInput, semestersUncheckedCreateWithoutSchool_yearsInput>
  }

  export type semestersUpdateWithWhereUniqueWithoutSchool_yearsInput = {
    where: semestersWhereUniqueInput
    data: XOR<semestersUpdateWithoutSchool_yearsInput, semestersUncheckedUpdateWithoutSchool_yearsInput>
  }

  export type semestersUpdateManyWithWhereWithoutSchool_yearsInput = {
    where: semestersScalarWhereInput
    data: XOR<semestersUpdateManyMutationInput, semestersUncheckedUpdateManyWithoutSchool_yearsInput>
  }

  export type semestersScalarWhereInput = {
    AND?: semestersScalarWhereInput | semestersScalarWhereInput[]
    OR?: semestersScalarWhereInput[]
    NOT?: semestersScalarWhereInput | semestersScalarWhereInput[]
    id?: BytesFilter<"semesters"> | Uint8Array
    semester?: IntFilter<"semesters"> | number
    start_date?: DateTimeFilter<"semesters"> | Date | string
    end_date?: DateTimeFilter<"semesters"> | Date | string
    school_year_id?: BytesFilter<"semesters"> | Uint8Array
  }

  export type final_gradesCreateWithoutSemestersInput = {
    id?: Uint8Array
    grade: number
    students: studentsCreateNestedOneWithoutFinal_gradesInput
    subjects: subjectsCreateNestedOneWithoutFinal_gradesInput
    teachers: teachersCreateNestedOneWithoutFinal_gradesInput
  }

  export type final_gradesUncheckedCreateWithoutSemestersInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type final_gradesCreateOrConnectWithoutSemestersInput = {
    where: final_gradesWhereUniqueInput
    create: XOR<final_gradesCreateWithoutSemestersInput, final_gradesUncheckedCreateWithoutSemestersInput>
  }

  export type final_gradesCreateManySemestersInputEnvelope = {
    data: final_gradesCreateManySemestersInput | final_gradesCreateManySemestersInput[]
    skipDuplicates?: boolean
  }

  export type school_yearsCreateWithoutSemestersInput = {
    id?: Uint8Array
    name: string
    start_date: Date | string
    end_date: Date | string
    classes?: classesCreateNestedManyWithoutSchool_yearsInput
  }

  export type school_yearsUncheckedCreateWithoutSemestersInput = {
    id?: Uint8Array
    name: string
    start_date: Date | string
    end_date: Date | string
    classes?: classesUncheckedCreateNestedManyWithoutSchool_yearsInput
  }

  export type school_yearsCreateOrConnectWithoutSemestersInput = {
    where: school_yearsWhereUniqueInput
    create: XOR<school_yearsCreateWithoutSemestersInput, school_yearsUncheckedCreateWithoutSemestersInput>
  }

  export type final_gradesUpsertWithWhereUniqueWithoutSemestersInput = {
    where: final_gradesWhereUniqueInput
    update: XOR<final_gradesUpdateWithoutSemestersInput, final_gradesUncheckedUpdateWithoutSemestersInput>
    create: XOR<final_gradesCreateWithoutSemestersInput, final_gradesUncheckedCreateWithoutSemestersInput>
  }

  export type final_gradesUpdateWithWhereUniqueWithoutSemestersInput = {
    where: final_gradesWhereUniqueInput
    data: XOR<final_gradesUpdateWithoutSemestersInput, final_gradesUncheckedUpdateWithoutSemestersInput>
  }

  export type final_gradesUpdateManyWithWhereWithoutSemestersInput = {
    where: final_gradesScalarWhereInput
    data: XOR<final_gradesUpdateManyMutationInput, final_gradesUncheckedUpdateManyWithoutSemestersInput>
  }

  export type school_yearsUpsertWithoutSemestersInput = {
    update: XOR<school_yearsUpdateWithoutSemestersInput, school_yearsUncheckedUpdateWithoutSemestersInput>
    create: XOR<school_yearsCreateWithoutSemestersInput, school_yearsUncheckedCreateWithoutSemestersInput>
    where?: school_yearsWhereInput
  }

  export type school_yearsUpdateToOneWithWhereWithoutSemestersInput = {
    where?: school_yearsWhereInput
    data: XOR<school_yearsUpdateWithoutSemestersInput, school_yearsUncheckedUpdateWithoutSemestersInput>
  }

  export type school_yearsUpdateWithoutSemestersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: classesUpdateManyWithoutSchool_yearsNestedInput
  }

  export type school_yearsUncheckedUpdateWithoutSemestersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: classesUncheckedUpdateManyWithoutSchool_yearsNestedInput
  }

  export type classesCreateWithoutClass_namesInput = {
    id?: Uint8Array
    school_years: school_yearsCreateNestedOneWithoutClassesInput
    teachers?: teachersCreateNestedOneWithoutClassesInput
    classes_exams?: classes_examsCreateNestedManyWithoutClassesInput
    lessons?: lessonsCreateNestedManyWithoutClassesInput
    students?: studentsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutClass_namesInput = {
    id?: Uint8Array
    school_year_id: Uint8Array
    teacher_id?: Uint8Array | null
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutClassesInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutClassesInput
    students?: studentsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutClass_namesInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutClass_namesInput, classesUncheckedCreateWithoutClass_namesInput>
  }

  export type classesCreateManyClass_namesInputEnvelope = {
    data: classesCreateManyClass_namesInput | classesCreateManyClass_namesInput[]
    skipDuplicates?: boolean
  }

  export type classesUpsertWithWhereUniqueWithoutClass_namesInput = {
    where: classesWhereUniqueInput
    update: XOR<classesUpdateWithoutClass_namesInput, classesUncheckedUpdateWithoutClass_namesInput>
    create: XOR<classesCreateWithoutClass_namesInput, classesUncheckedCreateWithoutClass_namesInput>
  }

  export type classesUpdateWithWhereUniqueWithoutClass_namesInput = {
    where: classesWhereUniqueInput
    data: XOR<classesUpdateWithoutClass_namesInput, classesUncheckedUpdateWithoutClass_namesInput>
  }

  export type classesUpdateManyWithWhereWithoutClass_namesInput = {
    where: classesScalarWhereInput
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyWithoutClass_namesInput>
  }

  export type attemptsCreateWithoutExamsInput = {
    id?: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsCreateNestedManyWithoutAttemptsInput
    students: studentsCreateNestedOneWithoutAttemptsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutAttemptsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsCreateOrConnectWithoutExamsInput = {
    where: attemptsWhereUniqueInput
    create: XOR<attemptsCreateWithoutExamsInput, attemptsUncheckedCreateWithoutExamsInput>
  }

  export type attemptsCreateManyExamsInputEnvelope = {
    data: attemptsCreateManyExamsInput | attemptsCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type classes_examsCreateWithoutExamsInput = {
    classes: classesCreateNestedOneWithoutClasses_examsInput
  }

  export type classes_examsUncheckedCreateWithoutExamsInput = {
    class_id: Uint8Array
  }

  export type classes_examsCreateOrConnectWithoutExamsInput = {
    where: classes_examsWhereUniqueInput
    create: XOR<classes_examsCreateWithoutExamsInput, classes_examsUncheckedCreateWithoutExamsInput>
  }

  export type classes_examsCreateManyExamsInputEnvelope = {
    data: classes_examsCreateManyExamsInput | classes_examsCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type closed_questionsCreateWithoutExamsInput = {
    id?: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsCreateNestedManyWithoutClosed_questionsInput
    closed_answers?: closed_answersCreateNestedManyWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutClosed_questionsInput
    closed_answers?: closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsCreateOrConnectWithoutExamsInput = {
    where: closed_questionsWhereUniqueInput
    create: XOR<closed_questionsCreateWithoutExamsInput, closed_questionsUncheckedCreateWithoutExamsInput>
  }

  export type closed_questionsCreateManyExamsInputEnvelope = {
    data: closed_questionsCreateManyExamsInput | closed_questionsCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type lessonsCreateWithoutExamsInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    attendances?: attendancesCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksCreateNestedOneWithoutLessonsInput
    teachers: teachersCreateNestedOneWithoutLessonsInput
    classes: classesCreateNestedOneWithoutLessonsInput
    subjects: subjectsCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
    subject_id: Uint8Array
    attendances?: attendancesUncheckedCreateNestedManyWithoutLessonsInput
    gradebook_exams?: gradebook_examsUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksUncheckedCreateNestedOneWithoutLessonsInput
  }

  export type lessonsCreateOrConnectWithoutExamsInput = {
    where: lessonsWhereUniqueInput
    create: XOR<lessonsCreateWithoutExamsInput, lessonsUncheckedCreateWithoutExamsInput>
  }

  export type teachersCreateWithoutExamsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutTeachersInput
    lessons?: lessonsCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutTeachersInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutTeachersInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutExamsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
  }

  export type files_repositoryCreateWithoutExamsInput = {
    id?: Uint8Array
    title: string
    description: string
    file: Uint8Array
  }

  export type files_repositoryUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    title: string
    description: string
    file: Uint8Array
  }

  export type files_repositoryCreateOrConnectWithoutExamsInput = {
    where: files_repositoryWhereUniqueInput
    create: XOR<files_repositoryCreateWithoutExamsInput, files_repositoryUncheckedCreateWithoutExamsInput>
  }

  export type files_repositoryCreateManyExamsInputEnvelope = {
    data: files_repositoryCreateManyExamsInput | files_repositoryCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type grades_examsCreateWithoutExamsInput = {
    id?: Uint8Array
    attempt_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
    students: studentsCreateNestedOneWithoutGrades_examsInput
  }

  export type grades_examsUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    attempt_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
  }

  export type grades_examsCreateOrConnectWithoutExamsInput = {
    where: grades_examsWhereUniqueInput
    create: XOR<grades_examsCreateWithoutExamsInput, grades_examsUncheckedCreateWithoutExamsInput>
  }

  export type grades_examsCreateManyExamsInputEnvelope = {
    data: grades_examsCreateManyExamsInput | grades_examsCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutExamsInput = {
    id?: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
    students: studentsCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
  }

  export type notificationsCreateOrConnectWithoutExamsInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutExamsInput, notificationsUncheckedCreateWithoutExamsInput>
  }

  export type notificationsCreateManyExamsInputEnvelope = {
    data: notificationsCreateManyExamsInput | notificationsCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type open_questionsCreateWithoutExamsInput = {
    id?: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsCreateNestedManyWithoutOpen_questionsInput
    open_answers?: open_answersCreateNestedManyWithoutOpen_questionsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsUncheckedCreateWithoutExamsInput = {
    id?: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutOpen_questionsInput
    open_answers?: open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsCreateOrConnectWithoutExamsInput = {
    where: open_questionsWhereUniqueInput
    create: XOR<open_questionsCreateWithoutExamsInput, open_questionsUncheckedCreateWithoutExamsInput>
  }

  export type open_questionsCreateManyExamsInputEnvelope = {
    data: open_questionsCreateManyExamsInput | open_questionsCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type students_examsCreateWithoutExamsInput = {
    students: studentsCreateNestedOneWithoutStudents_examsInput
  }

  export type students_examsUncheckedCreateWithoutExamsInput = {
    students_id: Uint8Array
  }

  export type students_examsCreateOrConnectWithoutExamsInput = {
    where: students_examsWhereUniqueInput
    create: XOR<students_examsCreateWithoutExamsInput, students_examsUncheckedCreateWithoutExamsInput>
  }

  export type students_examsCreateManyExamsInputEnvelope = {
    data: students_examsCreateManyExamsInput | students_examsCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type attemptsUpsertWithWhereUniqueWithoutExamsInput = {
    where: attemptsWhereUniqueInput
    update: XOR<attemptsUpdateWithoutExamsInput, attemptsUncheckedUpdateWithoutExamsInput>
    create: XOR<attemptsCreateWithoutExamsInput, attemptsUncheckedCreateWithoutExamsInput>
  }

  export type attemptsUpdateWithWhereUniqueWithoutExamsInput = {
    where: attemptsWhereUniqueInput
    data: XOR<attemptsUpdateWithoutExamsInput, attemptsUncheckedUpdateWithoutExamsInput>
  }

  export type attemptsUpdateManyWithWhereWithoutExamsInput = {
    where: attemptsScalarWhereInput
    data: XOR<attemptsUpdateManyMutationInput, attemptsUncheckedUpdateManyWithoutExamsInput>
  }

  export type classes_examsUpsertWithWhereUniqueWithoutExamsInput = {
    where: classes_examsWhereUniqueInput
    update: XOR<classes_examsUpdateWithoutExamsInput, classes_examsUncheckedUpdateWithoutExamsInput>
    create: XOR<classes_examsCreateWithoutExamsInput, classes_examsUncheckedCreateWithoutExamsInput>
  }

  export type classes_examsUpdateWithWhereUniqueWithoutExamsInput = {
    where: classes_examsWhereUniqueInput
    data: XOR<classes_examsUpdateWithoutExamsInput, classes_examsUncheckedUpdateWithoutExamsInput>
  }

  export type classes_examsUpdateManyWithWhereWithoutExamsInput = {
    where: classes_examsScalarWhereInput
    data: XOR<classes_examsUpdateManyMutationInput, classes_examsUncheckedUpdateManyWithoutExamsInput>
  }

  export type closed_questionsUpsertWithWhereUniqueWithoutExamsInput = {
    where: closed_questionsWhereUniqueInput
    update: XOR<closed_questionsUpdateWithoutExamsInput, closed_questionsUncheckedUpdateWithoutExamsInput>
    create: XOR<closed_questionsCreateWithoutExamsInput, closed_questionsUncheckedCreateWithoutExamsInput>
  }

  export type closed_questionsUpdateWithWhereUniqueWithoutExamsInput = {
    where: closed_questionsWhereUniqueInput
    data: XOR<closed_questionsUpdateWithoutExamsInput, closed_questionsUncheckedUpdateWithoutExamsInput>
  }

  export type closed_questionsUpdateManyWithWhereWithoutExamsInput = {
    where: closed_questionsScalarWhereInput
    data: XOR<closed_questionsUpdateManyMutationInput, closed_questionsUncheckedUpdateManyWithoutExamsInput>
  }

  export type closed_questionsScalarWhereInput = {
    AND?: closed_questionsScalarWhereInput | closed_questionsScalarWhereInput[]
    OR?: closed_questionsScalarWhereInput[]
    NOT?: closed_questionsScalarWhereInput | closed_questionsScalarWhereInput[]
    id?: BytesFilter<"closed_questions"> | Uint8Array
    exam_id?: BytesFilter<"closed_questions"> | Uint8Array
    score?: IntNullableFilter<"closed_questions"> | number | null
    is_multiple?: BoolNullableFilter<"closed_questions"> | boolean | null
    description?: StringFilter<"closed_questions"> | string
  }

  export type lessonsUpsertWithoutExamsInput = {
    update: XOR<lessonsUpdateWithoutExamsInput, lessonsUncheckedUpdateWithoutExamsInput>
    create: XOR<lessonsCreateWithoutExamsInput, lessonsUncheckedCreateWithoutExamsInput>
    where?: lessonsWhereInput
  }

  export type lessonsUpdateToOneWithWhereWithoutExamsInput = {
    where?: lessonsWhereInput
    data: XOR<lessonsUpdateWithoutExamsInput, lessonsUncheckedUpdateWithoutExamsInput>
  }

  export type lessonsUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: attendancesUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUpdateOneWithoutLessonsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLessonsNestedInput
    classes?: classesUpdateOneRequiredWithoutLessonsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attendances?: attendancesUncheckedUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUncheckedUpdateOneWithoutLessonsNestedInput
  }

  export type teachersUpsertWithoutExamsInput = {
    update: XOR<teachersUpdateWithoutExamsInput, teachersUncheckedUpdateWithoutExamsInput>
    create: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutExamsInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutExamsInput, teachersUncheckedUpdateWithoutExamsInput>
  }

  export type teachersUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutTeachersNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type files_repositoryUpsertWithWhereUniqueWithoutExamsInput = {
    where: files_repositoryWhereUniqueInput
    update: XOR<files_repositoryUpdateWithoutExamsInput, files_repositoryUncheckedUpdateWithoutExamsInput>
    create: XOR<files_repositoryCreateWithoutExamsInput, files_repositoryUncheckedCreateWithoutExamsInput>
  }

  export type files_repositoryUpdateWithWhereUniqueWithoutExamsInput = {
    where: files_repositoryWhereUniqueInput
    data: XOR<files_repositoryUpdateWithoutExamsInput, files_repositoryUncheckedUpdateWithoutExamsInput>
  }

  export type files_repositoryUpdateManyWithWhereWithoutExamsInput = {
    where: files_repositoryScalarWhereInput
    data: XOR<files_repositoryUpdateManyMutationInput, files_repositoryUncheckedUpdateManyWithoutExamsInput>
  }

  export type files_repositoryScalarWhereInput = {
    AND?: files_repositoryScalarWhereInput | files_repositoryScalarWhereInput[]
    OR?: files_repositoryScalarWhereInput[]
    NOT?: files_repositoryScalarWhereInput | files_repositoryScalarWhereInput[]
    id?: BytesFilter<"files_repository"> | Uint8Array
    title?: StringFilter<"files_repository"> | string
    description?: StringFilter<"files_repository"> | string
    file?: BytesFilter<"files_repository"> | Uint8Array
    exam_id?: BytesFilter<"files_repository"> | Uint8Array
  }

  export type grades_examsUpsertWithWhereUniqueWithoutExamsInput = {
    where: grades_examsWhereUniqueInput
    update: XOR<grades_examsUpdateWithoutExamsInput, grades_examsUncheckedUpdateWithoutExamsInput>
    create: XOR<grades_examsCreateWithoutExamsInput, grades_examsUncheckedCreateWithoutExamsInput>
  }

  export type grades_examsUpdateWithWhereUniqueWithoutExamsInput = {
    where: grades_examsWhereUniqueInput
    data: XOR<grades_examsUpdateWithoutExamsInput, grades_examsUncheckedUpdateWithoutExamsInput>
  }

  export type grades_examsUpdateManyWithWhereWithoutExamsInput = {
    where: grades_examsScalarWhereInput
    data: XOR<grades_examsUpdateManyMutationInput, grades_examsUncheckedUpdateManyWithoutExamsInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutExamsInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutExamsInput, notificationsUncheckedUpdateWithoutExamsInput>
    create: XOR<notificationsCreateWithoutExamsInput, notificationsUncheckedCreateWithoutExamsInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutExamsInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutExamsInput, notificationsUncheckedUpdateWithoutExamsInput>
  }

  export type notificationsUpdateManyWithWhereWithoutExamsInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutExamsInput>
  }

  export type open_questionsUpsertWithWhereUniqueWithoutExamsInput = {
    where: open_questionsWhereUniqueInput
    update: XOR<open_questionsUpdateWithoutExamsInput, open_questionsUncheckedUpdateWithoutExamsInput>
    create: XOR<open_questionsCreateWithoutExamsInput, open_questionsUncheckedCreateWithoutExamsInput>
  }

  export type open_questionsUpdateWithWhereUniqueWithoutExamsInput = {
    where: open_questionsWhereUniqueInput
    data: XOR<open_questionsUpdateWithoutExamsInput, open_questionsUncheckedUpdateWithoutExamsInput>
  }

  export type open_questionsUpdateManyWithWhereWithoutExamsInput = {
    where: open_questionsScalarWhereInput
    data: XOR<open_questionsUpdateManyMutationInput, open_questionsUncheckedUpdateManyWithoutExamsInput>
  }

  export type open_questionsScalarWhereInput = {
    AND?: open_questionsScalarWhereInput | open_questionsScalarWhereInput[]
    OR?: open_questionsScalarWhereInput[]
    NOT?: open_questionsScalarWhereInput | open_questionsScalarWhereInput[]
    id?: BytesFilter<"open_questions"> | Uint8Array
    exam_id?: BytesFilter<"open_questions"> | Uint8Array
    auto_check?: BoolFilter<"open_questions"> | boolean
    description?: StringNullableFilter<"open_questions"> | string | null
    score?: IntFilter<"open_questions"> | number
  }

  export type students_examsUpsertWithWhereUniqueWithoutExamsInput = {
    where: students_examsWhereUniqueInput
    update: XOR<students_examsUpdateWithoutExamsInput, students_examsUncheckedUpdateWithoutExamsInput>
    create: XOR<students_examsCreateWithoutExamsInput, students_examsUncheckedCreateWithoutExamsInput>
  }

  export type students_examsUpdateWithWhereUniqueWithoutExamsInput = {
    where: students_examsWhereUniqueInput
    data: XOR<students_examsUpdateWithoutExamsInput, students_examsUncheckedUpdateWithoutExamsInput>
  }

  export type students_examsUpdateManyWithWhereWithoutExamsInput = {
    where: students_examsScalarWhereInput
    data: XOR<students_examsUpdateManyMutationInput, students_examsUncheckedUpdateManyWithoutExamsInput>
  }

  export type studentsCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutFinal_gradesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutFinal_gradesInput, studentsUncheckedCreateWithoutFinal_gradesInput>
  }

  export type subjectsCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    name: string
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    name: string
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutSubjectsInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutSubjectsInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutFinal_gradesInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutFinal_gradesInput, subjectsUncheckedCreateWithoutFinal_gradesInput>
  }

  export type teachersCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutTeachersInput
    lessons?: lessonsCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    classes?: classesUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutTeachersInput
    lessons?: lessonsUncheckedCreateNestedManyWithoutTeachersInput
    teachers_subjects?: teachers_subjectsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutFinal_gradesInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutFinal_gradesInput, teachersUncheckedCreateWithoutFinal_gradesInput>
  }

  export type semestersCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
    school_years: school_yearsCreateNestedOneWithoutSemestersInput
  }

  export type semestersUncheckedCreateWithoutFinal_gradesInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
    school_year_id: Uint8Array
  }

  export type semestersCreateOrConnectWithoutFinal_gradesInput = {
    where: semestersWhereUniqueInput
    create: XOR<semestersCreateWithoutFinal_gradesInput, semestersUncheckedCreateWithoutFinal_gradesInput>
  }

  export type studentsUpsertWithoutFinal_gradesInput = {
    update: XOR<studentsUpdateWithoutFinal_gradesInput, studentsUncheckedUpdateWithoutFinal_gradesInput>
    create: XOR<studentsCreateWithoutFinal_gradesInput, studentsUncheckedCreateWithoutFinal_gradesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutFinal_gradesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutFinal_gradesInput, studentsUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type studentsUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type subjectsUpsertWithoutFinal_gradesInput = {
    update: XOR<subjectsUpdateWithoutFinal_gradesInput, subjectsUncheckedUpdateWithoutFinal_gradesInput>
    create: XOR<subjectsCreateWithoutFinal_gradesInput, subjectsUncheckedCreateWithoutFinal_gradesInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutFinal_gradesInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutFinal_gradesInput, subjectsUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type subjectsUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    grades_gradebook?: grades_gradebookUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutSubjectsNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutSubjectsNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type teachersUpsertWithoutFinal_gradesInput = {
    update: XOR<teachersUpdateWithoutFinal_gradesInput, teachersUncheckedUpdateWithoutFinal_gradesInput>
    create: XOR<teachersCreateWithoutFinal_gradesInput, teachersUncheckedCreateWithoutFinal_gradesInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutFinal_gradesInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutFinal_gradesInput, teachersUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type teachersUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: classesUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutTeachersNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutTeachersNestedInput
    teachers_subjects?: teachers_subjectsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type semestersUpsertWithoutFinal_gradesInput = {
    update: XOR<semestersUpdateWithoutFinal_gradesInput, semestersUncheckedUpdateWithoutFinal_gradesInput>
    create: XOR<semestersCreateWithoutFinal_gradesInput, semestersUncheckedCreateWithoutFinal_gradesInput>
    where?: semestersWhereInput
  }

  export type semestersUpdateToOneWithWhereWithoutFinal_gradesInput = {
    where?: semestersWhereInput
    data: XOR<semestersUpdateWithoutFinal_gradesInput, semestersUncheckedUpdateWithoutFinal_gradesInput>
  }

  export type semestersUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    school_years?: school_yearsUpdateOneRequiredWithoutSemestersNestedInput
  }

  export type semestersUncheckedUpdateWithoutFinal_gradesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type surveysCreateWithoutQuestionsInput = {
    id?: Uint8Array
    name: string
    description: string
    start_time: Date | string
    end_time: Date | string
  }

  export type surveysUncheckedCreateWithoutQuestionsInput = {
    id?: Uint8Array
    name: string
    description: string
    start_time: Date | string
    end_time: Date | string
  }

  export type surveysCreateOrConnectWithoutQuestionsInput = {
    where: surveysWhereUniqueInput
    create: XOR<surveysCreateWithoutQuestionsInput, surveysUncheckedCreateWithoutQuestionsInput>
  }

  export type questions_typesCreateWithoutQuestionsInput = {
    id?: Uint8Array
    name: string
  }

  export type questions_typesUncheckedCreateWithoutQuestionsInput = {
    id?: Uint8Array
    name: string
  }

  export type questions_typesCreateOrConnectWithoutQuestionsInput = {
    where: questions_typesWhereUniqueInput
    create: XOR<questions_typesCreateWithoutQuestionsInput, questions_typesUncheckedCreateWithoutQuestionsInput>
  }

  export type questions_possible_responsesCreateWithoutQuestionsInput = {
    id?: Uint8Array
    content: string
  }

  export type questions_possible_responsesUncheckedCreateWithoutQuestionsInput = {
    id?: Uint8Array
    content: string
  }

  export type questions_possible_responsesCreateOrConnectWithoutQuestionsInput = {
    where: questions_possible_responsesWhereUniqueInput
    create: XOR<questions_possible_responsesCreateWithoutQuestionsInput, questions_possible_responsesUncheckedCreateWithoutQuestionsInput>
  }

  export type questions_possible_responsesCreateManyQuestionsInputEnvelope = {
    data: questions_possible_responsesCreateManyQuestionsInput | questions_possible_responsesCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type questions_responsesCreateWithoutQuestionsInput = {
    id?: Uint8Array
    content: string
    students: studentsCreateNestedOneWithoutQuestions_responsesInput
  }

  export type questions_responsesUncheckedCreateWithoutQuestionsInput = {
    id?: Uint8Array
    content: string
    student_id: Uint8Array
  }

  export type questions_responsesCreateOrConnectWithoutQuestionsInput = {
    where: questions_responsesWhereUniqueInput
    create: XOR<questions_responsesCreateWithoutQuestionsInput, questions_responsesUncheckedCreateWithoutQuestionsInput>
  }

  export type questions_responsesCreateManyQuestionsInputEnvelope = {
    data: questions_responsesCreateManyQuestionsInput | questions_responsesCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type surveysUpsertWithoutQuestionsInput = {
    update: XOR<surveysUpdateWithoutQuestionsInput, surveysUncheckedUpdateWithoutQuestionsInput>
    create: XOR<surveysCreateWithoutQuestionsInput, surveysUncheckedCreateWithoutQuestionsInput>
    where?: surveysWhereInput
  }

  export type surveysUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: surveysWhereInput
    data: XOR<surveysUpdateWithoutQuestionsInput, surveysUncheckedUpdateWithoutQuestionsInput>
  }

  export type surveysUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type surveysUncheckedUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questions_typesUpsertWithoutQuestionsInput = {
    update: XOR<questions_typesUpdateWithoutQuestionsInput, questions_typesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<questions_typesCreateWithoutQuestionsInput, questions_typesUncheckedCreateWithoutQuestionsInput>
    where?: questions_typesWhereInput
  }

  export type questions_typesUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: questions_typesWhereInput
    data: XOR<questions_typesUpdateWithoutQuestionsInput, questions_typesUncheckedUpdateWithoutQuestionsInput>
  }

  export type questions_typesUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type questions_typesUncheckedUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
  }

  export type questions_possible_responsesUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: questions_possible_responsesWhereUniqueInput
    update: XOR<questions_possible_responsesUpdateWithoutQuestionsInput, questions_possible_responsesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<questions_possible_responsesCreateWithoutQuestionsInput, questions_possible_responsesUncheckedCreateWithoutQuestionsInput>
  }

  export type questions_possible_responsesUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: questions_possible_responsesWhereUniqueInput
    data: XOR<questions_possible_responsesUpdateWithoutQuestionsInput, questions_possible_responsesUncheckedUpdateWithoutQuestionsInput>
  }

  export type questions_possible_responsesUpdateManyWithWhereWithoutQuestionsInput = {
    where: questions_possible_responsesScalarWhereInput
    data: XOR<questions_possible_responsesUpdateManyMutationInput, questions_possible_responsesUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type questions_possible_responsesScalarWhereInput = {
    AND?: questions_possible_responsesScalarWhereInput | questions_possible_responsesScalarWhereInput[]
    OR?: questions_possible_responsesScalarWhereInput[]
    NOT?: questions_possible_responsesScalarWhereInput | questions_possible_responsesScalarWhereInput[]
    id?: BytesFilter<"questions_possible_responses"> | Uint8Array
    content?: StringFilter<"questions_possible_responses"> | string
    question_id?: BytesFilter<"questions_possible_responses"> | Uint8Array
  }

  export type questions_responsesUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: questions_responsesWhereUniqueInput
    update: XOR<questions_responsesUpdateWithoutQuestionsInput, questions_responsesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<questions_responsesCreateWithoutQuestionsInput, questions_responsesUncheckedCreateWithoutQuestionsInput>
  }

  export type questions_responsesUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: questions_responsesWhereUniqueInput
    data: XOR<questions_responsesUpdateWithoutQuestionsInput, questions_responsesUncheckedUpdateWithoutQuestionsInput>
  }

  export type questions_responsesUpdateManyWithWhereWithoutQuestionsInput = {
    where: questions_responsesScalarWhereInput
    data: XOR<questions_responsesUpdateManyMutationInput, questions_responsesUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type questionsCreateWithoutQuestions_possible_responsesInput = {
    id?: Uint8Array
    content: string
    surveys: surveysCreateNestedOneWithoutQuestionsInput
    questions_types: questions_typesCreateNestedOneWithoutQuestionsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestions_possible_responsesInput = {
    id?: Uint8Array
    content: string
    survey_id: Uint8Array
    question_type_id: Uint8Array
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutQuestions_possible_responsesInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestions_possible_responsesInput, questionsUncheckedCreateWithoutQuestions_possible_responsesInput>
  }

  export type questionsUpsertWithoutQuestions_possible_responsesInput = {
    update: XOR<questionsUpdateWithoutQuestions_possible_responsesInput, questionsUncheckedUpdateWithoutQuestions_possible_responsesInput>
    create: XOR<questionsCreateWithoutQuestions_possible_responsesInput, questionsUncheckedCreateWithoutQuestions_possible_responsesInput>
    where?: questionsWhereInput
  }

  export type questionsUpdateToOneWithWhereWithoutQuestions_possible_responsesInput = {
    where?: questionsWhereInput
    data: XOR<questionsUpdateWithoutQuestions_possible_responsesInput, questionsUncheckedUpdateWithoutQuestions_possible_responsesInput>
  }

  export type questionsUpdateWithoutQuestions_possible_responsesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    surveys?: surveysUpdateOneRequiredWithoutQuestionsNestedInput
    questions_types?: questions_typesUpdateOneRequiredWithoutQuestionsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestions_possible_responsesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    survey_id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type studentsCreateWithoutQuestions_responsesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutQuestions_responsesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutQuestions_responsesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutQuestions_responsesInput, studentsUncheckedCreateWithoutQuestions_responsesInput>
  }

  export type questionsCreateWithoutQuestions_responsesInput = {
    id?: Uint8Array
    content: string
    surveys: surveysCreateNestedOneWithoutQuestionsInput
    questions_types: questions_typesCreateNestedOneWithoutQuestionsInput
    questions_possible_responses?: questions_possible_responsesCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestions_responsesInput = {
    id?: Uint8Array
    content: string
    survey_id: Uint8Array
    question_type_id: Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutQuestions_responsesInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestions_responsesInput, questionsUncheckedCreateWithoutQuestions_responsesInput>
  }

  export type studentsUpsertWithoutQuestions_responsesInput = {
    update: XOR<studentsUpdateWithoutQuestions_responsesInput, studentsUncheckedUpdateWithoutQuestions_responsesInput>
    create: XOR<studentsCreateWithoutQuestions_responsesInput, studentsUncheckedCreateWithoutQuestions_responsesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutQuestions_responsesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutQuestions_responsesInput, studentsUncheckedUpdateWithoutQuestions_responsesInput>
  }

  export type studentsUpdateWithoutQuestions_responsesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutQuestions_responsesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type questionsUpsertWithoutQuestions_responsesInput = {
    update: XOR<questionsUpdateWithoutQuestions_responsesInput, questionsUncheckedUpdateWithoutQuestions_responsesInput>
    create: XOR<questionsCreateWithoutQuestions_responsesInput, questionsUncheckedCreateWithoutQuestions_responsesInput>
    where?: questionsWhereInput
  }

  export type questionsUpdateToOneWithWhereWithoutQuestions_responsesInput = {
    where?: questionsWhereInput
    data: XOR<questionsUpdateWithoutQuestions_responsesInput, questionsUncheckedUpdateWithoutQuestions_responsesInput>
  }

  export type questionsUpdateWithoutQuestions_responsesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    surveys?: surveysUpdateOneRequiredWithoutQuestionsNestedInput
    questions_types?: questions_typesUpdateOneRequiredWithoutQuestionsNestedInput
    questions_possible_responses?: questions_possible_responsesUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestions_responsesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    survey_id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsCreateWithoutQuestions_typesInput = {
    id?: Uint8Array
    content: string
    surveys: surveysCreateNestedOneWithoutQuestionsInput
    questions_possible_responses?: questions_possible_responsesCreateNestedManyWithoutQuestionsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestions_typesInput = {
    id?: Uint8Array
    content: string
    survey_id: Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedCreateNestedManyWithoutQuestionsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutQuestions_typesInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestions_typesInput, questionsUncheckedCreateWithoutQuestions_typesInput>
  }

  export type questionsCreateManyQuestions_typesInputEnvelope = {
    data: questionsCreateManyQuestions_typesInput | questionsCreateManyQuestions_typesInput[]
    skipDuplicates?: boolean
  }

  export type questionsUpsertWithWhereUniqueWithoutQuestions_typesInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutQuestions_typesInput, questionsUncheckedUpdateWithoutQuestions_typesInput>
    create: XOR<questionsCreateWithoutQuestions_typesInput, questionsUncheckedCreateWithoutQuestions_typesInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutQuestions_typesInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutQuestions_typesInput, questionsUncheckedUpdateWithoutQuestions_typesInput>
  }

  export type questionsUpdateManyWithWhereWithoutQuestions_typesInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutQuestions_typesInput>
  }

  export type attemptsCreateWithoutAttempt_questionsInput = {
    id?: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    students: studentsCreateNestedOneWithoutAttemptsInput
    exams: examsCreateNestedOneWithoutAttemptsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsUncheckedCreateWithoutAttempt_questionsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsCreateOrConnectWithoutAttempt_questionsInput = {
    where: attemptsWhereUniqueInput
    create: XOR<attemptsCreateWithoutAttempt_questionsInput, attemptsUncheckedCreateWithoutAttempt_questionsInput>
  }

  export type open_questionsCreateWithoutAttempt_questionsInput = {
    id?: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    open_answers?: open_answersCreateNestedManyWithoutOpen_questionsInput
    exams: examsCreateNestedOneWithoutOpen_questionsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsUncheckedCreateWithoutAttempt_questionsInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    open_answers?: open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsCreateOrConnectWithoutAttempt_questionsInput = {
    where: open_questionsWhereUniqueInput
    create: XOR<open_questionsCreateWithoutAttempt_questionsInput, open_questionsUncheckedCreateWithoutAttempt_questionsInput>
  }

  export type closed_questionsCreateWithoutAttempt_questionsInput = {
    id?: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    closed_answers?: closed_answersCreateNestedManyWithoutClosed_questionsInput
    exams: examsCreateNestedOneWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsUncheckedCreateWithoutAttempt_questionsInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    closed_answers?: closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsCreateOrConnectWithoutAttempt_questionsInput = {
    where: closed_questionsWhereUniqueInput
    create: XOR<closed_questionsCreateWithoutAttempt_questionsInput, closed_questionsUncheckedCreateWithoutAttempt_questionsInput>
  }

  export type attemptsUpsertWithoutAttempt_questionsInput = {
    update: XOR<attemptsUpdateWithoutAttempt_questionsInput, attemptsUncheckedUpdateWithoutAttempt_questionsInput>
    create: XOR<attemptsCreateWithoutAttempt_questionsInput, attemptsUncheckedCreateWithoutAttempt_questionsInput>
    where?: attemptsWhereInput
  }

  export type attemptsUpdateToOneWithWhereWithoutAttempt_questionsInput = {
    where?: attemptsWhereInput
    data: XOR<attemptsUpdateWithoutAttempt_questionsInput, attemptsUncheckedUpdateWithoutAttempt_questionsInput>
  }

  export type attemptsUpdateWithoutAttempt_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutAttemptsNestedInput
    exams?: examsUpdateOneRequiredWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateWithoutAttempt_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutAttemptsNestedInput
  }

  export type open_questionsUpsertWithoutAttempt_questionsInput = {
    update: XOR<open_questionsUpdateWithoutAttempt_questionsInput, open_questionsUncheckedUpdateWithoutAttempt_questionsInput>
    create: XOR<open_questionsCreateWithoutAttempt_questionsInput, open_questionsUncheckedCreateWithoutAttempt_questionsInput>
    where?: open_questionsWhereInput
  }

  export type open_questionsUpdateToOneWithWhereWithoutAttempt_questionsInput = {
    where?: open_questionsWhereInput
    data: XOR<open_questionsUpdateWithoutAttempt_questionsInput, open_questionsUncheckedUpdateWithoutAttempt_questionsInput>
  }

  export type open_questionsUpdateWithoutAttempt_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    open_answers?: open_answersUpdateManyWithoutOpen_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutOpen_questionsNestedInput
  }

  export type open_questionsUncheckedUpdateWithoutAttempt_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    open_answers?: open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
  }

  export type closed_questionsUpsertWithoutAttempt_questionsInput = {
    update: XOR<closed_questionsUpdateWithoutAttempt_questionsInput, closed_questionsUncheckedUpdateWithoutAttempt_questionsInput>
    create: XOR<closed_questionsCreateWithoutAttempt_questionsInput, closed_questionsUncheckedCreateWithoutAttempt_questionsInput>
    where?: closed_questionsWhereInput
  }

  export type closed_questionsUpdateToOneWithWhereWithoutAttempt_questionsInput = {
    where?: closed_questionsWhereInput
    data: XOR<closed_questionsUpdateWithoutAttempt_questionsInput, closed_questionsUncheckedUpdateWithoutAttempt_questionsInput>
  }

  export type closed_questionsUpdateWithoutAttempt_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    closed_answers?: closed_answersUpdateManyWithoutClosed_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutClosed_questionsNestedInput
  }

  export type closed_questionsUncheckedUpdateWithoutAttempt_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    closed_answers?: closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
  }

  export type attempt_questionsCreateWithoutAttemptsInput = {
    id: Uint8Array
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
    open_questions?: open_questionsCreateNestedOneWithoutAttempt_questionsInput
    closed_questions?: closed_questionsCreateNestedOneWithoutAttempt_questionsInput
  }

  export type attempt_questionsUncheckedCreateWithoutAttemptsInput = {
    id: Uint8Array
    open_question_id?: Uint8Array | null
    closed_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type attempt_questionsCreateOrConnectWithoutAttemptsInput = {
    where: attempt_questionsWhereUniqueInput
    create: XOR<attempt_questionsCreateWithoutAttemptsInput, attempt_questionsUncheckedCreateWithoutAttemptsInput>
  }

  export type attempt_questionsCreateManyAttemptsInputEnvelope = {
    data: attempt_questionsCreateManyAttemptsInput | attempt_questionsCreateManyAttemptsInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutAttemptsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutAttemptsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutAttemptsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutAttemptsInput, studentsUncheckedCreateWithoutAttemptsInput>
  }

  export type examsCreateWithoutAttemptsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutAttemptsInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutAttemptsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutAttemptsInput, examsUncheckedCreateWithoutAttemptsInput>
  }

  export type student_closed_answersCreateWithoutAttemptsInput = {
    id?: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
    students: studentsCreateNestedOneWithoutStudent_closed_answersInput
    closed_questions: closed_questionsCreateNestedOneWithoutStudent_closed_answersInput
    closed_answers: closed_answersCreateNestedOneWithoutStudent_closed_answersInput
  }

  export type student_closed_answersUncheckedCreateWithoutAttemptsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_question_id: Uint8Array
    closed_answer_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_closed_answersCreateOrConnectWithoutAttemptsInput = {
    where: student_closed_answersWhereUniqueInput
    create: XOR<student_closed_answersCreateWithoutAttemptsInput, student_closed_answersUncheckedCreateWithoutAttemptsInput>
  }

  export type student_closed_answersCreateManyAttemptsInputEnvelope = {
    data: student_closed_answersCreateManyAttemptsInput | student_closed_answersCreateManyAttemptsInput[]
    skipDuplicates?: boolean
  }

  export type student_open_answersCreateWithoutAttemptsInput = {
    id?: Uint8Array
    score?: number | null
    date_time?: Date | string | null
    description?: string | null
    open_questions: open_questionsCreateNestedOneWithoutStudent_open_answersInput
    students: studentsCreateNestedOneWithoutStudent_open_answersInput
  }

  export type student_open_answersUncheckedCreateWithoutAttemptsInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    score?: number | null
    student_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type student_open_answersCreateOrConnectWithoutAttemptsInput = {
    where: student_open_answersWhereUniqueInput
    create: XOR<student_open_answersCreateWithoutAttemptsInput, student_open_answersUncheckedCreateWithoutAttemptsInput>
  }

  export type student_open_answersCreateManyAttemptsInputEnvelope = {
    data: student_open_answersCreateManyAttemptsInput | student_open_answersCreateManyAttemptsInput[]
    skipDuplicates?: boolean
  }

  export type attempt_questionsUpsertWithWhereUniqueWithoutAttemptsInput = {
    where: attempt_questionsWhereUniqueInput
    update: XOR<attempt_questionsUpdateWithoutAttemptsInput, attempt_questionsUncheckedUpdateWithoutAttemptsInput>
    create: XOR<attempt_questionsCreateWithoutAttemptsInput, attempt_questionsUncheckedCreateWithoutAttemptsInput>
  }

  export type attempt_questionsUpdateWithWhereUniqueWithoutAttemptsInput = {
    where: attempt_questionsWhereUniqueInput
    data: XOR<attempt_questionsUpdateWithoutAttemptsInput, attempt_questionsUncheckedUpdateWithoutAttemptsInput>
  }

  export type attempt_questionsUpdateManyWithWhereWithoutAttemptsInput = {
    where: attempt_questionsScalarWhereInput
    data: XOR<attempt_questionsUpdateManyMutationInput, attempt_questionsUncheckedUpdateManyWithoutAttemptsInput>
  }

  export type attempt_questionsScalarWhereInput = {
    AND?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
    OR?: attempt_questionsScalarWhereInput[]
    NOT?: attempt_questionsScalarWhereInput | attempt_questionsScalarWhereInput[]
    id?: BytesFilter<"attempt_questions"> | Uint8Array
    attempt_id?: BytesFilter<"attempt_questions"> | Uint8Array
    open_question_id?: BytesNullableFilter<"attempt_questions"> | Uint8Array | null
    closed_question_id?: BytesNullableFilter<"attempt_questions"> | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFilter<"attempt_questions"> | $Enums.attempt_questions_question_type
    created_at?: DateTimeNullableFilter<"attempt_questions"> | Date | string | null
  }

  export type studentsUpsertWithoutAttemptsInput = {
    update: XOR<studentsUpdateWithoutAttemptsInput, studentsUncheckedUpdateWithoutAttemptsInput>
    create: XOR<studentsCreateWithoutAttemptsInput, studentsUncheckedCreateWithoutAttemptsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutAttemptsInput, studentsUncheckedUpdateWithoutAttemptsInput>
  }

  export type studentsUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type examsUpsertWithoutAttemptsInput = {
    update: XOR<examsUpdateWithoutAttemptsInput, examsUncheckedUpdateWithoutAttemptsInput>
    create: XOR<examsCreateWithoutAttemptsInput, examsUncheckedCreateWithoutAttemptsInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutAttemptsInput, examsUncheckedUpdateWithoutAttemptsInput>
  }

  export type examsUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type student_closed_answersUpsertWithWhereUniqueWithoutAttemptsInput = {
    where: student_closed_answersWhereUniqueInput
    update: XOR<student_closed_answersUpdateWithoutAttemptsInput, student_closed_answersUncheckedUpdateWithoutAttemptsInput>
    create: XOR<student_closed_answersCreateWithoutAttemptsInput, student_closed_answersUncheckedCreateWithoutAttemptsInput>
  }

  export type student_closed_answersUpdateWithWhereUniqueWithoutAttemptsInput = {
    where: student_closed_answersWhereUniqueInput
    data: XOR<student_closed_answersUpdateWithoutAttemptsInput, student_closed_answersUncheckedUpdateWithoutAttemptsInput>
  }

  export type student_closed_answersUpdateManyWithWhereWithoutAttemptsInput = {
    where: student_closed_answersScalarWhereInput
    data: XOR<student_closed_answersUpdateManyMutationInput, student_closed_answersUncheckedUpdateManyWithoutAttemptsInput>
  }

  export type student_open_answersUpsertWithWhereUniqueWithoutAttemptsInput = {
    where: student_open_answersWhereUniqueInput
    update: XOR<student_open_answersUpdateWithoutAttemptsInput, student_open_answersUncheckedUpdateWithoutAttemptsInput>
    create: XOR<student_open_answersCreateWithoutAttemptsInput, student_open_answersUncheckedCreateWithoutAttemptsInput>
  }

  export type student_open_answersUpdateWithWhereUniqueWithoutAttemptsInput = {
    where: student_open_answersWhereUniqueInput
    data: XOR<student_open_answersUpdateWithoutAttemptsInput, student_open_answersUncheckedUpdateWithoutAttemptsInput>
  }

  export type student_open_answersUpdateManyWithWhereWithoutAttemptsInput = {
    where: student_open_answersScalarWhereInput
    data: XOR<student_open_answersUpdateManyMutationInput, student_open_answersUncheckedUpdateManyWithoutAttemptsInput>
  }

  export type classesCreateWithoutClasses_examsInput = {
    id?: Uint8Array
    class_names: class_namesCreateNestedOneWithoutClassesInput
    school_years: school_yearsCreateNestedOneWithoutClassesInput
    teachers?: teachersCreateNestedOneWithoutClassesInput
    lessons?: lessonsCreateNestedManyWithoutClassesInput
    students?: studentsCreateNestedManyWithoutClassesInput
  }

  export type classesUncheckedCreateWithoutClasses_examsInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
    teacher_id?: Uint8Array | null
    lessons?: lessonsUncheckedCreateNestedManyWithoutClassesInput
    students?: studentsUncheckedCreateNestedManyWithoutClassesInput
  }

  export type classesCreateOrConnectWithoutClasses_examsInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutClasses_examsInput, classesUncheckedCreateWithoutClasses_examsInput>
  }

  export type examsCreateWithoutClasses_examsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutClasses_examsInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutClasses_examsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutClasses_examsInput, examsUncheckedCreateWithoutClasses_examsInput>
  }

  export type classesUpsertWithoutClasses_examsInput = {
    update: XOR<classesUpdateWithoutClasses_examsInput, classesUncheckedUpdateWithoutClasses_examsInput>
    create: XOR<classesCreateWithoutClasses_examsInput, classesUncheckedCreateWithoutClasses_examsInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutClasses_examsInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutClasses_examsInput, classesUncheckedUpdateWithoutClasses_examsInput>
  }

  export type classesUpdateWithoutClasses_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_names?: class_namesUpdateOneRequiredWithoutClassesNestedInput
    school_years?: school_yearsUpdateOneRequiredWithoutClassesNestedInput
    teachers?: teachersUpdateOneWithoutClassesNestedInput
    lessons?: lessonsUpdateManyWithoutClassesNestedInput
    students?: studentsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutClasses_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    lessons?: lessonsUncheckedUpdateManyWithoutClassesNestedInput
    students?: studentsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type examsUpsertWithoutClasses_examsInput = {
    update: XOR<examsUpdateWithoutClasses_examsInput, examsUncheckedUpdateWithoutClasses_examsInput>
    create: XOR<examsCreateWithoutClasses_examsInput, examsUncheckedCreateWithoutClasses_examsInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutClasses_examsInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutClasses_examsInput, examsUncheckedUpdateWithoutClasses_examsInput>
  }

  export type examsUpdateWithoutClasses_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutClasses_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type closed_questionsCreateWithoutClosed_answersInput = {
    id?: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsCreateNestedManyWithoutClosed_questionsInput
    exams: examsCreateNestedOneWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsUncheckedCreateWithoutClosed_answersInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutClosed_questionsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsCreateOrConnectWithoutClosed_answersInput = {
    where: closed_questionsWhereUniqueInput
    create: XOR<closed_questionsCreateWithoutClosed_answersInput, closed_questionsUncheckedCreateWithoutClosed_answersInput>
  }

  export type student_closed_answersCreateWithoutClosed_answersInput = {
    id?: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
    students: studentsCreateNestedOneWithoutStudent_closed_answersInput
    closed_questions: closed_questionsCreateNestedOneWithoutStudent_closed_answersInput
    attempts: attemptsCreateNestedOneWithoutStudent_closed_answersInput
  }

  export type student_closed_answersUncheckedCreateWithoutClosed_answersInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_question_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_closed_answersCreateOrConnectWithoutClosed_answersInput = {
    where: student_closed_answersWhereUniqueInput
    create: XOR<student_closed_answersCreateWithoutClosed_answersInput, student_closed_answersUncheckedCreateWithoutClosed_answersInput>
  }

  export type student_closed_answersCreateManyClosed_answersInputEnvelope = {
    data: student_closed_answersCreateManyClosed_answersInput | student_closed_answersCreateManyClosed_answersInput[]
    skipDuplicates?: boolean
  }

  export type closed_questionsUpsertWithoutClosed_answersInput = {
    update: XOR<closed_questionsUpdateWithoutClosed_answersInput, closed_questionsUncheckedUpdateWithoutClosed_answersInput>
    create: XOR<closed_questionsCreateWithoutClosed_answersInput, closed_questionsUncheckedCreateWithoutClosed_answersInput>
    where?: closed_questionsWhereInput
  }

  export type closed_questionsUpdateToOneWithWhereWithoutClosed_answersInput = {
    where?: closed_questionsWhereInput
    data: XOR<closed_questionsUpdateWithoutClosed_answersInput, closed_questionsUncheckedUpdateWithoutClosed_answersInput>
  }

  export type closed_questionsUpdateWithoutClosed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUpdateManyWithoutClosed_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutClosed_questionsNestedInput
  }

  export type closed_questionsUncheckedUpdateWithoutClosed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
  }

  export type student_closed_answersUpsertWithWhereUniqueWithoutClosed_answersInput = {
    where: student_closed_answersWhereUniqueInput
    update: XOR<student_closed_answersUpdateWithoutClosed_answersInput, student_closed_answersUncheckedUpdateWithoutClosed_answersInput>
    create: XOR<student_closed_answersCreateWithoutClosed_answersInput, student_closed_answersUncheckedCreateWithoutClosed_answersInput>
  }

  export type student_closed_answersUpdateWithWhereUniqueWithoutClosed_answersInput = {
    where: student_closed_answersWhereUniqueInput
    data: XOR<student_closed_answersUpdateWithoutClosed_answersInput, student_closed_answersUncheckedUpdateWithoutClosed_answersInput>
  }

  export type student_closed_answersUpdateManyWithWhereWithoutClosed_answersInput = {
    where: student_closed_answersScalarWhereInput
    data: XOR<student_closed_answersUpdateManyMutationInput, student_closed_answersUncheckedUpdateManyWithoutClosed_answersInput>
  }

  export type attempt_questionsCreateWithoutClosed_questionsInput = {
    id: Uint8Array
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
    attempts: attemptsCreateNestedOneWithoutAttempt_questionsInput
    open_questions?: open_questionsCreateNestedOneWithoutAttempt_questionsInput
  }

  export type attempt_questionsUncheckedCreateWithoutClosed_questionsInput = {
    id: Uint8Array
    attempt_id: Uint8Array
    open_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type attempt_questionsCreateOrConnectWithoutClosed_questionsInput = {
    where: attempt_questionsWhereUniqueInput
    create: XOR<attempt_questionsCreateWithoutClosed_questionsInput, attempt_questionsUncheckedCreateWithoutClosed_questionsInput>
  }

  export type attempt_questionsCreateManyClosed_questionsInputEnvelope = {
    data: attempt_questionsCreateManyClosed_questionsInput | attempt_questionsCreateManyClosed_questionsInput[]
    skipDuplicates?: boolean
  }

  export type closed_answersCreateWithoutClosed_questionsInput = {
    id?: Uint8Array
    is_correct?: boolean | null
    description: string
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutClosed_answersInput
  }

  export type closed_answersUncheckedCreateWithoutClosed_questionsInput = {
    id?: Uint8Array
    is_correct?: boolean | null
    description: string
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutClosed_answersInput
  }

  export type closed_answersCreateOrConnectWithoutClosed_questionsInput = {
    where: closed_answersWhereUniqueInput
    create: XOR<closed_answersCreateWithoutClosed_questionsInput, closed_answersUncheckedCreateWithoutClosed_questionsInput>
  }

  export type closed_answersCreateManyClosed_questionsInputEnvelope = {
    data: closed_answersCreateManyClosed_questionsInput | closed_answersCreateManyClosed_questionsInput[]
    skipDuplicates?: boolean
  }

  export type examsCreateWithoutClosed_questionsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutClosed_questionsInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutClosed_questionsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutClosed_questionsInput, examsUncheckedCreateWithoutClosed_questionsInput>
  }

  export type student_closed_answersCreateWithoutClosed_questionsInput = {
    id?: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
    students: studentsCreateNestedOneWithoutStudent_closed_answersInput
    closed_answers: closed_answersCreateNestedOneWithoutStudent_closed_answersInput
    attempts: attemptsCreateNestedOneWithoutStudent_closed_answersInput
  }

  export type student_closed_answersUncheckedCreateWithoutClosed_questionsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_answer_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_closed_answersCreateOrConnectWithoutClosed_questionsInput = {
    where: student_closed_answersWhereUniqueInput
    create: XOR<student_closed_answersCreateWithoutClosed_questionsInput, student_closed_answersUncheckedCreateWithoutClosed_questionsInput>
  }

  export type student_closed_answersCreateManyClosed_questionsInputEnvelope = {
    data: student_closed_answersCreateManyClosed_questionsInput | student_closed_answersCreateManyClosed_questionsInput[]
    skipDuplicates?: boolean
  }

  export type attempt_questionsUpsertWithWhereUniqueWithoutClosed_questionsInput = {
    where: attempt_questionsWhereUniqueInput
    update: XOR<attempt_questionsUpdateWithoutClosed_questionsInput, attempt_questionsUncheckedUpdateWithoutClosed_questionsInput>
    create: XOR<attempt_questionsCreateWithoutClosed_questionsInput, attempt_questionsUncheckedCreateWithoutClosed_questionsInput>
  }

  export type attempt_questionsUpdateWithWhereUniqueWithoutClosed_questionsInput = {
    where: attempt_questionsWhereUniqueInput
    data: XOR<attempt_questionsUpdateWithoutClosed_questionsInput, attempt_questionsUncheckedUpdateWithoutClosed_questionsInput>
  }

  export type attempt_questionsUpdateManyWithWhereWithoutClosed_questionsInput = {
    where: attempt_questionsScalarWhereInput
    data: XOR<attempt_questionsUpdateManyMutationInput, attempt_questionsUncheckedUpdateManyWithoutClosed_questionsInput>
  }

  export type closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput = {
    where: closed_answersWhereUniqueInput
    update: XOR<closed_answersUpdateWithoutClosed_questionsInput, closed_answersUncheckedUpdateWithoutClosed_questionsInput>
    create: XOR<closed_answersCreateWithoutClosed_questionsInput, closed_answersUncheckedCreateWithoutClosed_questionsInput>
  }

  export type closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput = {
    where: closed_answersWhereUniqueInput
    data: XOR<closed_answersUpdateWithoutClosed_questionsInput, closed_answersUncheckedUpdateWithoutClosed_questionsInput>
  }

  export type closed_answersUpdateManyWithWhereWithoutClosed_questionsInput = {
    where: closed_answersScalarWhereInput
    data: XOR<closed_answersUpdateManyMutationInput, closed_answersUncheckedUpdateManyWithoutClosed_questionsInput>
  }

  export type closed_answersScalarWhereInput = {
    AND?: closed_answersScalarWhereInput | closed_answersScalarWhereInput[]
    OR?: closed_answersScalarWhereInput[]
    NOT?: closed_answersScalarWhereInput | closed_answersScalarWhereInput[]
    id?: BytesFilter<"closed_answers"> | Uint8Array
    closed_question_id?: BytesFilter<"closed_answers"> | Uint8Array
    is_correct?: BoolNullableFilter<"closed_answers"> | boolean | null
    description?: StringFilter<"closed_answers"> | string
  }

  export type examsUpsertWithoutClosed_questionsInput = {
    update: XOR<examsUpdateWithoutClosed_questionsInput, examsUncheckedUpdateWithoutClosed_questionsInput>
    create: XOR<examsCreateWithoutClosed_questionsInput, examsUncheckedCreateWithoutClosed_questionsInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutClosed_questionsInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutClosed_questionsInput, examsUncheckedUpdateWithoutClosed_questionsInput>
  }

  export type examsUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type student_closed_answersUpsertWithWhereUniqueWithoutClosed_questionsInput = {
    where: student_closed_answersWhereUniqueInput
    update: XOR<student_closed_answersUpdateWithoutClosed_questionsInput, student_closed_answersUncheckedUpdateWithoutClosed_questionsInput>
    create: XOR<student_closed_answersCreateWithoutClosed_questionsInput, student_closed_answersUncheckedCreateWithoutClosed_questionsInput>
  }

  export type student_closed_answersUpdateWithWhereUniqueWithoutClosed_questionsInput = {
    where: student_closed_answersWhereUniqueInput
    data: XOR<student_closed_answersUpdateWithoutClosed_questionsInput, student_closed_answersUncheckedUpdateWithoutClosed_questionsInput>
  }

  export type student_closed_answersUpdateManyWithWhereWithoutClosed_questionsInput = {
    where: student_closed_answersScalarWhereInput
    data: XOR<student_closed_answersUpdateManyMutationInput, student_closed_answersUncheckedUpdateManyWithoutClosed_questionsInput>
  }

  export type examsCreateWithoutFiles_repositoryInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutFiles_repositoryInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutFiles_repositoryInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutFiles_repositoryInput, examsUncheckedCreateWithoutFiles_repositoryInput>
  }

  export type examsUpsertWithoutFiles_repositoryInput = {
    update: XOR<examsUpdateWithoutFiles_repositoryInput, examsUncheckedUpdateWithoutFiles_repositoryInput>
    create: XOR<examsCreateWithoutFiles_repositoryInput, examsUncheckedCreateWithoutFiles_repositoryInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutFiles_repositoryInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutFiles_repositoryInput, examsUncheckedUpdateWithoutFiles_repositoryInput>
  }

  export type examsUpdateWithoutFiles_repositoryInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutFiles_repositoryInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type lessonsCreateWithoutGradebook_examsInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    attendances?: attendancesCreateNestedManyWithoutLessonsInput
    exams?: examsCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksCreateNestedOneWithoutLessonsInput
    teachers: teachersCreateNestedOneWithoutLessonsInput
    classes: classesCreateNestedOneWithoutLessonsInput
    subjects: subjectsCreateNestedOneWithoutLessonsInput
  }

  export type lessonsUncheckedCreateWithoutGradebook_examsInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
    subject_id: Uint8Array
    attendances?: attendancesUncheckedCreateNestedManyWithoutLessonsInput
    exams?: examsUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: homeworksUncheckedCreateNestedOneWithoutLessonsInput
  }

  export type lessonsCreateOrConnectWithoutGradebook_examsInput = {
    where: lessonsWhereUniqueInput
    create: XOR<lessonsCreateWithoutGradebook_examsInput, lessonsUncheckedCreateWithoutGradebook_examsInput>
  }

  export type lessonsUpsertWithoutGradebook_examsInput = {
    update: XOR<lessonsUpdateWithoutGradebook_examsInput, lessonsUncheckedUpdateWithoutGradebook_examsInput>
    create: XOR<lessonsCreateWithoutGradebook_examsInput, lessonsUncheckedCreateWithoutGradebook_examsInput>
    where?: lessonsWhereInput
  }

  export type lessonsUpdateToOneWithWhereWithoutGradebook_examsInput = {
    where?: lessonsWhereInput
    data: XOR<lessonsUpdateWithoutGradebook_examsInput, lessonsUncheckedUpdateWithoutGradebook_examsInput>
  }

  export type lessonsUpdateWithoutGradebook_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: attendancesUpdateManyWithoutLessonsNestedInput
    exams?: examsUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUpdateOneWithoutLessonsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLessonsNestedInput
    classes?: classesUpdateOneRequiredWithoutLessonsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateWithoutGradebook_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attendances?: attendancesUncheckedUpdateManyWithoutLessonsNestedInput
    exams?: examsUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUncheckedUpdateOneWithoutLessonsNestedInput
  }

  export type studentsCreateWithoutGrades_examsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutGrades_examsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutGrades_examsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutGrades_examsInput, studentsUncheckedCreateWithoutGrades_examsInput>
  }

  export type examsCreateWithoutGrades_examsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutGrades_examsInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutGrades_examsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutGrades_examsInput, examsUncheckedCreateWithoutGrades_examsInput>
  }

  export type studentsUpsertWithoutGrades_examsInput = {
    update: XOR<studentsUpdateWithoutGrades_examsInput, studentsUncheckedUpdateWithoutGrades_examsInput>
    create: XOR<studentsCreateWithoutGrades_examsInput, studentsUncheckedCreateWithoutGrades_examsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutGrades_examsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutGrades_examsInput, studentsUncheckedUpdateWithoutGrades_examsInput>
  }

  export type studentsUpdateWithoutGrades_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutGrades_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type examsUpsertWithoutGrades_examsInput = {
    update: XOR<examsUpdateWithoutGrades_examsInput, examsUncheckedUpdateWithoutGrades_examsInput>
    create: XOR<examsCreateWithoutGrades_examsInput, examsUncheckedCreateWithoutGrades_examsInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutGrades_examsInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutGrades_examsInput, examsUncheckedUpdateWithoutGrades_examsInput>
  }

  export type examsUpdateWithoutGrades_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutGrades_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type studentsCreateWithoutNotificationsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutNotificationsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutNotificationsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutNotificationsInput, studentsUncheckedCreateWithoutNotificationsInput>
  }

  export type examsCreateWithoutNotificationsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutNotificationsInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutNotificationsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutNotificationsInput, examsUncheckedCreateWithoutNotificationsInput>
  }

  export type studentsUpsertWithoutNotificationsInput = {
    update: XOR<studentsUpdateWithoutNotificationsInput, studentsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<studentsCreateWithoutNotificationsInput, studentsUncheckedCreateWithoutNotificationsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutNotificationsInput, studentsUncheckedUpdateWithoutNotificationsInput>
  }

  export type studentsUpdateWithoutNotificationsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutNotificationsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type examsUpsertWithoutNotificationsInput = {
    update: XOR<examsUpdateWithoutNotificationsInput, examsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<examsCreateWithoutNotificationsInput, examsUncheckedCreateWithoutNotificationsInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutNotificationsInput, examsUncheckedUpdateWithoutNotificationsInput>
  }

  export type examsUpdateWithoutNotificationsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutNotificationsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type open_questionsCreateWithoutOpen_answersInput = {
    id?: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsCreateNestedManyWithoutOpen_questionsInput
    exams: examsCreateNestedOneWithoutOpen_questionsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsUncheckedCreateWithoutOpen_answersInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutOpen_questionsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsCreateOrConnectWithoutOpen_answersInput = {
    where: open_questionsWhereUniqueInput
    create: XOR<open_questionsCreateWithoutOpen_answersInput, open_questionsUncheckedCreateWithoutOpen_answersInput>
  }

  export type open_questionsUpsertWithoutOpen_answersInput = {
    update: XOR<open_questionsUpdateWithoutOpen_answersInput, open_questionsUncheckedUpdateWithoutOpen_answersInput>
    create: XOR<open_questionsCreateWithoutOpen_answersInput, open_questionsUncheckedCreateWithoutOpen_answersInput>
    where?: open_questionsWhereInput
  }

  export type open_questionsUpdateToOneWithWhereWithoutOpen_answersInput = {
    where?: open_questionsWhereInput
    data: XOR<open_questionsUpdateWithoutOpen_answersInput, open_questionsUncheckedUpdateWithoutOpen_answersInput>
  }

  export type open_questionsUpdateWithoutOpen_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUpdateManyWithoutOpen_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutOpen_questionsNestedInput
  }

  export type open_questionsUncheckedUpdateWithoutOpen_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
  }

  export type attempt_questionsCreateWithoutOpen_questionsInput = {
    id: Uint8Array
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
    attempts: attemptsCreateNestedOneWithoutAttempt_questionsInput
    closed_questions?: closed_questionsCreateNestedOneWithoutAttempt_questionsInput
  }

  export type attempt_questionsUncheckedCreateWithoutOpen_questionsInput = {
    id: Uint8Array
    attempt_id: Uint8Array
    closed_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type attempt_questionsCreateOrConnectWithoutOpen_questionsInput = {
    where: attempt_questionsWhereUniqueInput
    create: XOR<attempt_questionsCreateWithoutOpen_questionsInput, attempt_questionsUncheckedCreateWithoutOpen_questionsInput>
  }

  export type attempt_questionsCreateManyOpen_questionsInputEnvelope = {
    data: attempt_questionsCreateManyOpen_questionsInput | attempt_questionsCreateManyOpen_questionsInput[]
    skipDuplicates?: boolean
  }

  export type open_answersCreateWithoutOpen_questionsInput = {
    id?: Uint8Array
    description: string
  }

  export type open_answersUncheckedCreateWithoutOpen_questionsInput = {
    id?: Uint8Array
    description: string
  }

  export type open_answersCreateOrConnectWithoutOpen_questionsInput = {
    where: open_answersWhereUniqueInput
    create: XOR<open_answersCreateWithoutOpen_questionsInput, open_answersUncheckedCreateWithoutOpen_questionsInput>
  }

  export type open_answersCreateManyOpen_questionsInputEnvelope = {
    data: open_answersCreateManyOpen_questionsInput | open_answersCreateManyOpen_questionsInput[]
    skipDuplicates?: boolean
  }

  export type examsCreateWithoutOpen_questionsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    students_exams?: students_examsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutOpen_questionsInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutOpen_questionsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutOpen_questionsInput, examsUncheckedCreateWithoutOpen_questionsInput>
  }

  export type student_open_answersCreateWithoutOpen_questionsInput = {
    id?: Uint8Array
    score?: number | null
    date_time?: Date | string | null
    description?: string | null
    students: studentsCreateNestedOneWithoutStudent_open_answersInput
    attempts: attemptsCreateNestedOneWithoutStudent_open_answersInput
  }

  export type student_open_answersUncheckedCreateWithoutOpen_questionsInput = {
    id?: Uint8Array
    score?: number | null
    student_id: Uint8Array
    attempt_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type student_open_answersCreateOrConnectWithoutOpen_questionsInput = {
    where: student_open_answersWhereUniqueInput
    create: XOR<student_open_answersCreateWithoutOpen_questionsInput, student_open_answersUncheckedCreateWithoutOpen_questionsInput>
  }

  export type student_open_answersCreateManyOpen_questionsInputEnvelope = {
    data: student_open_answersCreateManyOpen_questionsInput | student_open_answersCreateManyOpen_questionsInput[]
    skipDuplicates?: boolean
  }

  export type attempt_questionsUpsertWithWhereUniqueWithoutOpen_questionsInput = {
    where: attempt_questionsWhereUniqueInput
    update: XOR<attempt_questionsUpdateWithoutOpen_questionsInput, attempt_questionsUncheckedUpdateWithoutOpen_questionsInput>
    create: XOR<attempt_questionsCreateWithoutOpen_questionsInput, attempt_questionsUncheckedCreateWithoutOpen_questionsInput>
  }

  export type attempt_questionsUpdateWithWhereUniqueWithoutOpen_questionsInput = {
    where: attempt_questionsWhereUniqueInput
    data: XOR<attempt_questionsUpdateWithoutOpen_questionsInput, attempt_questionsUncheckedUpdateWithoutOpen_questionsInput>
  }

  export type attempt_questionsUpdateManyWithWhereWithoutOpen_questionsInput = {
    where: attempt_questionsScalarWhereInput
    data: XOR<attempt_questionsUpdateManyMutationInput, attempt_questionsUncheckedUpdateManyWithoutOpen_questionsInput>
  }

  export type open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput = {
    where: open_answersWhereUniqueInput
    update: XOR<open_answersUpdateWithoutOpen_questionsInput, open_answersUncheckedUpdateWithoutOpen_questionsInput>
    create: XOR<open_answersCreateWithoutOpen_questionsInput, open_answersUncheckedCreateWithoutOpen_questionsInput>
  }

  export type open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput = {
    where: open_answersWhereUniqueInput
    data: XOR<open_answersUpdateWithoutOpen_questionsInput, open_answersUncheckedUpdateWithoutOpen_questionsInput>
  }

  export type open_answersUpdateManyWithWhereWithoutOpen_questionsInput = {
    where: open_answersScalarWhereInput
    data: XOR<open_answersUpdateManyMutationInput, open_answersUncheckedUpdateManyWithoutOpen_questionsInput>
  }

  export type open_answersScalarWhereInput = {
    AND?: open_answersScalarWhereInput | open_answersScalarWhereInput[]
    OR?: open_answersScalarWhereInput[]
    NOT?: open_answersScalarWhereInput | open_answersScalarWhereInput[]
    id?: BytesFilter<"open_answers"> | Uint8Array
    open_question_id?: BytesFilter<"open_answers"> | Uint8Array
    description?: StringFilter<"open_answers"> | string
  }

  export type examsUpsertWithoutOpen_questionsInput = {
    update: XOR<examsUpdateWithoutOpen_questionsInput, examsUncheckedUpdateWithoutOpen_questionsInput>
    create: XOR<examsCreateWithoutOpen_questionsInput, examsUncheckedCreateWithoutOpen_questionsInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutOpen_questionsInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutOpen_questionsInput, examsUncheckedUpdateWithoutOpen_questionsInput>
  }

  export type examsUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type student_open_answersUpsertWithWhereUniqueWithoutOpen_questionsInput = {
    where: student_open_answersWhereUniqueInput
    update: XOR<student_open_answersUpdateWithoutOpen_questionsInput, student_open_answersUncheckedUpdateWithoutOpen_questionsInput>
    create: XOR<student_open_answersCreateWithoutOpen_questionsInput, student_open_answersUncheckedCreateWithoutOpen_questionsInput>
  }

  export type student_open_answersUpdateWithWhereUniqueWithoutOpen_questionsInput = {
    where: student_open_answersWhereUniqueInput
    data: XOR<student_open_answersUpdateWithoutOpen_questionsInput, student_open_answersUncheckedUpdateWithoutOpen_questionsInput>
  }

  export type student_open_answersUpdateManyWithWhereWithoutOpen_questionsInput = {
    where: student_open_answersScalarWhereInput
    data: XOR<student_open_answersUpdateManyMutationInput, student_open_answersUncheckedUpdateManyWithoutOpen_questionsInput>
  }

  export type studentsCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudent_closed_answersInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudent_closed_answersInput, studentsUncheckedCreateWithoutStudent_closed_answersInput>
  }

  export type closed_questionsCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsCreateNestedManyWithoutClosed_questionsInput
    closed_answers?: closed_answersCreateNestedManyWithoutClosed_questionsInput
    exams: examsCreateNestedOneWithoutClosed_questionsInput
  }

  export type closed_questionsUncheckedCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutClosed_questionsInput
    closed_answers?: closed_answersUncheckedCreateNestedManyWithoutClosed_questionsInput
  }

  export type closed_questionsCreateOrConnectWithoutStudent_closed_answersInput = {
    where: closed_questionsWhereUniqueInput
    create: XOR<closed_questionsCreateWithoutStudent_closed_answersInput, closed_questionsUncheckedCreateWithoutStudent_closed_answersInput>
  }

  export type closed_answersCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    is_correct?: boolean | null
    description: string
    closed_questions: closed_questionsCreateNestedOneWithoutClosed_answersInput
  }

  export type closed_answersUncheckedCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    closed_question_id: Uint8Array
    is_correct?: boolean | null
    description: string
  }

  export type closed_answersCreateOrConnectWithoutStudent_closed_answersInput = {
    where: closed_answersWhereUniqueInput
    create: XOR<closed_answersCreateWithoutStudent_closed_answersInput, closed_answersUncheckedCreateWithoutStudent_closed_answersInput>
  }

  export type attemptsCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsCreateNestedManyWithoutAttemptsInput
    students: studentsCreateNestedOneWithoutAttemptsInput
    exams: examsCreateNestedOneWithoutAttemptsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsUncheckedCreateWithoutStudent_closed_answersInput = {
    id?: Uint8Array
    student_id: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutAttemptsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsCreateOrConnectWithoutStudent_closed_answersInput = {
    where: attemptsWhereUniqueInput
    create: XOR<attemptsCreateWithoutStudent_closed_answersInput, attemptsUncheckedCreateWithoutStudent_closed_answersInput>
  }

  export type studentsUpsertWithoutStudent_closed_answersInput = {
    update: XOR<studentsUpdateWithoutStudent_closed_answersInput, studentsUncheckedUpdateWithoutStudent_closed_answersInput>
    create: XOR<studentsCreateWithoutStudent_closed_answersInput, studentsUncheckedCreateWithoutStudent_closed_answersInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudent_closed_answersInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudent_closed_answersInput, studentsUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type studentsUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type closed_questionsUpsertWithoutStudent_closed_answersInput = {
    update: XOR<closed_questionsUpdateWithoutStudent_closed_answersInput, closed_questionsUncheckedUpdateWithoutStudent_closed_answersInput>
    create: XOR<closed_questionsCreateWithoutStudent_closed_answersInput, closed_questionsUncheckedCreateWithoutStudent_closed_answersInput>
    where?: closed_questionsWhereInput
  }

  export type closed_questionsUpdateToOneWithWhereWithoutStudent_closed_answersInput = {
    where?: closed_questionsWhereInput
    data: XOR<closed_questionsUpdateWithoutStudent_closed_answersInput, closed_questionsUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type closed_questionsUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUpdateManyWithoutClosed_questionsNestedInput
    closed_answers?: closed_answersUpdateManyWithoutClosed_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutClosed_questionsNestedInput
  }

  export type closed_questionsUncheckedUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutClosed_questionsNestedInput
    closed_answers?: closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
  }

  export type closed_answersUpsertWithoutStudent_closed_answersInput = {
    update: XOR<closed_answersUpdateWithoutStudent_closed_answersInput, closed_answersUncheckedUpdateWithoutStudent_closed_answersInput>
    create: XOR<closed_answersCreateWithoutStudent_closed_answersInput, closed_answersUncheckedCreateWithoutStudent_closed_answersInput>
    where?: closed_answersWhereInput
  }

  export type closed_answersUpdateToOneWithWhereWithoutStudent_closed_answersInput = {
    where?: closed_answersWhereInput
    data: XOR<closed_answersUpdateWithoutStudent_closed_answersInput, closed_answersUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type closed_answersUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    closed_questions?: closed_questionsUpdateOneRequiredWithoutClosed_answersNestedInput
  }

  export type closed_answersUncheckedUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type attemptsUpsertWithoutStudent_closed_answersInput = {
    update: XOR<attemptsUpdateWithoutStudent_closed_answersInput, attemptsUncheckedUpdateWithoutStudent_closed_answersInput>
    create: XOR<attemptsCreateWithoutStudent_closed_answersInput, attemptsUncheckedCreateWithoutStudent_closed_answersInput>
    where?: attemptsWhereInput
  }

  export type attemptsUpdateToOneWithWhereWithoutStudent_closed_answersInput = {
    where?: attemptsWhereInput
    data: XOR<attemptsUpdateWithoutStudent_closed_answersInput, attemptsUncheckedUpdateWithoutStudent_closed_answersInput>
  }

  export type attemptsUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUpdateManyWithoutAttemptsNestedInput
    students?: studentsUpdateOneRequiredWithoutAttemptsNestedInput
    exams?: examsUpdateOneRequiredWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateWithoutStudent_closed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutAttemptsNestedInput
  }

  export type open_questionsCreateWithoutStudent_open_answersInput = {
    id?: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsCreateNestedManyWithoutOpen_questionsInput
    open_answers?: open_answersCreateNestedManyWithoutOpen_questionsInput
    exams: examsCreateNestedOneWithoutOpen_questionsInput
  }

  export type open_questionsUncheckedCreateWithoutStudent_open_answersInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutOpen_questionsInput
    open_answers?: open_answersUncheckedCreateNestedManyWithoutOpen_questionsInput
  }

  export type open_questionsCreateOrConnectWithoutStudent_open_answersInput = {
    where: open_questionsWhereUniqueInput
    create: XOR<open_questionsCreateWithoutStudent_open_answersInput, open_questionsUncheckedCreateWithoutStudent_open_answersInput>
  }

  export type studentsCreateWithoutStudent_open_answersInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_exams?: students_examsCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudent_open_answersInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_exams?: students_examsUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudent_open_answersInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudent_open_answersInput, studentsUncheckedCreateWithoutStudent_open_answersInput>
  }

  export type attemptsCreateWithoutStudent_open_answersInput = {
    id?: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsCreateNestedManyWithoutAttemptsInput
    students: studentsCreateNestedOneWithoutAttemptsInput
    exams: examsCreateNestedOneWithoutAttemptsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsUncheckedCreateWithoutStudent_open_answersInput = {
    id?: Uint8Array
    student_id: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
    attempt_questions?: attempt_questionsUncheckedCreateNestedManyWithoutAttemptsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutAttemptsInput
  }

  export type attemptsCreateOrConnectWithoutStudent_open_answersInput = {
    where: attemptsWhereUniqueInput
    create: XOR<attemptsCreateWithoutStudent_open_answersInput, attemptsUncheckedCreateWithoutStudent_open_answersInput>
  }

  export type open_questionsUpsertWithoutStudent_open_answersInput = {
    update: XOR<open_questionsUpdateWithoutStudent_open_answersInput, open_questionsUncheckedUpdateWithoutStudent_open_answersInput>
    create: XOR<open_questionsCreateWithoutStudent_open_answersInput, open_questionsUncheckedCreateWithoutStudent_open_answersInput>
    where?: open_questionsWhereInput
  }

  export type open_questionsUpdateToOneWithWhereWithoutStudent_open_answersInput = {
    where?: open_questionsWhereInput
    data: XOR<open_questionsUpdateWithoutStudent_open_answersInput, open_questionsUncheckedUpdateWithoutStudent_open_answersInput>
  }

  export type open_questionsUpdateWithoutStudent_open_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUpdateManyWithoutOpen_questionsNestedInput
    open_answers?: open_answersUpdateManyWithoutOpen_questionsNestedInput
    exams?: examsUpdateOneRequiredWithoutOpen_questionsNestedInput
  }

  export type open_questionsUncheckedUpdateWithoutStudent_open_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutOpen_questionsNestedInput
    open_answers?: open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
  }

  export type studentsUpsertWithoutStudent_open_answersInput = {
    update: XOR<studentsUpdateWithoutStudent_open_answersInput, studentsUncheckedUpdateWithoutStudent_open_answersInput>
    create: XOR<studentsCreateWithoutStudent_open_answersInput, studentsUncheckedCreateWithoutStudent_open_answersInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudent_open_answersInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudent_open_answersInput, studentsUncheckedUpdateWithoutStudent_open_answersInput>
  }

  export type studentsUpdateWithoutStudent_open_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudent_open_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type attemptsUpsertWithoutStudent_open_answersInput = {
    update: XOR<attemptsUpdateWithoutStudent_open_answersInput, attemptsUncheckedUpdateWithoutStudent_open_answersInput>
    create: XOR<attemptsCreateWithoutStudent_open_answersInput, attemptsUncheckedCreateWithoutStudent_open_answersInput>
    where?: attemptsWhereInput
  }

  export type attemptsUpdateToOneWithWhereWithoutStudent_open_answersInput = {
    where?: attemptsWhereInput
    data: XOR<attemptsUpdateWithoutStudent_open_answersInput, attemptsUncheckedUpdateWithoutStudent_open_answersInput>
  }

  export type attemptsUpdateWithoutStudent_open_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUpdateManyWithoutAttemptsNestedInput
    students?: studentsUpdateOneRequiredWithoutAttemptsNestedInput
    exams?: examsUpdateOneRequiredWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateWithoutStudent_open_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutAttemptsNestedInput
  }

  export type studentsCreateWithoutStudents_examsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    attempts?: attemptsCreateNestedManyWithoutStudentsInput
    attendances?: attendancesCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookCreateNestedManyWithoutStudentsInput
    notifications?: notificationsCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersCreateNestedManyWithoutStudentsInput
    classes?: classesCreateNestedOneWithoutStudentsInput
    students_parents?: students_parentsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudents_examsInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
    class_id?: Uint8Array | null
    attempts?: attemptsUncheckedCreateNestedManyWithoutStudentsInput
    attendances?: attendancesUncheckedCreateNestedManyWithoutStudentsInput
    badges_history?: badges_historyUncheckedCreateNestedManyWithoutStudentsInput
    final_grades?: final_gradesUncheckedCreateNestedManyWithoutStudentsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutStudentsInput
    grades_gradebook?: grades_gradebookUncheckedCreateNestedManyWithoutStudentsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutStudentsInput
    questions_responses?: questions_responsesUncheckedCreateNestedManyWithoutStudentsInput
    student_closed_answers?: student_closed_answersUncheckedCreateNestedManyWithoutStudentsInput
    student_open_answers?: student_open_answersUncheckedCreateNestedManyWithoutStudentsInput
    students_parents?: students_parentsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudents_examsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudents_examsInput, studentsUncheckedCreateWithoutStudents_examsInput>
  }

  export type examsCreateWithoutStudents_examsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsCreateNestedManyWithoutExamsInput
    lessons: lessonsCreateNestedOneWithoutExamsInput
    teachers: teachersCreateNestedOneWithoutExamsInput
    files_repository?: files_repositoryCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsCreateNestedManyWithoutExamsInput
    notifications?: notificationsCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutStudents_examsInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
    attempts?: attemptsUncheckedCreateNestedManyWithoutExamsInput
    classes_exams?: classes_examsUncheckedCreateNestedManyWithoutExamsInput
    closed_questions?: closed_questionsUncheckedCreateNestedManyWithoutExamsInput
    files_repository?: files_repositoryUncheckedCreateNestedManyWithoutExamsInput
    grades_exams?: grades_examsUncheckedCreateNestedManyWithoutExamsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutExamsInput
    open_questions?: open_questionsUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutStudents_examsInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutStudents_examsInput, examsUncheckedCreateWithoutStudents_examsInput>
  }

  export type studentsUpsertWithoutStudents_examsInput = {
    update: XOR<studentsUpdateWithoutStudents_examsInput, studentsUncheckedUpdateWithoutStudents_examsInput>
    create: XOR<studentsCreateWithoutStudents_examsInput, studentsUncheckedCreateWithoutStudents_examsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudents_examsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudents_examsInput, studentsUncheckedUpdateWithoutStudents_examsInput>
  }

  export type studentsUpdateWithoutStudents_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    classes?: classesUpdateOneWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudents_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type examsUpsertWithoutStudents_examsInput = {
    update: XOR<examsUpdateWithoutStudents_examsInput, examsUncheckedUpdateWithoutStudents_examsInput>
    create: XOR<examsCreateWithoutStudents_examsInput, examsUncheckedCreateWithoutStudents_examsInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutStudents_examsInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutStudents_examsInput, examsUncheckedUpdateWithoutStudents_examsInput>
  }

  export type examsUpdateWithoutStudents_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutStudents_examsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type badges_historyCreateManyBadgesInput = {
    id?: Uint8Array
    date_awarded: Date | string
    student_id: Uint8Array
  }

  export type badges_historyUpdateWithoutBadgesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutBadges_historyNestedInput
  }

  export type badges_historyUncheckedUpdateWithoutBadgesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type badges_historyUncheckedUpdateManyWithoutBadgesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type badgesCreateManyBadges_categoriesInput = {
    id?: Uint8Array
    name: string
    description: string
  }

  export type badgesUpdateWithoutBadges_categoriesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badges_history?: badges_historyUpdateManyWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateWithoutBadges_categoriesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    badges_history?: badges_historyUncheckedUpdateManyWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateManyWithoutBadges_categoriesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type classes_examsCreateManyClassesInput = {
    exam_id: Uint8Array
  }

  export type lessonsCreateManyClassesInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    subject_id: Uint8Array
  }

  export type studentsCreateManyClassesInput = {
    id?: Uint8Array
    pesel: string
    email: string
    phone_number: string
    password: string
    first_name: string
    last_name: string
    reset_password_token?: string | null
    reset_password_expires?: Date | string | null
  }

  export type classes_examsUpdateWithoutClassesInput = {
    exams?: examsUpdateOneRequiredWithoutClasses_examsNestedInput
  }

  export type classes_examsUncheckedUpdateWithoutClassesInput = {
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classes_examsUncheckedUpdateManyWithoutClassesInput = {
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type lessonsUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: attendancesUpdateManyWithoutLessonsNestedInput
    exams?: examsUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUpdateOneWithoutLessonsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLessonsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attendances?: attendancesUncheckedUpdateManyWithoutLessonsNestedInput
    exams?: examsUncheckedUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUncheckedUpdateOneWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateManyWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type studentsUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUncheckedUpdateManyWithoutStudentsNestedInput
    attendances?: attendancesUncheckedUpdateManyWithoutStudentsNestedInput
    badges_history?: badges_historyUncheckedUpdateManyWithoutStudentsNestedInput
    final_grades?: final_gradesUncheckedUpdateManyWithoutStudentsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutStudentsNestedInput
    grades_gradebook?: grades_gradebookUncheckedUpdateManyWithoutStudentsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutStudentsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutStudentsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutStudentsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutStudentsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutStudentsNestedInput
    students_parents?: students_parentsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateManyWithoutClassesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    pesel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    reset_password_token?: NullableStringFieldUpdateOperationsInput | string | null
    reset_password_expires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type school_eventsCreateManyEvent_typesInput = {
    id?: Uint8Array
    name: string
    location: string
    description: string
    date: Date | string
    start_time: Date | string
    end_time: Date | string
  }

  export type school_eventsUpdateWithoutEvent_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type school_eventsUncheckedUpdateWithoutEvent_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type school_eventsUncheckedUpdateManyWithoutEvent_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancesCreateManyLessonsInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    student_id: Uint8Array
  }

  export type examsCreateManyLessonsInput = {
    id?: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    teacher_id: Uint8Array
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
  }

  export type gradebook_examsCreateManyLessonsInput = {
    id?: Uint8Array
    topic: string
    scope: string
  }

  export type attendancesUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    students?: studentsUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type attendancesUncheckedUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type attendancesUncheckedUpdateManyWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type examsUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateManyWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
  }

  export type gradebook_examsUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    topic?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type gradebook_examsUncheckedUpdateWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    topic?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type gradebook_examsUncheckedUpdateManyWithoutLessonsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    topic?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
  }

  export type students_parentsCreateManyParentsInput = {
    student_id: Uint8Array
  }

  export type students_parentsUpdateWithoutParentsInput = {
    students?: studentsUpdateOneRequiredWithoutStudents_parentsNestedInput
  }

  export type students_parentsUncheckedUpdateWithoutParentsInput = {
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type students_parentsUncheckedUpdateManyWithoutParentsInput = {
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookCreateManyProblem_typesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    reporter_id: Uint8Array
    user_type_id: Uint8Array
    status_id: Uint8Array
  }

  export type problems_gradebookUpdateWithoutProblem_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_types?: user_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput
    statuses?: statusesUpdateOneRequiredWithoutProblems_gradebookNestedInput
  }

  export type problems_gradebookUncheckedUpdateWithoutProblem_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    status_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookUncheckedUpdateManyWithoutProblem_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    status_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookCreateManyStatusesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    problem_type_id: Uint8Array
    reporter_id: Uint8Array
    user_type_id: Uint8Array
  }

  export type problems_gradebookUpdateWithoutStatusesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    problem_types?: problem_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput
    user_types?: user_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput
  }

  export type problems_gradebookUncheckedUpdateWithoutStatusesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    problem_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookUncheckedUpdateManyWithoutStatusesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    problem_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type attemptsCreateManyStudentsInput = {
    id?: Uint8Array
    exam_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
  }

  export type attendancesCreateManyStudentsInput = {
    id?: Uint8Array
    date_time: Date | string
    was_present?: boolean
    was_late?: boolean
    was_excused?: boolean
    lesson_id: Uint8Array
  }

  export type badges_historyCreateManyStudentsInput = {
    id?: Uint8Array
    date_awarded: Date | string
    badge_id: Uint8Array
  }

  export type final_gradesCreateManyStudentsInput = {
    id?: Uint8Array
    grade: number
    subject_id: Uint8Array
    teacher_id: Uint8Array
    semester_id: Uint8Array
  }

  export type grades_examsCreateManyStudentsInput = {
    id?: Uint8Array
    attempt_id: Uint8Array
    exam_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
  }

  export type grades_gradebookCreateManyStudentsInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    subject_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type notificationsCreateManyStudentsInput = {
    id?: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
    exam_id?: Uint8Array | null
  }

  export type questions_responsesCreateManyStudentsInput = {
    id?: Uint8Array
    content: string
    question_id: Uint8Array
  }

  export type student_closed_answersCreateManyStudentsInput = {
    id?: Uint8Array
    closed_question_id: Uint8Array
    closed_answer_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_open_answersCreateManyStudentsInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    score?: number | null
    attempt_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type students_examsCreateManyStudentsInput = {
    exam_id: Uint8Array
  }

  export type students_parentsCreateManyStudentsInput = {
    parent_id: Uint8Array
  }

  export type attemptsUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUpdateManyWithoutAttemptsNestedInput
    exams?: examsUpdateOneRequiredWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendancesUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    lessons?: lessonsUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type attendancesUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type attendancesUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_present?: BoolFieldUpdateOperationsInput | boolean
    was_late?: BoolFieldUpdateOperationsInput | boolean
    was_excused?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type badges_historyUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    badges?: badgesUpdateOneRequiredWithoutBadges_historyNestedInput
  }

  export type badges_historyUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    badge_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type badges_historyUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_awarded?: DateTimeFieldUpdateOperationsInput | Date | string
    badge_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type final_gradesUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    subjects?: subjectsUpdateOneRequiredWithoutFinal_gradesNestedInput
    teachers?: teachersUpdateOneRequiredWithoutFinal_gradesNestedInput
    semesters?: semestersUpdateOneRequiredWithoutFinal_gradesNestedInput
  }

  export type final_gradesUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type final_gradesUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_examsUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: examsUpdateOneRequiredWithoutGrades_examsNestedInput
  }

  export type grades_examsUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grades_examsUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grades_gradebookUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectsUpdateOneRequiredWithoutGrades_gradebookNestedInput
    teachers?: teachersUpdateOneRequiredWithoutGrades_gradebookNestedInput
  }

  export type grades_gradebookUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_gradebookUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type notificationsUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    exams?: examsUpdateOneWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    exam_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type notificationsUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    exam_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type questions_responsesUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    questions?: questionsUpdateOneRequiredWithoutQuestions_responsesNestedInput
  }

  export type questions_responsesUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    question_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_responsesUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    question_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type student_closed_answersUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_questions?: closed_questionsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    closed_answers?: closed_answersUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    attempts?: attemptsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
  }

  export type student_closed_answersUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_closed_answersUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_open_answersUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    open_questions?: open_questionsUpdateOneRequiredWithoutStudent_open_answersNestedInput
    attempts?: attemptsUpdateOneRequiredWithoutStudent_open_answersNestedInput
  }

  export type student_open_answersUncheckedUpdateWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_open_answersUncheckedUpdateManyWithoutStudentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type students_examsUpdateWithoutStudentsInput = {
    exams?: examsUpdateOneRequiredWithoutStudents_examsNestedInput
  }

  export type students_examsUncheckedUpdateWithoutStudentsInput = {
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type students_examsUncheckedUpdateManyWithoutStudentsInput = {
    exam_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type students_parentsUpdateWithoutStudentsInput = {
    parents?: parentsUpdateOneRequiredWithoutStudents_parentsNestedInput
  }

  export type students_parentsUncheckedUpdateWithoutStudentsInput = {
    parent_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type students_parentsUncheckedUpdateManyWithoutStudentsInput = {
    parent_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type final_gradesCreateManySubjectsInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    teacher_id: Uint8Array
    semester_id: Uint8Array
  }

  export type grades_gradebookCreateManySubjectsInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    student_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type lessonsCreateManySubjectsInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    teacher_id: Uint8Array
    class_id: Uint8Array
  }

  export type teachers_subjectsCreateManySubjectsInput = {
    teacher_id: Uint8Array
  }

  export type final_gradesUpdateWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    students?: studentsUpdateOneRequiredWithoutFinal_gradesNestedInput
    teachers?: teachersUpdateOneRequiredWithoutFinal_gradesNestedInput
    semesters?: semestersUpdateOneRequiredWithoutFinal_gradesNestedInput
  }

  export type final_gradesUncheckedUpdateWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type final_gradesUncheckedUpdateManyWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_gradebookUpdateWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutGrades_gradebookNestedInput
    teachers?: teachersUpdateOneRequiredWithoutGrades_gradebookNestedInput
  }

  export type grades_gradebookUncheckedUpdateWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_gradebookUncheckedUpdateManyWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type lessonsUpdateWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: attendancesUpdateManyWithoutLessonsNestedInput
    exams?: examsUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUpdateOneWithoutLessonsNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLessonsNestedInput
    classes?: classesUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attendances?: attendancesUncheckedUpdateManyWithoutLessonsNestedInput
    exams?: examsUncheckedUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUncheckedUpdateOneWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateManyWithoutSubjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type teachers_subjectsUpdateWithoutSubjectsInput = {
    teachers?: teachersUpdateOneRequiredWithoutTeachers_subjectsNestedInput
  }

  export type teachers_subjectsUncheckedUpdateWithoutSubjectsInput = {
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type teachers_subjectsUncheckedUpdateManyWithoutSubjectsInput = {
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questionsCreateManySurveysInput = {
    id?: Uint8Array
    content: string
    question_type_id: Uint8Array
  }

  export type questionsUpdateWithoutSurveysInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    questions_types?: questions_typesUpdateOneRequiredWithoutQuestionsNestedInput
    questions_possible_responses?: questions_possible_responsesUpdateManyWithoutQuestionsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutSurveysInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    question_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutSurveysInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    question_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classesCreateManyTeachersInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    school_year_id: Uint8Array
  }

  export type examsCreateManyTeachersInput = {
    id?: Uint8Array
    lesson_id: Uint8Array
    title?: string | null
    topic?: string | null
    scope?: string | null
    start_date_time: Date | string
    end_date_time: Date | string
    visibility?: boolean
    number_of_questions?: number | null
    duration: number
    description?: string | null
    number_of_tries?: number | null
    multiple_tries?: boolean
    time_limit_for_each_question?: boolean
    randomise_questions?: boolean
    end_test_after_leaving_window?: boolean
    block_copying_pasting?: boolean
    randomise_answers?: boolean
    latest_attempt_counts?: boolean
    best_attempt_counts?: boolean
    hide_results?: boolean
    display_points_per_question?: boolean
    show_correct_answers?: boolean
    allow_navigation?: boolean
    allow_review?: boolean
  }

  export type final_gradesCreateManyTeachersInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    subject_id: Uint8Array
    semester_id: Uint8Array
  }

  export type grades_gradebookCreateManyTeachersInput = {
    id?: Uint8Array
    description: string
    grade: number
    weight: number
    date_given: Date | string
    student_id: Uint8Array
    subject_id: Uint8Array
  }

  export type lessonsCreateManyTeachersInput = {
    id?: Uint8Array
    description?: string | null
    date: Date | string
    start_time: Date | string
    end_time: Date | string
    class_id: Uint8Array
    subject_id: Uint8Array
  }

  export type teachers_subjectsCreateManyTeachersInput = {
    subject_id: Uint8Array
  }

  export type classesUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_names?: class_namesUpdateOneRequiredWithoutClassesNestedInput
    school_years?: school_yearsUpdateOneRequiredWithoutClassesNestedInput
    classes_exams?: classes_examsUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUpdateManyWithoutClassesNestedInput
    students?: studentsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    classes_exams?: classes_examsUncheckedUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutClassesNestedInput
    students?: studentsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type examsUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUpdateManyWithoutExamsNestedInput
    lessons?: lessonsUpdateOneRequiredWithoutExamsNestedInput
    files_repository?: files_repositoryUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
    attempts?: attemptsUncheckedUpdateManyWithoutExamsNestedInput
    classes_exams?: classes_examsUncheckedUpdateManyWithoutExamsNestedInput
    closed_questions?: closed_questionsUncheckedUpdateManyWithoutExamsNestedInput
    files_repository?: files_repositoryUncheckedUpdateManyWithoutExamsNestedInput
    grades_exams?: grades_examsUncheckedUpdateManyWithoutExamsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutExamsNestedInput
    open_questions?: open_questionsUncheckedUpdateManyWithoutExamsNestedInput
    students_exams?: students_examsUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateManyWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    lesson_id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    start_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    visibility?: BoolFieldUpdateOperationsInput | boolean
    number_of_questions?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_tries?: NullableIntFieldUpdateOperationsInput | number | null
    multiple_tries?: BoolFieldUpdateOperationsInput | boolean
    time_limit_for_each_question?: BoolFieldUpdateOperationsInput | boolean
    randomise_questions?: BoolFieldUpdateOperationsInput | boolean
    end_test_after_leaving_window?: BoolFieldUpdateOperationsInput | boolean
    block_copying_pasting?: BoolFieldUpdateOperationsInput | boolean
    randomise_answers?: BoolFieldUpdateOperationsInput | boolean
    latest_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    best_attempt_counts?: BoolFieldUpdateOperationsInput | boolean
    hide_results?: BoolFieldUpdateOperationsInput | boolean
    display_points_per_question?: BoolFieldUpdateOperationsInput | boolean
    show_correct_answers?: BoolFieldUpdateOperationsInput | boolean
    allow_navigation?: BoolFieldUpdateOperationsInput | boolean
    allow_review?: BoolFieldUpdateOperationsInput | boolean
  }

  export type final_gradesUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    students?: studentsUpdateOneRequiredWithoutFinal_gradesNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutFinal_gradesNestedInput
    semesters?: semestersUpdateOneRequiredWithoutFinal_gradesNestedInput
  }

  export type final_gradesUncheckedUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type final_gradesUncheckedUpdateManyWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_gradebookUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutGrades_gradebookNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutGrades_gradebookNestedInput
  }

  export type grades_gradebookUncheckedUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_gradebookUncheckedUpdateManyWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    weight?: IntFieldUpdateOperationsInput | number
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type lessonsUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: attendancesUpdateManyWithoutLessonsNestedInput
    exams?: examsUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUpdateOneWithoutLessonsNestedInput
    classes?: classesUpdateOneRequiredWithoutLessonsNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attendances?: attendancesUncheckedUpdateManyWithoutLessonsNestedInput
    exams?: examsUncheckedUpdateManyWithoutLessonsNestedInput
    gradebook_exams?: gradebook_examsUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: homeworksUncheckedUpdateOneWithoutLessonsNestedInput
  }

  export type lessonsUncheckedUpdateManyWithoutTeachersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type teachers_subjectsUpdateWithoutTeachersInput = {
    subjects?: subjectsUpdateOneRequiredWithoutTeachers_subjectsNestedInput
  }

  export type teachers_subjectsUncheckedUpdateWithoutTeachersInput = {
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type teachers_subjectsUncheckedUpdateManyWithoutTeachersInput = {
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type messagesCreateManyUser_types_messages_sender_type_idTouser_typesInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    receiver_id: Uint8Array
    receiver_type_id: Uint8Array
  }

  export type messagesCreateManyUser_types_messages_receiver_type_idTouser_typesInput = {
    id?: Uint8Array
    subject: string
    content: string
    date_time: Date | string
    was_read?: boolean
    sender_id: Uint8Array
    sender_type_id: Uint8Array
    receiver_id: Uint8Array
  }

  export type problems_gradebookCreateManyUser_typesInput = {
    id?: Uint8Array
    description: string
    reported_time: Date | string
    problem_type_id: Uint8Array
    reporter_id: Uint8Array
    status_id: Uint8Array
  }

  export type messagesUpdateWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_types_messages_receiver_type_idTouser_types?: user_typesUpdateOneRequiredWithoutMessages_messages_receiver_type_idTouser_typesNestedInput
  }

  export type messagesUncheckedUpdateWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type messagesUncheckedUpdateManyWithoutUser_types_messages_sender_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type messagesUpdateWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
    user_types_messages_sender_type_idTouser_types?: user_typesUpdateOneRequiredWithoutMessages_messages_sender_type_idTouser_typesNestedInput
  }

  export type messagesUncheckedUpdateWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    sender_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type messagesUncheckedUpdateManyWithoutUser_types_messages_receiver_type_idTouser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date_time?: DateTimeFieldUpdateOperationsInput | Date | string
    was_read?: BoolFieldUpdateOperationsInput | boolean
    sender_id?: BytesFieldUpdateOperationsInput | Uint8Array
    sender_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    receiver_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookUpdateWithoutUser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    problem_types?: problem_typesUpdateOneRequiredWithoutProblems_gradebookNestedInput
    statuses?: statusesUpdateOneRequiredWithoutProblems_gradebookNestedInput
  }

  export type problems_gradebookUncheckedUpdateWithoutUser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    problem_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    status_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type problems_gradebookUncheckedUpdateManyWithoutUser_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    reported_time?: DateTimeFieldUpdateOperationsInput | Date | string
    problem_type_id?: BytesFieldUpdateOperationsInput | Uint8Array
    reporter_id?: BytesFieldUpdateOperationsInput | Uint8Array
    status_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classesCreateManySchool_yearsInput = {
    id?: Uint8Array
    class_name_id: Uint8Array
    teacher_id?: Uint8Array | null
  }

  export type semestersCreateManySchool_yearsInput = {
    id?: Uint8Array
    semester: number
    start_date: Date | string
    end_date: Date | string
  }

  export type classesUpdateWithoutSchool_yearsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_names?: class_namesUpdateOneRequiredWithoutClassesNestedInput
    teachers?: teachersUpdateOneWithoutClassesNestedInput
    classes_exams?: classes_examsUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUpdateManyWithoutClassesNestedInput
    students?: studentsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutSchool_yearsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    classes_exams?: classes_examsUncheckedUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutClassesNestedInput
    students?: studentsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutSchool_yearsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    class_name_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type semestersUpdateWithoutSchool_yearsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    final_grades?: final_gradesUpdateManyWithoutSemestersNestedInput
  }

  export type semestersUncheckedUpdateWithoutSchool_yearsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    final_grades?: final_gradesUncheckedUpdateManyWithoutSemestersNestedInput
  }

  export type semestersUncheckedUpdateManyWithoutSchool_yearsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    semester?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type final_gradesCreateManySemestersInput = {
    id?: Uint8Array
    grade: number
    student_id: Uint8Array
    subject_id: Uint8Array
    teacher_id: Uint8Array
  }

  export type final_gradesUpdateWithoutSemestersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    students?: studentsUpdateOneRequiredWithoutFinal_gradesNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutFinal_gradesNestedInput
    teachers?: teachersUpdateOneRequiredWithoutFinal_gradesNestedInput
  }

  export type final_gradesUncheckedUpdateWithoutSemestersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type final_gradesUncheckedUpdateManyWithoutSemestersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    grade?: IntFieldUpdateOperationsInput | number
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    subject_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classesCreateManyClass_namesInput = {
    id?: Uint8Array
    school_year_id: Uint8Array
    teacher_id?: Uint8Array | null
  }

  export type classesUpdateWithoutClass_namesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_years?: school_yearsUpdateOneRequiredWithoutClassesNestedInput
    teachers?: teachersUpdateOneWithoutClassesNestedInput
    classes_exams?: classes_examsUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUpdateManyWithoutClassesNestedInput
    students?: studentsUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateWithoutClass_namesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    classes_exams?: classes_examsUncheckedUpdateManyWithoutClassesNestedInput
    lessons?: lessonsUncheckedUpdateManyWithoutClassesNestedInput
    students?: studentsUncheckedUpdateManyWithoutClassesNestedInput
  }

  export type classesUncheckedUpdateManyWithoutClass_namesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    school_year_id?: BytesFieldUpdateOperationsInput | Uint8Array
    teacher_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type attemptsCreateManyExamsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    attempt_number: number
    total_score?: number | null
    max_score?: number | null
    graded?: boolean
    start_time?: Date | string
    end_time?: Date | string | null
  }

  export type classes_examsCreateManyExamsInput = {
    class_id: Uint8Array
  }

  export type closed_questionsCreateManyExamsInput = {
    id?: Uint8Array
    score?: number | null
    is_multiple?: boolean | null
    description: string
  }

  export type files_repositoryCreateManyExamsInput = {
    id?: Uint8Array
    title: string
    description: string
    file: Uint8Array
  }

  export type grades_examsCreateManyExamsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    attempt_id: Uint8Array
    description: string
    grade: string
    date_given?: Date | string
  }

  export type notificationsCreateManyExamsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    description: string
    notification_date?: Date | string
    is_read?: boolean
  }

  export type open_questionsCreateManyExamsInput = {
    id?: Uint8Array
    auto_check?: boolean
    description?: string | null
    score: number
  }

  export type students_examsCreateManyExamsInput = {
    students_id: Uint8Array
  }

  export type attemptsUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUpdateManyWithoutAttemptsNestedInput
    students?: studentsUpdateOneRequiredWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutAttemptsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutAttemptsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutAttemptsNestedInput
  }

  export type attemptsUncheckedUpdateManyWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_number?: IntFieldUpdateOperationsInput | number
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    max_score?: NullableIntFieldUpdateOperationsInput | number | null
    graded?: BoolFieldUpdateOperationsInput | boolean
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classes_examsUpdateWithoutExamsInput = {
    classes?: classesUpdateOneRequiredWithoutClasses_examsNestedInput
  }

  export type classes_examsUncheckedUpdateWithoutExamsInput = {
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type classes_examsUncheckedUpdateManyWithoutExamsInput = {
    class_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type closed_questionsUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUpdateManyWithoutClosed_questionsNestedInput
    closed_answers?: closed_answersUpdateManyWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUpdateManyWithoutClosed_questionsNestedInput
  }

  export type closed_questionsUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutClosed_questionsNestedInput
    closed_answers?: closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutClosed_questionsNestedInput
  }

  export type closed_questionsUncheckedUpdateManyWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    is_multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type files_repositoryUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    file?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type files_repositoryUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    file?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type files_repositoryUncheckedUpdateManyWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    file?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type grades_examsUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutGrades_examsNestedInput
  }

  export type grades_examsUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grades_examsUncheckedUpdateManyWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    date_given?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    students?: studentsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificationsUncheckedUpdateManyWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
    notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type open_questionsUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUpdateManyWithoutOpen_questionsNestedInput
    open_answers?: open_answersUpdateManyWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUpdateManyWithoutOpen_questionsNestedInput
  }

  export type open_questionsUncheckedUpdateWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    attempt_questions?: attempt_questionsUncheckedUpdateManyWithoutOpen_questionsNestedInput
    open_answers?: open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
    student_open_answers?: student_open_answersUncheckedUpdateManyWithoutOpen_questionsNestedInput
  }

  export type open_questionsUncheckedUpdateManyWithoutExamsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    auto_check?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
  }

  export type students_examsUpdateWithoutExamsInput = {
    students?: studentsUpdateOneRequiredWithoutStudents_examsNestedInput
  }

  export type students_examsUncheckedUpdateWithoutExamsInput = {
    students_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type students_examsUncheckedUpdateManyWithoutExamsInput = {
    students_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_possible_responsesCreateManyQuestionsInput = {
    id?: Uint8Array
    content: string
  }

  export type questions_responsesCreateManyQuestionsInput = {
    id?: Uint8Array
    content: string
    student_id: Uint8Array
  }

  export type questions_possible_responsesUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
  }

  export type questions_possible_responsesUncheckedUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
  }

  export type questions_possible_responsesUncheckedUpdateManyWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
  }

  export type questions_responsesUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    students?: studentsUpdateOneRequiredWithoutQuestions_responsesNestedInput
  }

  export type questions_responsesUncheckedUpdateWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questions_responsesUncheckedUpdateManyWithoutQuestionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type questionsCreateManyQuestions_typesInput = {
    id?: Uint8Array
    content: string
    survey_id: Uint8Array
  }

  export type questionsUpdateWithoutQuestions_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    surveys?: surveysUpdateOneRequiredWithoutQuestionsNestedInput
    questions_possible_responses?: questions_possible_responsesUpdateManyWithoutQuestionsNestedInput
    questions_responses?: questions_responsesUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestions_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    survey_id?: BytesFieldUpdateOperationsInput | Uint8Array
    questions_possible_responses?: questions_possible_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
    questions_responses?: questions_responsesUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutQuestions_typesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    survey_id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type attempt_questionsCreateManyAttemptsInput = {
    id: Uint8Array
    open_question_id?: Uint8Array | null
    closed_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type student_closed_answersCreateManyAttemptsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_question_id: Uint8Array
    closed_answer_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_open_answersCreateManyAttemptsInput = {
    id?: Uint8Array
    open_question_id: Uint8Array
    score?: number | null
    student_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type attempt_questionsUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    open_questions?: open_questionsUpdateOneWithoutAttempt_questionsNestedInput
    closed_questions?: closed_questionsUpdateOneWithoutAttempt_questionsNestedInput
  }

  export type attempt_questionsUncheckedUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    closed_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attempt_questionsUncheckedUpdateManyWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    closed_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_closed_answersUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    closed_questions?: closed_questionsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    closed_answers?: closed_answersUpdateOneRequiredWithoutStudent_closed_answersNestedInput
  }

  export type student_closed_answersUncheckedUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_closed_answersUncheckedUpdateManyWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_open_answersUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    open_questions?: open_questionsUpdateOneRequiredWithoutStudent_open_answersNestedInput
    students?: studentsUpdateOneRequiredWithoutStudent_open_answersNestedInput
  }

  export type student_open_answersUncheckedUpdateWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_open_answersUncheckedUpdateManyWithoutAttemptsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_closed_answersCreateManyClosed_answersInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_question_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type student_closed_answersUpdateWithoutClosed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    closed_questions?: closed_questionsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    attempts?: attemptsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
  }

  export type student_closed_answersUncheckedUpdateWithoutClosed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_closed_answersUncheckedUpdateManyWithoutClosed_answersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attempt_questionsCreateManyClosed_questionsInput = {
    id: Uint8Array
    attempt_id: Uint8Array
    open_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type closed_answersCreateManyClosed_questionsInput = {
    id?: Uint8Array
    is_correct?: boolean | null
    description: string
  }

  export type student_closed_answersCreateManyClosed_questionsInput = {
    id?: Uint8Array
    student_id: Uint8Array
    closed_answer_id: Uint8Array
    attempt_id: Uint8Array
    correctness?: boolean | null
    date_time?: Date | string | null
  }

  export type attempt_questionsUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateOneRequiredWithoutAttempt_questionsNestedInput
    open_questions?: open_questionsUpdateOneWithoutAttempt_questionsNestedInput
  }

  export type attempt_questionsUncheckedUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attempt_questionsUncheckedUpdateManyWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    open_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type closed_answersUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    student_closed_answers?: student_closed_answersUpdateManyWithoutClosed_answersNestedInput
  }

  export type closed_answersUncheckedUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
    student_closed_answers?: student_closed_answersUncheckedUpdateManyWithoutClosed_answersNestedInput
  }

  export type closed_answersUncheckedUpdateManyWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    is_correct?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type student_closed_answersUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    closed_answers?: closed_answersUpdateOneRequiredWithoutStudent_closed_answersNestedInput
    attempts?: attemptsUpdateOneRequiredWithoutStudent_closed_answersNestedInput
  }

  export type student_closed_answersUncheckedUpdateWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_closed_answersUncheckedUpdateManyWithoutClosed_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_answer_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    correctness?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attempt_questionsCreateManyOpen_questionsInput = {
    id: Uint8Array
    attempt_id: Uint8Array
    closed_question_id?: Uint8Array | null
    question_type: $Enums.attempt_questions_question_type
    created_at?: Date | string | null
  }

  export type open_answersCreateManyOpen_questionsInput = {
    id?: Uint8Array
    description: string
  }

  export type student_open_answersCreateManyOpen_questionsInput = {
    id?: Uint8Array
    score?: number | null
    student_id: Uint8Array
    attempt_id: Uint8Array
    date_time?: Date | string | null
    description?: string | null
  }

  export type attempt_questionsUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: attemptsUpdateOneRequiredWithoutAttempt_questionsNestedInput
    closed_questions?: closed_questionsUpdateOneWithoutAttempt_questionsNestedInput
  }

  export type attempt_questionsUncheckedUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attempt_questionsUncheckedUpdateManyWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    closed_question_id?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    question_type?: Enumattempt_questions_question_typeFieldUpdateOperationsInput | $Enums.attempt_questions_question_type
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type open_answersUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
  }

  export type open_answersUncheckedUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
  }

  export type open_answersUncheckedUpdateManyWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    description?: StringFieldUpdateOperationsInput | string
  }

  export type student_open_answersUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_open_answersNestedInput
    attempts?: attemptsUpdateOneRequiredWithoutStudent_open_answersNestedInput
  }

  export type student_open_answersUncheckedUpdateWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_open_answersUncheckedUpdateManyWithoutOpen_questionsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    score?: NullableIntFieldUpdateOperationsInput | number | null
    student_id?: BytesFieldUpdateOperationsInput | Uint8Array
    attempt_id?: BytesFieldUpdateOperationsInput | Uint8Array
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}